<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SharpRemote</name>
    </assembly>
    <members>
        <member name="T:SharpRemote.Attributes.AfterDeserializeAttribute">
            <summary>
                This attribute can be applied to instance methods which are invoked after an object
                of the instance's type was deserialized.
            </summary>
            <remarks>
                A method with this attribute must be publicly accessible, be an instance method (i.e. non-static)
                and may only be part of reference types (classes, not structs) with the <see cref="T:System.Runtime.Serialization.DataContractAttribute" />.
            </remarks>
            <remarks>
                A type may contain exactly one method with these attributes. If a type hierarchy needs one per sub-type,
                then it is advised that the base class declares their method virtual (or provide an additional protected virtual method).
            </remarks>
        </member>
        <member name="P:SharpRemote.Attributes.AfterDeserializeAttribute.Method">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.Attributes.AfterSerializeAttribute">
            <summary>
                This attribute can be applied to instance methods which are invoked after an object
                of the instance's type was serialized.
            </summary>
            <remarks>
                A method with this attribute must be publicly accessible, be an instance method (i.e. non-static)
                and may only be part of reference types (classes, not structs) with the <see cref="T:System.Runtime.Serialization.DataContractAttribute"/>.
            </remarks>
            <remarks>
                A type may contain exactly one method with these attributes. If a type hierarchy needs one per sub-type,
                then it is advised that the base class declares their method virtual (or provide an additional protected virtual method).
            </remarks>
        </member>
        <member name="P:SharpRemote.Attributes.AfterSerializeAttribute.Method">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.Attributes.AsyncRemoteAttribute">
            <summary>
            This attribute can be applied to methods with a return type of <see cref="T:System.Void"/>
            in order to indicate that it should behave exactly like a method that returns <see cref="T:System.Threading.Tasks.Task"/>:
            The method is dispatched asynchronously, however compared to <see cref="T:System.Threading.Tasks.Task"/>, there is no
            programmatic way to know when the method has finished, nor when it threw an exception.
            </summary>
        </member>
        <member name="T:SharpRemote.Attributes.BeforeDeserializeAttribute">
            <summary>
                This attribute can be applied to instance methods which are invoked before an object
                of the instance's type is deserialized.
            </summary>
            <remarks>
                A method with this attribute must be publicly accessible, be an instance method (i.e. non-static)
                and may only be part of reference types (classes, not structs) with the <see cref="T:System.Runtime.Serialization.DataContractAttribute" />.
            </remarks>
            <remarks>
                A type may contain exactly one method with these attributes. If a type hierarchy needs one per sub-type,
                then it is advised that the base class declares their method virtual (or provide an additional protected virtual
                method).
            </remarks>
        </member>
        <member name="P:SharpRemote.Attributes.BeforeDeserializeAttribute.Method">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.Attributes.BeforeSerializeAttribute">
            <summary>
                This attribute can be applied to instance methods which are invoked before an object
                of the instance's type is serialized.
            </summary>
            <remarks>
                A method with this attribute must be publicly accessible, be an instance method (i.e. non-static)
                and may only be part of reference types (classes, not structs) with the <see cref="T:System.Runtime.Serialization.DataContractAttribute"/>.
            </remarks>
            <remarks>
                A type may contain exactly one method with these attributes. If a type hierarchy needs one per sub-type,
                then it is advised that the base class declares their method virtual (or provide an additional protected virtual method).
            </remarks>
        </member>
        <member name="P:SharpRemote.Attributes.BeforeSerializeAttribute.Method">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.Attributes.SerializationMethodAttribute">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.Attributes.SerializationMethodAttribute.Method">
            <summary>
                The type of method being attributed.
            </summary>
        </member>
        <member name="T:SharpRemote.Attributes.SerializationSurrogateForAttribute">
            <summary>
                This attributes identifies a type as being a surrogate type which shall
                be used *instead* of the real thing when serializing.
            </summary>
            <remarks>
                A surrogate requires two publicly accessible conversion methods which convert
                to and from their surrogate. <see cref="T:SharpRemote.CodeGeneration.Serialization.IPAddressSurrogate" /> for a specific
                example of how implement a non-generic surrogate and <see cref="T:SharpRemote.CodeGeneration.Serialization.KeyValuePairSurrogate`2" />
                for a generic-surrogate.
            </remarks>
            <remarks>
                Surrogate types should be used when:
                A) You want to ensure that an object of type X can be serialized, but you have no control
                of its implementation and thus cannot add the appropriate <see cref="T:System.Runtime.Serialization.DataContractAttribute" />.
                B) You want to separate the serialization aspect from a type, for example because said
                type shall not expose public setters which are only necessary for serialization
            </remarks>
            <remarks>
                Surrogate types are not automatically identified and must be registered
                manually using <see cref="M:SharpRemote.ISerializer2.RegisterType(System.Type)" />.
                If you create a generic type surrogate, then you can registers its open type definition once without
                having to call <see cref="M:SharpRemote.ISerializer2.RegisterType(System.Type)" /> for every variation its of type arguments.
            </remarks>
        </member>
        <member name="M:SharpRemote.Attributes.SerializationSurrogateForAttribute.#ctor(System.Type)">
            <summary>
                Initializes this object.
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:SharpRemote.Attributes.SerializationSurrogateForAttribute.Type">
            <summary>
                The type for which this type is a surrogate.
            </summary>
        </member>
        <member name="T:SharpRemote.ByReferenceAttribute">
            <summary>
            Can be used to signal that a specific parameter, return value, class- or interface type shall not be marshalled by value
            but by reference instead. This means that instead of serializing the value, a servant will be created (or re-used if it already exists) 
            and the other side (caller/callee depending on whether its a parameter or a return value) will obtain a proxy (either newly
            created or re-used if one already exists) to the value.
            </summary>
        </member>
        <member name="M:SharpRemote.BlockingQueue`1.Enqueue(`0)">
            <summary>
                Adds the given item, blocks if the maximum capacity has been reached until at least one
                item has been retrieved.
            </summary>
            <param name="value"></param>
            <exception cref="T:System.OperationCanceledException">When this collection has been disposed of</exception>
        </member>
        <member name="M:SharpRemote.BlockingQueue`1.Dequeue">
            <summary>
                Removes the first item from this collection.
            </summary>
            <returns>True when the item was removed, false when this collection was disposed</returns>
        </member>
        <member name="T:SharpRemote.CodeGeneration.FaultTolerance.Fallback.DefaultFallbackCreator`1">
            <summary>
                Responsible for creating objects which implement a given interface.
                Methods and properties don't do anything besides returning default values.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:SharpRemote.CodeGeneration.FaultTolerance.Fallback.AsyncStateMachineCompiler">
            <summary>
                Responsible for creating a state machine capable of intercepting failed tasks and delegating
                calls to another new task, in case of failure.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.FaultTolerance.Fallback.AsyncStateMachineCompiler.StartStateMachineAtTargetSite(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo,System.Reflection.FieldInfo,System.Reflection.ConstructorInfo,System.Reflection.MethodInfo,System.Reflection.Emit.LocalBuilder)">
            <summary>
                Injects code necessary to start the async state machine at the target site.
                Moves the reference to the state machine's task into the given local <paramref name="task" />.
            </summary>
            <param name="gen"></param>
            <param name="subject"></param>
            <param name="fallback"></param>
            <param name="constructor"></param>
            <param name="invokeSubject"></param>
            <param name="task"></param>
        </member>
        <member name="T:SharpRemote.CodeGeneration.FaultTolerance.Fallback.TimeoutProxyCreator`1">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpRemote.CodeGeneration.FaultTolerance.IProxyFactory`1">
            <summary>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SharpRemote.CodeGeneration.FaultTolerance.IProxyFactory`1.WithMaximumLatencyOf(System.TimeSpan)">
            <summary>
                Method calls on the created never exceed the given maximum latency (within reason).
                Any method which appears to execute longer will be aborted and a <see cref="T:System.TimeoutException" />
                will be thrown.
            </summary>
            <remarks>
                This method should **only** be used in cases where the method you are calling cannot possibly
                be cancelled in any way.
            </remarks>
            <param name="maximumMethodLatency"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.FaultTolerance.IProxyFactory`1.WithDefaultFallback">
            <summary>
                All exceptions thrown by methods of the subject are caught and handled.
                If the method call has a return value, then the default value for that
                particular type is returned instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.FaultTolerance.IProxyFactory`1.WithFallbackTo(`0)">
            <summary>
                All exceptions thrown by methods of the subject are caught and handled.
                The specified fallback implementation is called in this case and, if
                the method happens to have a return type, the value returned from the fallback
                is returned.
            </summary>
            <remarks>
                Exceptions thrown by the fallback are NOT handled.
            </remarks>
            <remarks>
                You can chain various fallbacks and they will be executed in the chained order.
            </remarks>
            <param name="fallback"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.FaultTolerance.IProxyFactory`1.WithMaximumRetries(System.Int32)">
            <summary>
                All exceptions thrown by methods of the subject are caught and handled.
                The method in question will be invoked again for the given amount of times
                or until it returns without throwing.
            </summary>
            <param name="numberOfRetries"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.FaultTolerance.IProxyFactory`1.Create">
            <summary>
                Finally creates the proxy with the configured behaviour.
            </summary>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.CodeGeneration.FaultTolerance.ProxyCreator">
            <summary>
                Responsible for creating proxy objects implementing a specified interface,
                forwarding method calls to another object while attempting to hide failures
                from the caller.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.FaultTolerance.ProxyCreator.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.FaultTolerance.ProxyCreator.#ctor(System.Reflection.Emit.ModuleBuilder)">
            <summary>
            </summary>
            <param name="moduleBuilder"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:SharpRemote.CodeGeneration.FaultTolerance.ProxyCreator.PrepareProxyFor``1(``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="subject"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler">
            <summary>
                Base class for all method compilers.
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.CultureInfoGetInvariantCulture">
            <summary>
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.StringFormatObject">
            <summary>
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.StringEquals">
            <summary>
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.TypeGetTypeFromHandle">
            <summary>
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.HardcodedLevels">
            <summary>
                A list of accessors to special <see cref="T:log4net.Core.Level" /> values
                which shall be regarded as singletons: A serializer shall ensure
                that if an object equal to one of the given array is serialized, then
                deserialization shall produce the same object (and not a new one).
            </summary>
            <remarks>
                This list will never change in order and new values will only ever be appended
                to the bottom.
            </remarks>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.Singleton">
            <summary>
                Provides access to a singleton value which is accessible via static property
                or field.
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.Singleton.Field">
            <summary>
                The field through which the singleton value can be retrieved,
                may be null.
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.Singleton.Property">
            <summary>
                The property through which the singleton value can be retrieved,
                may be null.
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.Singleton.Name">
            <summary>
                A name for this singleton value.
                Will never change, ever and can be used for serialization, if desired.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.Singleton.FromField``1(System.String)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fieldName"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.Singleton.FromProperty``1(System.String)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fieldName"></param>
            <returns></returns>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.Method">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractMethodCompiler.Compile(SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler,SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage{SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler})">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.CompilationContext">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.CompilationContext.TypeDescription">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.CompilationContext.Type">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.CompilationContext.TypeBuilder">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.CompilationContext.SerializerType">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.CompilationContext.WriterType">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.CompilationContext.ReaderType">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler">
            <summary>
                Responsible for compiling and providing methods which take care of serializing/deserializing values.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler.#ctor(System.Reflection.Emit.TypeBuilder,SharpRemote.ITypeDescription,SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler,SharpRemote.CodeGeneration.Serialization.AbstractWriteObjectMethodCompiler,SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler,SharpRemote.CodeGeneration.Serialization.AbstractReadObjectMethodCompiler)">
            <summary>
                Initializes this object.
            </summary>
            <param name="typeBuilder"></param>
            <param name="typeDescription"></param>
            <param name="writeValueMethodCompiler"></param>
            <param name="writeObjectMethodCompiler"></param>
            <param name="readValueMethodCompiler"></param>
            <param name="readObjectMethodCompiler"></param>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler.WriterType">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler.ReaderType">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler.TypeDescription">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler.WriteValueMethod">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler.WriteObjectMethod">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler.ReadValueMethod">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler.ReadObjectMethod">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler.Compile(SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage{SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler})">
            <summary>
                Emits il-code for all methods.
            </summary>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.Binary.BinaryWriteValueMethodCompiler">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.Binary.Serializers.LevelSerializer.Info.SerializedValue">
            <summary>
            The actual value which is serialized as a substitute for a
            particular well known instance, such as <see cref="F:log4net.Core.Level.Debug"/>.
            </summary>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.Binary.Serializers.BuiltInTypeSerializer">
            <summary>
            Takes care of serializing / deserializing Type values.
            Serialization simply writes the type's assembly qualified name, e.g. "System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
            and deserialization calls <see cref="M:SharpRemote.CodeGeneration.TypeResolver.GetType(System.String)"/> or a user specified method.
            </summary>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.Binary.MessageType2">
            <summary>
                Classifies messages into method calls and -results.
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.Binary.MessageType2.Call">
            <summary>
                The method is a call and carries target, method and parameter values.
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.Binary.MessageType2.Result">
            <summary>
                The method is a result from a previous call and carries return value / exception, if available.
            </summary>
        </member>
        <member name="F:SharpRemote.CodeGeneration.Serialization.Binary.MessageType2.Exception">
            <summary>
                The method call resulted in an exception.
            </summary>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.TypeResolverAdapter">
            <summary>
                Responsible for ensuring that user-supplied type resolvers all behave identical
                when they fail to resolve a type.
            </summary>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.ExceptionCompiler">
            <summary>
                Responsible for creating custom exceptions which inherit from <see cref="T:System.Exception" />,
                provides a publicly accessible deserialization constructor so that nearly identical
                custom exceptions may be shipped using XML.
            </summary>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.IMethodCompiler">
            <summary>
            Responsible for compiling a single serialization method for a particular type.
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.IMethodCompiler.Method">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.IMethodCompiler.Compile(SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler,SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage{SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler})">
            <summary>
            
            </summary>
            <param name="methods">All serialization methods of the type being compiled</param>
            <param name="methodStorage">Serialization methods for any other available type</param>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.IPAddressSurrogate">
            <summary>
            </summary>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.ISerializationMethods">
            <summary>
                An interface through which serialization and deserialization methods can be accessed
                for a particular <see cref="T:System.Type" />.
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.ISerializationMethods.TypeDescription">
            <summary>
                A description of the type this object is responsible for serializing/deserializing.
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.ISerializationMethods.WriteValueMethod">
            <summary>
                The method through which a value of the described type may be serialized.
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.ISerializationMethods.WriteObjectMethod">
            <summary>
                The method through which an object of the described type may be serialized.
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.ISerializationMethods.ReadValueMethod">
            <summary>
                The method through which a value of the described type may be deserialized.
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.ISerializationMethods.ReadObjectMethod">
            <summary>
                The method through which an object of the described type may be deserialized.
            </summary>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage`1">
            <summary>
                Provides access to serialization methods on a per <see cref="T:System.Type"/> basis.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage`1.GetOrAdd(System.Type)">
            <summary>
                Returns the serialization methods to serialize/deserialize the given .NET <paramref name="type" />.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.AbstractReadObjectMethodCompiler">
            <summary>
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadObjectMethodCompiler.#ctor(SharpRemote.CodeGeneration.Serialization.CompilationContext)">
            <summary>
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractReadObjectMethodCompiler.Method">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadObjectMethodCompiler.Compile(SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler,SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage{SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler})">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler">
            <summary>
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.#ctor(SharpRemote.CodeGeneration.Serialization.CompilationContext)">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.Method">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.Compile(SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler,SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage{SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler})">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitDynamicDispatchReadObject(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitBeginReadField(System.Reflection.Emit.ILGenerator,SharpRemote.IFieldDescription)">
            <summary>
            
            </summary>
            <param name="gen"></param>
            <param name="field"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitEndReadField(System.Reflection.Emit.ILGenerator,SharpRemote.IFieldDescription)">
            <summary>
            
            </summary>
            <param name="gen"></param>
            <param name="field"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitBeginReadProperty(System.Reflection.Emit.ILGenerator,SharpRemote.IPropertyDescription)">
            <summary>
            
            </summary>
            <param name="gen"></param>
            <param name="property"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitEndReadProperty(System.Reflection.Emit.ILGenerator,SharpRemote.IPropertyDescription)">
            <summary>
            
            </summary>
            <param name="gen"></param>
            <param name="property"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitBeginRead(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitEndRead(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadEnum(System.Reflection.Emit.ILGenerator,SharpRemote.ITypeDescription)">
            <summary>
            
            </summary>
            <param name="gen"></param>
            <param name="typeDescription"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadByte(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadSByte(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadUInt16(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadInt16(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadUInt32(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadInt32(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadUInt64(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadInt64(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadDecimal(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadFloat(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadDouble(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadString(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadDateTime(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadLevel(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadException(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            
            </summary>
            <param name="gen"></param>
            <param name="exceptionType"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractReadValueMethodCompiler.EmitReadHintAndGrainId(System.Reflection.Emit.ILGenerator)">
            <summary>
                Shall emit code which reads two values from the given writer and pushes them
                onto the evaluation stack in the following order:
                1. Shall we create a proxy or servant? => <see cref="T:SharpRemote.ByReferenceHint" />
                2. GrainId of the proxy/servant => <see cref="T:System.UInt64"/>
            </summary>
            <param name="generator"></param>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.KeyValuePairSurrogate`2">
            <summary>
                A surrogate for <see cref="T:System.Collections.Generic.KeyValuePair`2" /> which allows every <see cref="T:SharpRemote.ISerializer2" />
                to serialize those values.
            </summary>
            <remarks>
                You do not need to care about this type at all, unless you are a maintainer of SharpRemote.
            </remarks>
            <remarks>
                TODO: Can the visibility of this type be set to internal? Only generated code needs to care...
            </remarks>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.KeyValuePairSurrogate`2.Key">
            <summary>
                Equivalent of <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" />
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.KeyValuePairSurrogate`2.Value">
            <summary>
                Equivalent of <see cref="P:System.Collections.Generic.KeyValuePair`2.Value" />
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.KeyValuePairSurrogate`2.op_Explicit(System.Collections.Generic.KeyValuePair{`0,`1})~SharpRemote.CodeGeneration.Serialization.KeyValuePairSurrogate{`0,`1}">
            <summary>
                Converts a <see cref="T:System.Collections.Generic.KeyValuePair`2" /> to a surrogate.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.KeyValuePairSurrogate`2.op_Explicit(SharpRemote.CodeGeneration.Serialization.KeyValuePairSurrogate{`0,`1})~System.Collections.Generic.KeyValuePair{`0,`1}">
            <summary>
                Converts a surrogate to a <see cref="T:System.Collections.Generic.KeyValuePair`2" />.
            </summary>
            <param name="that"></param>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.SerializationMethodStorage`1">
            <summary>
                Provides access to already compiled serialization methods
                and compiles new methods on-demand through a provided <see cref="T:SharpRemote.CodeGeneration.Serialization.ISerializationMethodCompiler`1" />.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.SerializationMethodStorage`1.#ctor(System.String,SharpRemote.CodeGeneration.Serialization.ISerializationMethodCompiler{`0})">
            <summary>
            </summary>
            <param name="suffix">The suffix used as part of the namespace for serialization methods</param>
            <param name="compiler"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.ISerializationMethodCompiler`1.Prepare(System.String,SharpRemote.ITypeDescription)">
            <summary>
                Creates a new store for serialization and deserialization of the given <paramref name="typeDescription" />.
                THIS SHALL NOT COMPILE ANYTHING BUT MERELY PREPARE A NEW CONTAINER FOR LATER COMPILATION.
            </summary>
            <param name="typeName"></param>
            <param name="typeDescription"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.ISerializationMethodCompiler`1.Compile(`0,SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage{`0})">
            <summary>
            
            </summary>
            <param name="methods"></param>
            <param name="storage"></param>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.AbstractWriteObjectMethodCompiler">
            <summary>
                Responsible for emitting a method with the following signature:
                static void (WriterType, <see cref="T:System.Object" />, <see cref="T:SharpRemote.ISerializer2" />, <see cref="T:SharpRemote.IRemotingEndPoint" />);
                The method casts/unboxes the given value and forwards it to the method compiled by
                <see cref="T:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler" />.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteObjectMethodCompiler.#ctor(SharpRemote.CodeGeneration.Serialization.CompilationContext)">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractWriteObjectMethodCompiler.Type">
            <summary>
                The type for which a WriteObject method is being compiled.
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractWriteObjectMethodCompiler.Method">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteObjectMethodCompiler.Compile(SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler,SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage{SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler})">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler">
            <summary>
                Responsible for emitting a method with the following signature:
                static void (WriterType, Type, <see cref="T:SharpRemote.ISerializer2" />, <see cref="T:SharpRemote.IRemotingEndPoint" />);
                The method can always assume that the passed value can never be null.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.#ctor(SharpRemote.CodeGeneration.Serialization.CompilationContext)">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.Method">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.Compile(SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler,SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage{SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler})">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteBuiltInType(SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage{SharpRemote.CodeGeneration.Serialization.AbstractMethodsCompiler})">
            <summary>
            
            </summary>
            <param name="methodStorage"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitDynamicDispatchWriteObject(System.Reflection.Emit.ILGenerator)">
            <summary>
            
            </summary>
            <param name="gen"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitBeginWriteField(System.Reflection.Emit.ILGenerator,SharpRemote.IFieldDescription)">
            <summary>
            
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="field"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitEndWriteField(System.Reflection.Emit.ILGenerator,SharpRemote.IFieldDescription)">
            <summary>
            
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="field"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitBeginWriteProperty(System.Reflection.Emit.ILGenerator,SharpRemote.IPropertyDescription)">
            <summary>
            
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="property"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitEndWriteProperty(System.Reflection.Emit.ILGenerator,SharpRemote.IPropertyDescription)">
            <summary>
            
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="property"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteEnum(System.Reflection.Emit.ILGenerator,SharpRemote.ITypeDescription,System.Action,System.Action)">
            <summary>
            
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="typeDescription"></param>
            <param name="loadMember"></param>
            <param name="loadMemberAddress"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteByte(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember"></param>
            <param name="loadMemberAddress"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteSByte(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember"></param>
            <param name="loadMemberAddress"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteUInt16(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember"></param>
            <param name="loadMemberAddress"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteInt16(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember"></param>
            <param name="loadMemberAddress"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteUInt32(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember">An operation which emits code to the given <paramref name="gen"/> which pushes the value of the field or property onto the evaluation stack</param>
            <param name="loadMemberAddress">An operation which emits code to the given <paramref name="gen"/> which pushes the address of the value of the field or property onto the evaluation stack</param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteInt32(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember">An operation which emits code to the given <paramref name="gen"/> which pushes the value of the field or property onto the evaluation stack</param>
            <param name="loadMemberAddress">An operation which emits code to the given <paramref name="gen"/> which pushes the address of the value of the field or property onto the evaluation stack</param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteUInt64(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember"></param>
            <param name="loadMemberAddress"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteInt64(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember"></param>
            <param name="loadMemberAddress"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteDecimal(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember">An operation which emits code to the given <paramref name="gen"/> which pushes the value of the field or property onto the evaluation stack</param>
            <param name="loadMemberAddress">An operation which emits code to the given <paramref name="gen"/> which pushes the address of the value of the field or property onto the evaluation stack</param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteSingle(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember"></param>
            <param name="loadMemberAddress"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteDouble(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember"></param>
            <param name="loadMemberAddress"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteString(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember">An operation which emits code to the given <paramref name="gen"/> which pushes the value of the field or property onto the evaluation stack</param>
            <param name="loadMemberAddress">An operation which emits code to the given <paramref name="gen"/> which pushes the address of the value of the field or property onto the evaluation stack</param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteDateTime(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember">An operation which emits code to the given <paramref name="gen"/> which pushes the value of the field or property onto the evaluation stack</param>
            <param name="loadMemberAddress">An operation which emits code to the given <paramref name="gen"/> which pushes the address of the value of the field or property onto the evaluation stack</param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteLevel(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember">An operation which emits code to the given <paramref name="gen"/> which pushes the value of the field or property onto the evaluation stack</param>
            <param name="loadMemberAddress">An operation which emits code to the given <paramref name="gen"/> which pushes the address of the value of the field or property onto the evaluation stack</param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteException(System.Reflection.Emit.ILGenerator,System.Action,System.Action)">
            <summary>
            
            </summary>
            <param name="gen">The code generator to use to emit new code</param>
            <param name="loadMember">An operation which emits code to the given <paramref name="gen"/> which pushes the value of the field or property onto the evaluation stack</param>
            <param name="loadMemberAddress">An operation which emits code to the given <paramref name="gen"/> which pushes the address of the value of the field or property onto the evaluation stack</param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteObjectId(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder)">
            <summary>
            </summary>
            <param name="generator"></param>
            <param name="grain"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.AbstractWriteValueMethodCompiler.EmitWriteHint(System.Reflection.Emit.ILGenerator,SharpRemote.ByReferenceHint)">
            <summary>
            </summary>
            <param name="generator"></param>
            <param name="hint"></param>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.Xml.XmlFormatterConverter">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Serialization.Xml.XmlMethodResultReader.TryReadResult">
            <summary>
            Tries to read the result of the method call.
            </summary>
            <returns>true if a return value is present, false if its an exception</returns>
            <exception cref="T:SharpRemote.XmlParseException">If the xml message is malformed</exception>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Serialization.Xml.XmlMethodsCompiler">
            <summary>
                Compiles methods to serialize/deserialize one .NET type,
                <see cref="M:SharpRemote.CodeGeneration.Serialization.Xml.XmlMethodsCompiler.Compile(SharpRemote.CodeGeneration.Serialization.ISerializationMethodStorage{SharpRemote.CodeGeneration.Serialization.Xml.XmlMethodsCompiler})" />.
            </summary>
        </member>
        <member name="T:SharpRemote.CodeGeneration.CodeGenerator">
            <summary>
                The default <see cref="T:SharpRemote.CodeGeneration.ICodeGenerator" /> implementation which generates code on-demand
                using IL.Emit.
            </summary>
        </member>
        <member name="P:SharpRemote.CodeGeneration.CodeGenerator.Default">
            <summary>
                The default code generator which is shared between all endpoints unless a user supplied
                code generator is given.
            </summary>
            <remarks>
                This property is internal because there is no need for a user to have acccess to
                this property. Either don't specify code generator, in which case this instance is used,
                or create your own code generator if you need your own stuff.
            </remarks>
        </member>
        <member name="M:SharpRemote.CodeGeneration.CodeGenerator.#ctor(SharpRemote.BinarySerializer)">
            <summary>
            
            </summary>
            <param name="binarySerializer"></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.CodeGenerator.#ctor(SharpRemote.ITypeResolver)">
            <summary>
                Initializes this object.
            </summary>
            <remarks>
                Creating a new instance of this type means loading a new dynamic assembly into the
                <see cref="P:System.AppDomain.CurrentDomain" />. THIS ASSEMBLY CANNOT BE UNLOADED UNLESS THE APPDOMAIN IS.
                Do not create new instances of this type if you can easily re-use an existing instance or
                you will consume more and more memory.
            </remarks>
            <param name="customTypeResolver">Type resolver that should be used instead of <see cref="T:SharpRemote.CodeGeneration.TypeResolver" /></param>
        </member>
        <member name="M:SharpRemote.CodeGeneration.CodeGenerator.GenerateServant``1">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.CodeGeneration.CodeGenerator.CreateServant``1(SharpRemote.IRemotingEndPoint,SharpRemote.IEndPointChannel,System.UInt64,``0)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.CodeGeneration.CodeGenerator.GenerateProxy``1">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.CodeGeneration.CodeGenerator.CreateProxy``1(SharpRemote.IRemotingEndPoint,SharpRemote.IEndPointChannel,System.UInt64)">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.CodeGeneration.ICodeGenerator">
            <summary>
                The interface for a code generator that is responsible for providing proxy implementations of
                interfaces as well as servants which work in conjunction with a <see cref="T:SharpRemote.IRemotingEndPoint" />
                and <see cref="T:SharpRemote.IEndPointChannel" />.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.ICodeGenerator.GenerateServant``1">
            <summary>
                Provides the .NET type of the servant for the given interface.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.ICodeGenerator.CreateServant``1(SharpRemote.IRemotingEndPoint,SharpRemote.IEndPointChannel,System.UInt64,``0)">
            <summary>
            </summary>
            <param name="endPoint"></param>
            <param name="channel"></param>
            <param name="objectId"></param>
            <param name="subject"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.ICodeGenerator.GenerateProxy``1">
            <summary>
                Provides the .NET type of the proxy for the given interface.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.ICodeGenerator.CreateProxy``1(SharpRemote.IRemotingEndPoint,SharpRemote.IEndPointChannel,System.UInt64)">
            <summary>
                Creates a proxy object for the given interface.
                All method calls are forwarded to the given <see cref="T:SharpRemote.IEndPointChannel" />.
            </summary>
            <param name="endPoint"></param>
            <param name="channel"></param>
            <param name="objectId"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Remoting.ServantCompiler.GenerateEvent(System.Reflection.EventInfo)">
            <summary>
                Responsible for generating a method to remote-invoke an event on this servant's proxy.
                The generated method serializes the event's parameters and then either calls
                <see cref="M:SharpRemote.IEndPointChannel.CallRemoteMethod(System.UInt64,System.String,System.String,System.IO.MemoryStream)" /> or <see cref="M:SharpRemote.IEndPointChannel.CallRemoteMethodAsync(System.UInt64,System.String,System.String,System.IO.MemoryStream)" />
                depending on whether or not the <see cref="T:SharpRemote.Attributes.AsyncRemoteAttribute" /> was applied to
                the event.
            </summary>
            <param name="event"></param>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Remoting.ServantCreator">
            <summary>
            Compiler capable of compiling <see cref="T:SharpRemote.IServant"/> implementations that forward calls from
            an <see cref="T:SharpRemote.IEndPointChannel"/> to a subject.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Remoting.ProxyCompiler.GenerateMethodInvocation(System.Reflection.MethodInfo)">
            <summary>
            Generates the method responsible for invoking the given interface method via
            <see cref="M:SharpRemote.IEndPointChannel.CallRemoteMethod(System.UInt64,System.String,System.String,System.IO.MemoryStream)"/>.
            </summary>
            <param name="remoteMethod"></param>
        </member>
        <member name="T:SharpRemote.CodeGeneration.Remoting.RemotingProxyCreator">
            <summary>
            Compiler capable of compiling <see cref="T:SharpRemote.IProxy"/> implementations that implement
            one additional interface, and forwards all calls to that interface to an <see cref="T:SharpRemote.IEndPointChannel"/>.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Remoting.RemotingProxyCreator.GenerateProxy``1">
            <summary>
            Generates the class for a proxy of the given type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.Remoting.RemotingProxyCreator.CreateProxy``1(SharpRemote.IRemotingEndPoint,SharpRemote.IEndPointChannel,System.UInt64)">
            <summary>
            Creates a new proxy instance that implements the given type <typeparamref name="T"/>
            of the given id.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="endPoint"></param>
            <param name="channel"></param>
            <param name="objectId"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.CodeGeneration.TypeResolver">
            <summary>
                Responsible for resolving <see cref="T:System.Type" /> objects by their names.
            </summary>
        </member>
        <member name="M:SharpRemote.CodeGeneration.TypeResolver.GetType(System.String)">
            <summary>
            Resolves the type for the given name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.CodeGeneration.TypeResolver.GetType(System.String,System.Boolean)">
            <summary>
            Resolves the type for the given name.
            </summary>
            <param name="name"></param>
            <param name="throwOnError"></param>
            <returns>The given type with the given name or null in case no such type could be found</returns>
        </member>
        <member name="P:SharpRemote.EndPoints.ProxyStorage.Proxies">
            <summary>
                Returns all the proxies of this endpoint.
                Used for testing.
            </summary>
        </member>
        <member name="M:SharpRemote.EndPoints.ProxyStorage.RemoveProxiesInRange(System.UInt64,System.UInt64)">
            <summary>
            Removies all proxies with ids in the given range.
            </summary>
            <param name="minimumId"></param>
            <param name="maximumId"></param>
        </member>
        <member name="T:SharpRemote.EndPoints.ServantStorage">
            <summary>
                Responsible for storing a list of servants.
            </summary>
            <remarks>
                Provides atomic access.
            </remarks>
        </member>
        <member name="P:SharpRemote.EndPoints.ServantStorage.Servants">
            <summary>
                Returns all the servnats of this endpoint.
                Used for testing.
            </summary>
        </member>
        <member name="T:SharpRemote.TaskEx">
            <summary>
                Extension methods to the awesome <see cref="T:System.Threading.Tasks.Task" /> class.
            </summary>
        </member>
        <member name="M:SharpRemote.TaskEx.TimeoutAfter(System.Threading.Tasks.Task,System.TimeSpan)">
            <summary>
                Creates a new task which returns the result (or exception)
                of the given <paramref name="task" /> in case it finishes
                in the given <paramref name="timeout" />. If it does't, then
                the returned task throws a <see cref="T:System.TimeoutException" />.
            </summary>
            <param name="task"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.TaskEx.TimeoutAfter``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>
                Creates a new task which returns the result (or exception)
                of the given <paramref name="task" /> in case it finishes
                in the given <paramref name="timeout" />. If it does't, then
                the returned task throws a <see cref="T:System.TimeoutException" />.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="task"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.BinarySerializer2">
            <summary>
                Shall replace <see cref="T:SharpRemote.BinarySerializer" />.
            </summary>
            <remarks>
                This class is meant to be internal, but I don't have a clue how to access
                internal class from within generated code, so it's public for now...
            </remarks>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.#ctor(SharpRemote.ITypeResolver)">
            <summary>
            </summary>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.#ctor(System.Reflection.Emit.ModuleBuilder,SharpRemote.ITypeResolver)">
            <summary>
            
            </summary>
            <param name="moduleBuilder"></param>
            <param name="typeResolver"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.RegisterType``1">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer2.RegisterType(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer2.IsTypeRegistered``1">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer2.IsTypeRegistered(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer2.CreateMethodCallWriter(System.IO.Stream,System.UInt64,System.UInt64,System.String,SharpRemote.IRemotingEndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer2.CreateMethodResultWriter(System.IO.Stream,System.UInt64,SharpRemote.IRemotingEndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer2.CreateMethodReader(System.IO.Stream,SharpRemote.IMethodCallReader@,SharpRemote.IMethodResultReader@,SharpRemote.IRemotingEndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer2.SerializeWithoutTypeInformation(System.Object)">
            <summary>
                Serializes the given object graph without any type information of <paramref name="message" />
                (Obviously types of other values within the object graph are allowed to be serialized).
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.Deserialize``1(System.Byte[])">
            <summary>
                Deserializes the given message into an object graph of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="serializedMessage"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteObject(System.IO.BinaryWriter,System.Object,SharpRemote.IRemotingEndPoint)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="endPoint"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteObjectNotNull(System.IO.BinaryWriter,System.Object,SharpRemote.IRemotingEndPoint)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="endPoint"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.Boolean)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.SByte)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.Byte)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.UInt16)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.UInt32)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.Int16)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.Int32)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.UInt64)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.Int64)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.Single)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.Double)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.String)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.Decimal)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.Byte[])">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.DateTime)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.WriteValue(System.IO.BinaryWriter,System.Exception)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="exception"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsByte(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsSByte(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsBoolean(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsUInt16(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsInt16(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsInt32(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsUInt32(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsInt64(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsUInt64(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsSingle(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsDouble(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsDecimal(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsDateTime(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsString(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadValueAsException(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer2.ReadObject(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.ISerializerCompiler">
            <summary>
            </summary>
        </member>
        <member name="M:SharpRemote.ISerializerCompiler.EmitReadValue(System.Reflection.Emit.ILGenerator,System.Action,System.Action,System.Action,System.Type)">
            <summary>
                Emits the code necessary to read a value of the given compile-time type from
                a <see cref="T:System.IO.BinaryReader" />.
            </summary>
            <param name="gen"></param>
            <param name="loadReader"></param>
            <param name="loadSerializer"></param>
            <param name="loadRemotingEndPoint"></param>
            <param name="valueType"></param>
        </member>
        <member name="M:SharpRemote.ISerializerCompiler.EmitWriteValue(System.Reflection.Emit.ILGenerator,System.Action,System.Action,System.Action,System.Action,System.Action,System.Type)">
            <summary>
            Emits the code necessary to write a value of the given compile-time type to
            a <see cref="T:System.IO.BinaryWriter"/>.
            </summary>
            <param name="gen"></param>
            <param name="loadWriter"></param>
            <param name="loadValue"></param>
            <param name="loadValueAddress"></param>
            <param name="loadSerializer"></param>
            <param name="loadRemotingEndPoint"></param>
            <param name="valueType"></param>
        </member>
        <member name="T:SharpRemote.ParseException">
            <summary>
                An exception thrown when an error occured during parsing.
            </summary>
        </member>
        <member name="M:SharpRemote.ParseException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:SharpRemote.XmlParseException">
            <summary>
                An exception thrown when an error occured during XML parsing.
            </summary>
        </member>
        <member name="M:SharpRemote.XmlParseException.#ctor(System.String,System.Int32,System.Int32,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="lineNumber"></param>
            <param name="linePosition"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:SharpRemote.XmlSerializer">
            <summary>
                A serializer implementation which writes and reads xml documents which carry method call invocations or results.
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.MethodCallElementName">
            <summary>
            Name of the XML element which represents a method call.
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.MethodResultElementName">
            <summary>
            Name of the XML element which represents a method result.
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.RpcIdAttributeName">
            <summary>
            Name of the XML attribute which carries the id of the remote procedure call.
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.GrainIdAttributeName">
            <summary>
            Name of the XML attribute which carries the id of the grain (proxy/servant).
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.MethodAttributeName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.FieldElementName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.PropertyElementName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.NameAttributeName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.ValueName">
            <summary>
            Name of the XML element (or attribute) which holds the return value or that of an argument.
            The value of built-in types is stored in an attribute and stored as child-elements in case for any
            other <see cref="T:System.Runtime.Serialization.DataContractAttribute"/> types.
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.ArgumentElementName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.ReturnValueElementName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.ExceptionElementName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.XmlSerializer.TypeAttributeName">
            <summary>
                The name of the attribute to hold the .NET type of a value, often
                the <see cref="P:System.Type.AssemblyQualifiedName" /> unless it happens to be a built-in
                type for which shorter names are used.
            </summary>
        </member>
        <member name="M:SharpRemote.XmlSerializer.#ctor(SharpRemote.ITypeResolver,System.Xml.XmlWriterSettings)">
            <summary>
            </summary>
            <param name="typeResolver"></param>
            <param name="writerSettings">The settings used to create xml documents</param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.#ctor(System.Reflection.Emit.ModuleBuilder,SharpRemote.ITypeResolver,System.Xml.XmlWriterSettings)">
            <summary>
            </summary>
            <param name="moduleBuilder"></param>
            <param name="typeResolver"></param>
            <param name="writerSettings">The settings used to create xml documents</param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.RegisterType``1">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.XmlSerializer.RegisterType(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.XmlSerializer.IsTypeRegistered``1">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.XmlSerializer.IsTypeRegistered(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.XmlSerializer.CreateMethodCallWriter(System.IO.Stream,System.UInt64,System.UInt64,System.String,SharpRemote.IRemotingEndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.XmlSerializer.CreateMethodResultWriter(System.IO.Stream,System.UInt64,SharpRemote.IRemotingEndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.XmlSerializer.CreateMethodReader(System.IO.Stream,SharpRemote.IMethodCallReader@,SharpRemote.IMethodResultReader@,SharpRemote.IRemotingEndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteObject(System.Xml.XmlWriter,System.Object,SharpRemote.IRemotingEndPoint)">
            <summary>
            
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="endPoint"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteObjectNotNull(System.Xml.XmlWriter,System.Object,SharpRemote.IRemotingEndPoint)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="endPoint"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:SharpRemote.XmlSerializer.GetTypeName(System.Type)">
            <summary>
                Returns the typename for the given type.
            </summary>
            <remarks>
                Exists because this serializer reserves very short names for built-in types
                so they are easier to read and take up less space in a message.
            </remarks>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.SByte)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.Byte)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.UInt16)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.Int16)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.UInt32)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.Int32)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.UInt64)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.Int64)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.Single)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.Double)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.Decimal)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.DateTime)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.String)">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteValue(System.Xml.XmlWriter,System.Byte[])">
            <summary>
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.WriteException(System.Xml.XmlWriter,SharpRemote.XmlSerializer,System.Exception)">
            <summary>
                Writes the given <paramref name="exception" /> to the given <paramref name="writer" />.
            </summary>
            <param name="writer"></param>
            <param name="serializer"></param>
            <param name="exception"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadObject(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ResolveTypeName(System.String)">
            <summary>
                Tries to resolve the given type-name to a .NET <see cref="T:System.Type" />.
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsSByte(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsByte(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsUInt16(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsInt16(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsUInt32(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsInt32(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsInt64(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsUInt64(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsSingle(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsDouble(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsDecimal(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsDateTime(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsString(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValue(System.Xml.XmlReader,System.Boolean)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <param name="allowNull"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadValueAsBytes(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.ReadException(System.Type,System.Xml.XmlReader,SharpRemote.XmlSerializer)">
            <summary>
            
            </summary>
            <remarks>
            TODO: Lookup exception in generated code only once, makes it easier!
            </remarks>
            <param name="exceptionType"></param>
            <param name="reader"></param>
            <param name="serializer"></param>
        </member>
        <member name="M:SharpRemote.XmlSerializer.BytesFromHex(System.String)">
            <summary>
                Returns a byte array with the given hex-coded content
                or null if <paramref name="value" /> is null.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.XmlSerializer.HexFromBytes(System.Byte[])">
            <summary>
                Returns a hex-string with the given content or null
                if <paramref name="value" /> is null.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.ConnectionDropReason">
            <summary>
                The reason why the server dropped the connection to the client:
                Is only used as part of the connection handshake between client and server.
            </summary>
        </member>
        <member name="F:SharpRemote.ConnectionDropReason.None">
            <summary>
                The connection isn't being dropped.
            </summary>
        </member>
        <member name="F:SharpRemote.ConnectionDropReason.UnacceptableVersion">
            <summary>
                The server doesn't accept the protocol version choices offered by the client.
            </summary>
        </member>
        <member name="F:SharpRemote.ConnectionDropReason.UnacceptableSerializer">
            <summary>
                The server doesn't accept the serializer choices offered by the client.
            </summary>
        </member>
        <member name="F:SharpRemote.ConnectionDropReason.UnacceptableTypeModel">
            <summary>
                The server doesn't accept the type model sent by the client.
                This may be because the type model uses types the server doesn't want to use,
                or cannot resolve, etc...
            </summary>
        </member>
        <member name="T:SharpRemote.EndPointStatistics">
            <summary>
                Responsible for retrieving statistics about a <see cref="T:SharpRemote.IRemotingEndPoint" /> and printing
                them to a <see cref="T:log4net.ILog" />.
            </summary>
        </member>
        <member name="T:SharpRemote.SocketServer">
            <summary>
                This class is responsible for accepting connections from more than one
                <see cref="T:SharpRemote.ISocketEndPoint" /> at the same time.
            </summary>
            <example>
                Just like <see cref="T:SharpRemote.ISocketEndPoint" />,
                it needs to be bound to a particular address (<see cref="M:SharpRemote.SocketServer.Bind(System.Net.IPAddress)" />)
                or <see cref="T:System.Net.IPEndPoint"/> (<see cref="M:SharpRemote.SocketServer.Bind(System.Net.IPEndPoint)" />).
            </example>
        </member>
        <member name="M:SharpRemote.SocketServer.#ctor(System.String,SharpRemote.IAuthenticator,SharpRemote.IAuthenticator,SharpRemote.ServiceDiscovery.INetworkServiceDiscoverer,SharpRemote.CodeGeneration.ICodeGenerator,SharpRemote.HeartbeatSettings,SharpRemote.LatencySettings,SharpRemote.EndPointSettings)">
            <summary>
            </summary>
            <param name="name"></param>
            <param name="serverAuthenticator"></param>
            <param name="networkServiceDiscoverer"></param>
            <param name="clientAuthenticator"></param>
            <param name="codeGenerator"></param>
            <param name="heartbeatSettings"></param>
            <param name="latencySettings"></param>
            <param name="endPointSettings"></param>
        </member>
        <member name="M:SharpRemote.SocketServer.Dispose">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.Name">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.LocalEndPoint">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketServer.Bind(System.Net.IPEndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketServer.Bind(System.Net.IPAddress)">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.NumBytesSent">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.NumBytesReceived">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.NumMessagesSent">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.NumMessagesReceived">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.NumCallsInvoked">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.NumCallsAnswered">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.NumPendingMethodCalls">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.NumPendingMethodInvocations">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.AverageRoundTripTime">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.TotalGarbageCollectionTime">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.EndPointSettings">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.LatencySettings">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.HeartbeatSettings">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketServer.RegisterSubject``1(System.UInt64,``0)">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketServer.Connections">
            <inheritdoc />
        </member>
        <member name="E:SharpRemote.SocketServer.OnClientConnected">
            <inheritdoc />
        </member>
        <member name="E:SharpRemote.SocketServer.OnClientDisconnected">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketServer.ToString">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketServer.CreateAndAddEndpoint">
            <summary>
                Creates a new endpoint, registers all currently known subjects
                with it and adds it to the <see cref="F:SharpRemote.SocketServer._internalEndPoints" /> list
                in one atomic operation.
            </summary>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.SocketServer.SubjectRegistration`1">
            <summary>
                Required in order to capture the type parameter of
                <see cref="M:SharpRemote.SocketServer.RegisterSubject``1(System.UInt64,``0)" />.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:SharpRemote.RemoteEndpointAlreadyConnectedException">
            <summary>
                This exception is thrown when an endpoint (client) tries to connect to another remote (server)
                end point and the latter does not accept the client's connection because it already is connected
                to a different client.
            </summary>
        </member>
        <member name="M:SharpRemote.RemoteEndpointAlreadyConnectedException.#ctor">
            <summary>
                Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="M:SharpRemote.RemoteEndpointAlreadyConnectedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.RemoteEndpointAlreadyConnectedException.#ctor(System.String,System.Net.EndPoint,System.Exception)">
            <summary>
                Initializes a new instance with the given message and inner exception that is the cause
                for this exception.
            </summary>
            <param name="message"></param>
            <param name="blockingEndPoint">The endpoint responsible for not being able to establish a connection</param>
            <param name="innerException"></param>
        </member>
        <member name="P:SharpRemote.RemoteEndpointAlreadyConnectedException.BlockingEndPoint">
            <summary>
                The endpoint responsible for not being able to establish a connection.
            </summary>
        </member>
        <member name="M:SharpRemote.RemoteEndpointAlreadyConnectedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.RemoteProcedureCallCanceledException">
            <summary>
                This exception is thrown when a synchronous method on the proxy, or an event on the servant, is called and
                the call did not **fully** succeed.
            </summary>
        </member>
        <member name="M:SharpRemote.RemoteProcedureCallCanceledException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.RemoteProcedureCallCanceledException.#ctor">
            <summary>
                Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="M:SharpRemote.RemoteProcedureCallCanceledException.#ctor(System.String)">
            <summary>
                Initializes a new instance of this exception.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:SharpRemote.RemoteProcedureCallCanceledException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of this exception.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:SharpRemote.IRemotingBase">
            <summary>
                The most basic interface which collects the commonality between
                <see cref="T:SharpRemote.IRemotingServer" /> and <see cref="T:SharpRemote.IRemotingEndPoint" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.Name">
            <summary>
                The name of this endpoint, only used for debugging.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.LocalEndPoint">
            <summary>
                The endpoint this object is bound to.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.NumBytesSent">
            <summary>
                The total amount of bytes that have been sent over the underlying stream.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.NumBytesReceived">
            <summary>
                The total amount of bytes that have been received over the underlying stream.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.NumMessagesSent">
            <summary>
                The total amount of messages that have been sent over the underlying stream.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.NumMessagesReceived">
            <summary>
                The total amount of messages that have been received over the underlying stream.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.NumCallsInvoked">
            <summary>
                The total amount of remote procedure calls that have been invoked from this end.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.NumCallsAnswered">
            <summary>
                The total amount of remote procedure calls that have been invoked from the other end.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.NumPendingMethodCalls">
            <summary>
                The current number of method calls which have been invoked, but have not been sent over
                the underlying stream.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.NumPendingMethodInvocations">
            <summary>
                The total number of method invocations that have been retrieved from the underlying stream,
                but not yet invoked or not yet finished.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.AverageRoundTripTime">
            <summary>
                The average roundtrip time of messages.
            </summary>
            <remarks>
                Set to <see cref="F:System.TimeSpan.Zero" /> in case latency measurements are disabled.
            </remarks>
        </member>
        <member name="P:SharpRemote.IRemotingBase.TotalGarbageCollectionTime">
            <summary>
                The total amount of time this endpoint spent collecting garbage.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingBase.EndPointSettings">
            <summary>
                The settings used for the endpoint itself (max. number of concurrent calls, etc...).
            </summary>
            <remarks>
                Changing these after construction has no effect.
            </remarks>
        </member>
        <member name="P:SharpRemote.IRemotingBase.LatencySettings">
            <summary>
                The settings used for latency measurements.
            </summary>
            <remarks>
                Changing these after construction has no effect.
            </remarks>
        </member>
        <member name="P:SharpRemote.IRemotingBase.HeartbeatSettings">
            <summary>
                The settings used for the heartbeat mechanism.
            </summary>
            <remarks>
                Changing these after construction has no effect.
            </remarks>
        </member>
        <member name="T:SharpRemote.IRemotingServer">
            <summary>
                The interface for a server-side remoting interface:
                Central server which can accept many connections.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingServer.Connections">
            <summary>
                The current list of connections to this server.
            </summary>
        </member>
        <member name="E:SharpRemote.IRemotingServer.OnClientConnected">
            <summary>
                This event is fired whenever a new connection has been (successfully) established.
            </summary>
        </member>
        <member name="E:SharpRemote.IRemotingServer.OnClientDisconnected">
            <summary>
                This event is fired whenever a connection has been disconnected.
            </summary>
            <remarks>
                Is called when:
                - Client disconnected
                - Server disconnected
                - The underlying transport channel failed
            </remarks>
        </member>
        <member name="M:SharpRemote.IRemotingServer.RegisterSubject``1(System.UInt64,``0)">
            <summary>
                Registers a servant for the given subject.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="objectId"></param>
            <param name="subject"></param>
        </member>
        <member name="T:SharpRemote.ISocketServer">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.ISocketServer.LocalEndPoint">
            <summary>
                The endpoint this socket is bound to.
            </summary>
        </member>
        <member name="M:SharpRemote.ISocketServer.Bind(System.Net.IPEndPoint)">
            <summary>
                Binds this socket to the given endpoint.
            </summary>
            <param name="ep"></param>
        </member>
        <member name="M:SharpRemote.ISocketServer.Bind(System.Net.IPAddress)">
            <summary>
                Binds this socket to the given address.
            </summary>
            <param name="localAddress"></param>
        </member>
        <member name="T:SharpRemote.StatisticsContainer">
            <summary>
                Collects statistics about a series of measurements.
            </summary>
        </member>
        <member name="M:SharpRemote.StatisticsContainer.#ctor(System.Int32)">
            <summary>
            </summary>
            <param name="numSamples">The maximum number of samples over which the average is to be calculated.</param>
        </member>
        <member name="P:SharpRemote.StatisticsContainer.Average">
            <summary>
            </summary>
        </member>
        <member name="M:SharpRemote.StatisticsContainer.Enqueue(System.Int64)">
            <summary>
                Adds a sample to this container.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:SharpRemote.HandshakeSyn">
            <summary>
                This structure forms the first part of the client/server handshake:
                It is sent from the client to the server upon establishing a connection and
                informs the server about the client's capabilities.
            </summary>
            <remarks>
                TODO: Is there a better name for these types? Syn, Ack, Synack is known, but it also part of TCP so these names
                might be misleading.
            </remarks>
        </member>
        <member name="F:SharpRemote.HandshakeSyn.SupportedVersions">
            <summary>
                The versions of the sharpremote protocol supported by the client.
            </summary>
        </member>
        <member name="F:SharpRemote.HandshakeSyn.SupportedSerializers">
            <summary>
                The serializers supported by the client.
            </summary>
        </member>
        <member name="F:SharpRemote.HandshakeSyn.TypeModel">
            <summary>
                A model of all types the client expects the server to know.
            </summary>
        </member>
        <member name="F:SharpRemote.HandshakeSyn.Challenge">
            <summary>
                The challenge that is posed by the client (and must be answered by the server).
            </summary>
        </member>
        <member name="T:SharpRemote.ByReferenceHint">
            <summary>
                This enum is used while serializing a type that is attributed with the <see cref="T:SharpRemote.ByReferenceAttribute" />.
                It instructs the deserializer on what exactly it should do.
            </summary>
        </member>
        <member name="F:SharpRemote.ByReferenceHint.CreateProxy">
            <summary>
                The deserializer should create a proxy to represent the subject of the other endpoint.
            </summary>
        </member>
        <member name="F:SharpRemote.ByReferenceHint.RetrieveSubject">
            <summary>
                The deserializer should retrieve the original subject (this happens when a proxy is sent back
                to the endpoint which registered the subject in the first place).
            </summary>
        </member>
        <member name="T:SharpRemote.Diagnostics.IDebugger">
            <summary>
            Provides access to dot net's debugger.
            </summary>
        </member>
        <member name="P:SharpRemote.Diagnostics.IDebugger.IsDebuggerAttached">
            <summary>
            Tests if the debugger is currently attached.
            </summary>
        </member>
        <member name="T:SharpRemote.ConnectionId">
            <summary>
                Identifies a connection of one <see cref="T:SharpRemote.SocketEndPoint" />.
            </summary>
        </member>
        <member name="F:SharpRemote.ConnectionId.None">
            <summary>
                The ConnectionId value used to represent "no" connection, i.e. the value returned by
                <see cref="P:SharpRemote.IRemotingEndPoint.CurrentConnectionId" />
                if the endpoint is just not connected.
            </summary>
        </member>
        <member name="M:SharpRemote.ConnectionId.ToString">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.ConnectionId.Equals(SharpRemote.ConnectionId)">
            <summary>
                Compares this and the given ConnectionId for equality.
                Two ids are equal if they represent the same connection.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ConnectionId.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.ConnectionId.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.ConnectionId.op_Equality(SharpRemote.ConnectionId,SharpRemote.ConnectionId)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.ConnectionId.op_Inequality(SharpRemote.ConnectionId,SharpRemote.ConnectionId)">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.DirectoryInfoExtensions">
            <summary>
                Provides extension methods for the <see cref="T:System.IO.DirectoryInfo" /> class.
            </summary>
        </member>
        <member name="M:SharpRemote.DirectoryInfoExtensions.TryDelete(System.IO.DirectoryInfo)">
            <summary>
                Tries to delete the given directory.
                Performs multiple tries if deleting fails (up to 10).
            </summary>
            <remarks>
                This method blocks for potentially 10 seconds if deleting fails.
            </remarks>
            <param name="file"></param>
        </member>
        <member name="T:SharpRemote.AbstractEndPoint">
            <summary>
                Base class for several endpoint implementations.
            </summary>
        </member>
        <member name="M:SharpRemote.AbstractEndPoint.WriteException(System.IO.BinaryWriter,System.Exception)">
            <summary>
            Writes the given exception using the given writer.
            </summary>
            <param name="writer"></param>
            <param name="e"></param>
        </member>
        <member name="T:SharpRemote.AbstractNamedPipeEndPoint`1">
            <summary>
            
            </summary>
            <typeparam name="TTransport"></typeparam>
        </member>
        <member name="P:SharpRemote.AbstractNamedPipeEndPoint`1.LocalEndPoint">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.AbstractNamedPipeEndPoint`1.RemoteEndPoint">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpRemote.EndPointSettings">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointSettings.MaxConcurrentCalls">
            <summary>
            The maximum number of pending, concurrent calls at any given time.
            Any further asynchronous call will block until the call is finished.
            </summary>
            <remarks>
            Defaults to 2000.
            </remarks>
        </member>
        <member name="T:SharpRemote.ILatency">
            <summary>
            The interface that must be installed on both end-points in order to measure the average latency
            of RPC invocations.
            </summary>
        </member>
        <member name="M:SharpRemote.ILatency.Roundtrip">
            <summary>
            This method is called regularly and shouldn't do any work, ideally.
            </summary>
        </member>
        <member name="T:SharpRemote.NamedPipeEndPoint">
            <summary>
            </summary>
        </member>
        <member name="T:SharpRemote.NamedPipeEndPoint.PipeType">
            <summary>
            </summary>
        </member>
        <member name="F:SharpRemote.NamedPipeEndPoint.PipeType.Server">
            <summary>
                This endpoint represents a server pipe.
            </summary>
        </member>
        <member name="F:SharpRemote.NamedPipeEndPoint.PipeType.Client">
            <summary>
                This endpoint represents a client pipe.
            </summary>
        </member>
        <member name="M:SharpRemote.NamedPipeEndPoint.#ctor(System.String,SharpRemote.NamedPipeEndPoint.PipeType)">
            <summary>
            </summary>
            <param name="pipeName"></param>
            <param name="type"></param>
        </member>
        <member name="P:SharpRemote.NamedPipeEndPoint.Type">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.NamedPipeEndPoint.PipeName">
            <summary>
            </summary>
        </member>
        <member name="M:SharpRemote.NamedPipeEndPoint.FromServer(System.String)">
            <summary>
                Creates a new <see cref="T:SharpRemote.NamedPipeEndPoint" /> for a server-side named pipe.
            </summary>
            <param name="pipeName"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.NamedPipeEndPoint.FromClient(System.String)">
            <summary>
                Creates a new <see cref="T:SharpRemote.NamedPipeEndPoint" /> for a client-side named pipe.
            </summary>
            <param name="pipeName"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.NamedPipeEndPoint.op_Equality(SharpRemote.NamedPipeEndPoint,SharpRemote.NamedPipeEndPoint)">
            <summary>
            Compares two <see cref="T:SharpRemote.NamedPipeEndPoint"/>s for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.NamedPipeEndPoint.op_Inequality(SharpRemote.NamedPipeEndPoint,SharpRemote.NamedPipeEndPoint)">
            <summary>
            Compares two <see cref="T:SharpRemote.NamedPipeEndPoint"/>s for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.NamedPipeRemotingEndPointClient">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpRemote.NamedPipeRemotingEndPointClient.#ctor(System.String,SharpRemote.IAuthenticator,SharpRemote.IAuthenticator,SharpRemote.CodeGeneration.ICodeGenerator,SharpRemote.HeartbeatSettings,SharpRemote.LatencySettings,SharpRemote.EndPointSettings)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="clientAuthenticator"></param>
            <param name="serverAuthenticator"></param>
            <param name="codeGenerator"></param>
            <param name="heartbeatSettings"></param>
            <param name="latencySettings"></param>
            <param name="endPointSettings"></param>
        </member>
        <member name="M:SharpRemote.NamedPipeRemotingEndPointClient.Connect(SharpRemote.NamedPipeEndPoint,System.TimeSpan)">
            <summary>
            
            </summary>
            <param name="endPoint"></param>
            <param name="timeout"></param>
        </member>
        <member name="M:SharpRemote.NamedPipeRemotingEndPointClient.TryConnect(SharpRemote.NamedPipeEndPoint,System.TimeSpan,System.Exception@,SharpRemote.ConnectionId@)">
            <summary>
            
            </summary>
            <param name="endPoint"></param>
            <param name="timeout"></param>
            <param name="exception"></param>
            <param name="connectionId"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:SharpRemote.NamedPipeRemotingEndPointClient.Connect(SharpRemote.NamedPipeEndPoint)">
            <summary>
            
            </summary>
            <param name="endPoint"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.NamedPipeRemotingEndPointServer">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpRemote.NamedPipeRemotingEndPointServer.#ctor(System.String,SharpRemote.IAuthenticator,SharpRemote.IAuthenticator,SharpRemote.CodeGeneration.ICodeGenerator,SharpRemote.HeartbeatSettings,SharpRemote.LatencySettings,SharpRemote.EndPointSettings)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="clientAuthenticator"></param>
            <param name="serverAuthenticator"></param>
            <param name="codeGenerator"></param>
            <param name="heartbeatSettings"></param>
            <param name="latencySettings"></param>
            <param name="endPointSettings"></param>
        </member>
        <member name="M:SharpRemote.NamedPipeRemotingEndPointServer.Bind">
            <summary>
                Binds this endpoint to <see cref="P:SharpRemote.IRemotingBase.Name" />.
            </summary>
        </member>
        <member name="M:SharpRemote.NamedPipeRemotingEndPointServer.Bind(SharpRemote.NamedPipeEndPoint)">
            <summary>
            Binds this endpoint to the given name.
            Once bound, incoming connections may be accepted.
            </summary>
            <param name="endPoint"></param>
        </member>
        <member name="T:SharpRemote.ISocketEndPoint">
            <summary>
                The interface for an endpoint which can establish a connection to another
                <see cref="T:SharpRemote.ISocketEndPoint" /> or to a <see cref="T:SharpRemote.ISocketServer" />.
            </summary>
            <example>
                Have another <see cref="T:SharpRemote.ISocketEndPoint" /> bound(<see cref="M:SharpRemote.ISocketEndPoint.Bind(System.Net.IPAddress)" />) to
                a particular address then then <see cref="M:SharpRemote.ISocketEndPoint.Connect(System.Net.IPEndPoint,System.TimeSpan)" /> to establish a
                connection with it.
            </example>
            <example>
                Have a <see cref="T:SharpRemote.ISocketServer" /> bound(<see cref="M:SharpRemote.ISocketServer.Bind(System.Net.IPAddress)" />) to
                a particular address then then <see cref="M:SharpRemote.ISocketEndPoint.Connect(System.Net.IPEndPoint,System.TimeSpan)" /> to establish a
                connection with it.
            </example>
        </member>
        <member name="P:SharpRemote.ISocketEndPoint.RemoteEndPoint">
            <summary>
                IPAddress+Port pair of the connected endPoint in case <see cref="M:SharpRemote.SocketEndPoint.Connect(System.Net.IPEndPoint)" /> has been
                called.
                Otherwise null.
            </summary>
        </member>
        <member name="P:SharpRemote.ISocketEndPoint.LocalEndPoint">
            <summary>
                IPAddress+Port pair of this endPoint in case <see cref="M:SharpRemote.ISocketEndPoint.Bind(System.Net.IPAddress)" />
                or
                has been called.
                Otherwise null.
            </summary>
        </member>
        <member name="M:SharpRemote.ISocketEndPoint.TryConnect(System.String)">
            <summary>
                Tries to connect to another endPoint with the given name.
            </summary>
            <param name="endPointName"></param>
            <returns>True when a connection could be established, false otherwise</returns>
        </member>
        <member name="M:SharpRemote.ISocketEndPoint.TryConnect(System.String,System.TimeSpan)">
            <summary>
                Tries to connects to another endPoint with the given name.
            </summary>
            <param name="endPointName"></param>
            <param name="timeout"></param>
            <returns>True when the connection succeeded, false otherwise</returns>
            <exception cref="T:System.ArgumentNullException">When <paramref name="endPointName" /> is null</exception>
            <exception cref="T:System.ArgumentException">When <paramref name="endPointName" /> is empty</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When <paramref name="timeout" /> is less or equal to
                <see cref="F:System.TimeSpan.Zero" />
            </exception>
            <exception cref="T:System.InvalidOperationException">When no network service discoverer was specified when creating this client</exception>
        </member>
        <member name="M:SharpRemote.ISocketEndPoint.TryConnect(System.Net.IPEndPoint)">
            <summary>
                Tries to connects to another endPoint with the given name.
            </summary>
            <param name="endPoint"></param>
            <returns>True when the connection succeeded, false otherwise</returns>
        </member>
        <member name="M:SharpRemote.ISocketEndPoint.TryConnect(System.Net.IPEndPoint,System.TimeSpan)">
            <summary>
                Tries to connect this endPoint to the given one.
            </summary>
            <param name="endPoint"></param>
            <param name="timeout">
                The amount of time this method should block and await a successful connection from the remote
                end-point
            </param>
            <exception cref="T:System.ArgumentNullException">
                When <paramref name="endPoint" /> is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When <paramref name="timeout" /> is equal or less than <see cref="F:System.TimeSpan.Zero" />
            </exception>
            <exception cref="T:System.InvalidOperationException">
                When this endPoint is already connected to another endPoint.
            </exception>
        </member>
        <member name="M:SharpRemote.ISocketEndPoint.TryConnect(System.Net.IPEndPoint,System.TimeSpan,System.Exception@,SharpRemote.ConnectionId@)">
            <summary>
                Tries to connect this endPoint to the given one.
            </summary>
            <param name="endPoint"></param>
            <param name="timeout">
                The amount of time this method should block and await a successful connection from the remote
                end-point
            </param>
            <param name="connectionId"></param>
            <param name="exception"></param>
            <exception cref="T:System.ArgumentNullException">
                When <paramref name="endPoint" /> is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When <paramref name="timeout" /> is equal or less than <see cref="F:System.TimeSpan.Zero" />
            </exception>
            <exception cref="T:System.InvalidOperationException">
                When this endPoint is already connected to another endPoint.
            </exception>
        </member>
        <member name="M:SharpRemote.ISocketEndPoint.Connect(System.String,System.TimeSpan)">
            <summary>
                Connects to another endPoint with the given name.
            </summary>
            <param name="endPointName"></param>
            <param name="timeout"></param>
            <exception cref="T:System.ArgumentException">
                In case <paramref name="endPointName" /> is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When <paramref name="timeout" /> is equal or less than <see cref="F:System.TimeSpan.Zero" />
            </exception>
            <exception cref="T:System.InvalidOperationException">
                When this endPoint is already connected to another endPoint.
            </exception>
            <exception cref="T:SharpRemote.NoSuchIPEndPointException">
                When no such endPoint could be *found* - it might exist but this one is
                incapable of establishing a successfuly connection
            </exception>
            <exception cref="T:SharpRemote.AuthenticationException">
                - The given endPoint is no <see cref="F:SharpRemote.EndPointType.Server" />
                - The given endPoint failed authentication
            </exception>
        </member>
        <member name="M:SharpRemote.ISocketEndPoint.Connect(System.Net.IPEndPoint)">
            <summary>
                Connects this endPoint to the given one.
            </summary>
            <param name="endPoint"></param>
            ///
            <exception cref="T:System.ArgumentNullException">
                When <paramref name="endPoint" /> is null
            </exception>
            <exception cref="T:System.InvalidOperationException">
                When this endPoint is already connected to another endPoint.
            </exception>
            <exception cref="T:SharpRemote.NoSuchIPEndPointException">
                When no such endPoint could be *found* - it might exist but this one is
                incapable of establishing a successfuly connection
            </exception>
            <exception cref="T:SharpRemote.AuthenticationException">
                - The given endPoint is no <see cref="F:SharpRemote.EndPointType.Server" />
                - The given endPoint failed authentication
            </exception>
        </member>
        <member name="M:SharpRemote.ISocketEndPoint.Connect(System.Net.IPEndPoint,System.TimeSpan)">
            <summary>
                Connects this endPoint to the given one.
            </summary>
            <param name="endPoint"></param>
            <param name="timeout">
                The amount of time this method should block and await a successful connection from the remote
                end-point
            </param>
            <exception cref="T:System.ArgumentNullException">
                When <paramref name="endPoint" /> is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When <paramref name="timeout" /> is equal or less than <see cref="F:System.TimeSpan.Zero" />
            </exception>
            <exception cref="T:System.InvalidOperationException">
                When this endPoint is already connected to another endPoint.
            </exception>
            <exception cref="T:SharpRemote.NoSuchIPEndPointException">
                When no such endPoint could be *found* - it might exist but this one is
                incapable of establishing a successfuly connection
            </exception>
            <exception cref="T:SharpRemote.AuthenticationException">
                - The given endPoint is no <see cref="F:SharpRemote.EndPointType.Server" />
                - The given endPoint failed authentication
            </exception>
            <exception cref="T:SharpRemote.AuthenticationRequiredException">
                - The given endPoint requires authentication, but this one didn't provide any
            </exception>
            <exception cref="T:SharpRemote.HandshakeException">
                - The handshake between this and the given endpoint failed
            </exception>
        </member>
        <member name="M:SharpRemote.ISocketEndPoint.Bind(System.Net.IPEndPoint)">
            <summary>
                Binds this socket to the given endpoint.
            </summary>
            <param name="ep"></param>
        </member>
        <member name="M:SharpRemote.ISocketEndPoint.Bind(System.Net.IPAddress)">
            <summary>
                Binds this socket to the given address.
            </summary>
            <param name="localAddress"></param>
        </member>
        <member name="M:SharpRemote.ISocketEndPoint.Bind(System.Net.IPAddress,System.UInt16,System.UInt16)">
            <summary>
                Binds this socket to the given address.
            </summary>
            <param name="localAddress"></param>
            <param name="minPort"></param>
            <param name="maxPort"></param>
        </member>
        <member name="T:SharpRemote.ETW.PendingMethodsEventSource">
            <summary>
                This class is used to track anything related to methods that are waiting to be
                * sent to
                * executed on
                * or answered by
                the other endpoint.
            </summary>
        </member>
        <member name="F:SharpRemote.ETW.PendingMethodsEventSource.Instance">
            <summary>
                The instance of this class which shall be used to log ETW events.
            </summary>
        </member>
        <member name="T:SharpRemote.NoSuchEndPointException">
            <summary>
            This exception is thrown when a connection to a non-existing / unreachable endpoint is established.
            </summary>
        </member>
        <member name="M:SharpRemote.NoSuchEndPointException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.NoSuchEndPointException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of this exception.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:SharpRemote.NoSuchEndPointException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="T:SharpRemote.NoSuchNamedPipeEndPointException">
            <summary>
            This exception is thrown when a connection to a non-existing / unreachable endpoint is established.
            </summary>
        </member>
        <member name="M:SharpRemote.NoSuchNamedPipeEndPointException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.NoSuchNamedPipeEndPointException.#ctor(SharpRemote.NamedPipeEndPoint,System.Exception)">
            <summary>
            Initializes an instance of this exception with the given named pipe endpoint and inner exception
            that caused this exception.
            </summary>
            <param name="endPoint"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:SharpRemote.NoSuchNamedPipeEndPointException.#ctor(SharpRemote.NamedPipeEndPoint,System.TimeSpan,System.Exception)">
            <summary>
            Initializes an instance of this exception with the given named pipe endpoint and inner exception
            that caused this exception.
            </summary>
            <param name="endPoint"></param>
            <param name="timeout">The amount of time that passed until the connection-establishment was dropped</param>
            <param name="innerException"></param>
        </member>
        <member name="M:SharpRemote.NoSuchNamedPipeEndPointException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes an instance of this exception with the given endpoint name and inner exception
            that caused this exception.
            </summary>
            <param name="endPointName"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:SharpRemote.NoSuchNamedPipeEndPointException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="F:SharpRemote.NoSuchNamedPipeEndPointException.EndPoint">
            <summary>
            The named pipe-endpoint in question, if given.
            </summary>
        </member>
        <member name="F:SharpRemote.NoSuchNamedPipeEndPointException.EndPointName">
            <summary>
            The name of the endpoint in question, if given.
            </summary>
        </member>
        <member name="T:SharpRemote.Extensions.ByteArrayExtensions">
            <summary>
                Extensions to the byte array.
            </summary>
        </member>
        <member name="M:SharpRemote.Extensions.ByteArrayExtensions.Print(System.Byte[])">
            <summary>
                Prints the contents of this array as a c# statement in the form of
                "var data = new byte[]{ content }".
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:SharpRemote.Extensions.ProcessExtensions.TryKill(System.Diagnostics.Process)">
            <summary>
            Tries to kill the given process.
            </summary>
            <param name="that"></param>
            <returns>True when the given process has been killed or doesn't live anymore, false otherwise</returns>
        </member>
        <member name="T:SharpRemote.HandshakeAck">
            <summary>
                This structure forms the second part of the client/server handshake:
                It is sent from the server to the client (in response to <see cref="T:SharpRemote.HandshakeSyn" />)
                and informs the client about the server's choice of protocol version and serializer.
            </summary>
        </member>
        <member name="F:SharpRemote.HandshakeAck.DropReason">
            <summary>
                The reason the server dropped the connection with the client.
            </summary>
            <remarks>
                A server should send this message prior to dropping the connection with a client,
                but it does not need to: A server may just close the socket and be done with the client.
            </remarks>
        </member>
        <member name="F:SharpRemote.HandshakeAck.Version">
            <summary>
                The version the sharpremote protocol the server wants to use for this connection.
                If the server doesn't support any of the client's versions, then <see cref="F:SharpRemote.ProtocolVersion.None" />
                is returned here.
            </summary>
        </member>
        <member name="F:SharpRemote.HandshakeAck.Serializer">
            <summary>
                The type of serializer the server wants to use for this connection.
                If the server doesn't support any of the client's serializers, then <see cref="F:SharpRemote.Serializer.None" />
                is returned here.
            </summary>
        </member>
        <member name="F:SharpRemote.HandshakeAck.TypeModel">
            <summary>
                A model of all types the server expects the client to know.
            </summary>
        </member>
        <member name="F:SharpRemote.HandshakeAck.Response">
            <summary>
                The response to the client's challenge or null if the client didn't pose a challenge
                *or* the response couldn't be created.
            </summary>
        </member>
        <member name="F:SharpRemote.HandshakeAck.Challenge">
            <summary>
                The challenge that is posed by the server (and must be answered by the client).
            </summary>
        </member>
        <member name="T:SharpRemote.HandshakeSynack">
            <summary>
                This structure forms the third and final part of the client/server handshake:
                It is send from the client as a response to <see cref="T:SharpRemote.HandshakeAck" /> and confirms
                that the connection is now established.
            </summary>
        </member>
        <member name="F:SharpRemote.HandshakeSynack.Response">
            <summary>
                The response to the server's challenge or null if the server didn't pose a challenge
                *or* the response couldn't be created.
            </summary>
        </member>
        <member name="T:SharpRemote.IMethodResultReader">
            <summary>
                Responsible for reading a message from a stream about the result of a method call.
                Reads the output from <see cref="T:SharpRemote.IMethodResultWriter" />.
            </summary>
            <remarks>
                Usage:
                After having obtained a newly created reader, you may call <see cref="M:SharpRemote.IMethodResultReader.ReadException(System.Exception@)" /> and **one**
                of the other ReadXYZ methods in no particular order.
            </remarks>
        </member>
        <member name="P:SharpRemote.IMethodResultReader.RpcId">
            <summary>
                The id of this remote procedure call.
                This value matches a previous call which has been created using
                <see cref="M:SharpRemote.ISerializer2.CreateMethodCallWriter(System.IO.Stream,System.UInt64,System.UInt64,System.String,SharpRemote.IRemotingEndPoint)" />.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadException(System.Exception@)">
            <summary>
                Reads an exception, if an exception was written using a <see cref="M:SharpRemote.ISerializer2.CreateMethodCallWriter(System.IO.Stream,System.UInt64,System.UInt64,System.String,SharpRemote.IRemotingEndPoint)" />.
            </summary>
            <param name="exception"></param>
            <returns>True if an exception was written to- and thus read from, false if no exception is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResult(System.Object@)">
            <summary>
                Returns the result of the method call as an <see cref="T:System.Object" />.
                Returns null if the method doesn't return any value (because it's return type is <see cref="T:System.Void" />)
                or if it actually returned null.
            </summary>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultSByte(System.SByte@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.SByte" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultByte(System.Byte@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.Byte" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultUInt16(System.UInt16@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.UInt16" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultInt16(System.Int16@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.Int16" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultUInt32(System.UInt32@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.UInt32" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultInt32(System.Int32@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.Int32" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultUInt64(System.UInt64@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.UInt64" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultInt64(System.Int64@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.Int64" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultSingle(System.Single@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.Single" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultDouble(System.Double@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.Double" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultString(System.String@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.String" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="M:SharpRemote.IMethodResultReader.ReadResultBytes(System.Byte[]@)">
            <summary>
                Returns the result of the method as an <see cref="T:System.String" />.
                May throw an exception if the method didn't return a value of that type, but doesn't need to.
            </summary>
            <remarks>
                It's the responsibility of the caller of this method to call the correct GetResultXYZ method
                which matches the signature of the method being called.
            </remarks>
            <param name="value"></param>
            <returns>True if a value was written to- and thus read from, false if no result is present</returns>
        </member>
        <member name="T:SharpRemote.IMethodCallWriter">
            <summary>
                Responsible for creating a serialized message out of a method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.Object)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.SByte)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.Byte)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.UInt16)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.Int16)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.UInt32)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.Int32)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.UInt64)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.Int64)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.Single)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.Double)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.Decimal)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.DateTime)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.String)">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodCallWriter.WriteArgument(System.Byte[])">
            <summary>
                Adds an argument of the given name and value to this method call.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:SharpRemote.IMethodCallReader">
            <summary>
                A forward-only reader which reads the invocation of a method from a stream which has been previously
                created using a <see cref="T:SharpRemote.IMethodCallWriter" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IMethodCallReader.RpcId">
            <summary>
                The id which identifies this remote procedure call.
                Is used to match method call and -result.
            </summary>
        </member>
        <member name="P:SharpRemote.IMethodCallReader.GrainId">
            <summary>
                The id of the grain on which the method is to be invoked.
            </summary>
        </member>
        <member name="P:SharpRemote.IMethodCallReader.MethodName">
            <summary>
                The name of the method which is to be invoked.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgument(System.Object@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsSByte(System.SByte@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsByte(System.Byte@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsUInt16(System.UInt16@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsInt16(System.Int16@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsUInt32(System.UInt32@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsInt32(System.Int32@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsUInt64(System.UInt64@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsInt64(System.Int64@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsSingle(System.Single@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsDouble(System.Double@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsDecimal(System.Decimal@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsDateTime(System.DateTime@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsString(System.String@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="M:SharpRemote.IMethodCallReader.ReadNextArgumentAsBytes(System.Byte[]@)">
            <summary>
                Reads the value of the next argument from the method call message.
            </summary>
            <param name="value">The value of the next argument</param>
            <returns>True if the next argument could be read, false when the end of arguments has been reached.</returns>
        </member>
        <member name="T:SharpRemote.IMethodResultWriter">
            <summary>
                Responsible for writing a message to a stream about the result of a method call.
            </summary>
            <remarks>
                A user of this class must either call <see cref="M:SharpRemote.IMethodResultWriter.WriteFinished" />, <see cref="M:SharpRemote.IMethodResultWriter.WriteResult(System.String)" />
                or <see cref="M:SharpRemote.IMethodResultWriter.WriteException(System.Exception)" />, but never more than one on the same writer-object.
            </remarks>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteFinished">
            <summary>
                Writes a marker that the method finished executing.
                Only to be used for methods which have a <see cref="T:System.Void" /> return type
                (and thus <see cref="M:SharpRemote.IMethodResultWriter.WriteResult(System.Object)" /> would not be appropriate).
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.Object)">
            <summary>
                Writes the result of the method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.SByte)">
            <summary>
                Writes the result of the method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.Byte)">
            <summary>
                Writes the result of the method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.UInt16)">
            <summary>
                Writes the result of the method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.Int16)">
            <summary>
                Writes the result of the method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.UInt32)">
            <summary>
                Writes the result of the method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.Int32)">
            <summary>
                Writes the result of the method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.UInt64)">
            <summary>
                Writes the result of the method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.Int64)">
            <summary>
                Writes the result of the method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.Single)">
            <summary>
                Writes the result of the method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.Double)">
            <summary>
                Writes the result of the method invocation.
            </summary>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.String)">
            <summary>
                Writes the result of the method invocation.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteResult(System.Byte[])">
            <summary>
                Writes the result of the method invocation.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.IMethodResultWriter.WriteException(System.Exception)">
            <summary>
                Signals that the method call resulted in an unhandled exception being thrown.
                The exception should be serialized.
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:SharpRemote.ISerializer2">
            <summary>
                The interface a serializer needs to implement:
                An RPC call is modelled by the following sequence of methods:
                - <see cref="M:SharpRemote.ISerializer2.CreateMethodCallWriter(System.IO.Stream,System.UInt64,System.UInt64,System.String,SharpRemote.IRemotingEndPoint)" /> [Caller]
                - <see cref="M:SharpRemote.ISerializer2.CreateMethodReader(System.IO.Stream,SharpRemote.IMethodCallReader@,SharpRemote.IMethodResultReader@,SharpRemote.IRemotingEndPoint)" /> [Callee]
                - <see cref="M:SharpRemote.ISerializer2.CreateMethodResultWriter(System.IO.Stream,System.UInt64,SharpRemote.IRemotingEndPoint)" /> [Callee]
                - <see cref="M:SharpRemote.ISerializer2.CreateMethodReader(System.IO.Stream,SharpRemote.IMethodCallReader@,SharpRemote.IMethodResultReader@,SharpRemote.IRemotingEndPoint)" /> [Caller]
                Where [Caller] is the serializer object on the side of the caller and [Callee] is the
                serializer object on the side of the callee of the method.
            </summary>
            <remarks>
                Shall replace <see cref="T:SharpRemote.ISerializer" />.
            </remarks>
            <remarks>
                This interface is responsible for deciding if a type model from another endpoint can be accepted
                or not (because serializers have the freedom to decide how [or if at all] compatible their messages
                are with regards to changes to the type model: One serializer might not care if a property has been
                added while another might care).
            </remarks>
        </member>
        <member name="M:SharpRemote.ISerializer2.RegisterType``1">
            <summary>
                Registers the given type <typeparamref name="T" /> with this serializer.
            </summary>
            <remarks>
                This method can be used to verify upfront that:
                - A used type can be serialized
                - No intermittent compilation happens while writing / reading an object graph
            </remarks>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.ArgumentNullException">When <typeparamref name="T" /> is null</exception>
            <exception cref="T:System.ArgumentException">When the type cannot be serialized</exception>
            <exception cref="T:SharpRemote.SerializationException">
                In case there was an error while generating the code necessary for
                serialization / deserialization
            </exception>
        </member>
        <member name="M:SharpRemote.ISerializer2.RegisterType(System.Type)">
            <summary>
                Registers the given type <paramref name="type" /> with this serializer.
            </summary>
            <remarks>
                This method can be used to verify upfront that:
                - A used type can be serialized
                - No intermittent compilation happens while writing / reading an object graph
            </remarks>
            <param name="type">The type to register</param>
            <exception cref="T:System.ArgumentNullException">When <paramref name="type" /> is null</exception>
            <exception cref="T:System.ArgumentException">When the type cannot be serialized</exception>
            <exception cref="T:SharpRemote.SerializationException">
                In case there was an error while generating the code necessary for
                serialization / deserialization
            </exception>
        </member>
        <member name="M:SharpRemote.ISerializer2.IsTypeRegistered``1">
            <summary>
                Tests if the given type <typeparamref name="T" /> has already been registered
                with this serializer (either directly through <see cref="M:SharpRemote.ISerializer2.RegisterType(System.Type)" /> or indirectly
                through <see cref="M:SharpRemote.ISerializer2.CreateMethodCallWriter(System.IO.Stream,System.UInt64,System.UInt64,System.String,SharpRemote.IRemotingEndPoint)" />, <see cref="M:SharpRemote.ISerializer2.CreateMethodReader(System.IO.Stream,SharpRemote.IMethodCallReader@,SharpRemote.IMethodResultReader@,SharpRemote.IRemotingEndPoint)" /> or
                <see cref="M:SharpRemote.ISerializer2.CreateMethodResultWriter(System.IO.Stream,System.UInt64,SharpRemote.IRemotingEndPoint)" />.
            </summary>
            <typeparam name="T">The type to test</typeparam>
            <returns>True if the type has been registered, false otherwise</returns>
        </member>
        <member name="M:SharpRemote.ISerializer2.IsTypeRegistered(System.Type)">
            <summary>
                Tests if the given type <paramref name="type" /> has already been registered
                with this serializer (either directly through <see cref="M:SharpRemote.ISerializer2.RegisterType(System.Type)" /> or indirectly
                through <see cref="M:SharpRemote.ISerializer2.CreateMethodCallWriter(System.IO.Stream,System.UInt64,System.UInt64,System.String,SharpRemote.IRemotingEndPoint)" />, <see cref="M:SharpRemote.ISerializer2.CreateMethodResultWriter(System.IO.Stream,System.UInt64,SharpRemote.IRemotingEndPoint)" /> or
                <see cref="M:SharpRemote.ISerializer2.CreateMethodReader(System.IO.Stream,SharpRemote.IMethodCallReader@,SharpRemote.IMethodResultReader@,SharpRemote.IRemotingEndPoint)" />.
            </summary>
            <param name="type">The type to test</param>
            <returns>True if the type has been registered, false otherwise</returns>
        </member>
        <member name="M:SharpRemote.ISerializer2.CreateMethodCallWriter(System.IO.Stream,System.UInt64,System.UInt64,System.String,SharpRemote.IRemotingEndPoint)">
            <summary>
                Creates a new writer which writes the intention to call the given method on the given object
                to the given stream.
            </summary>
            <remarks>
                It is expected that <see cref="M:SharpRemote.ISerializer2.CreateMethodReader(System.IO.Stream,SharpRemote.IMethodCallReader@,SharpRemote.IMethodResultReader@,SharpRemote.IRemotingEndPoint)" /> can read the contents of the stream
                written to by this method.
            </remarks>
            <remarks>
                The given <paramref name="stream" /> should NOT be written to any more after
                the returned writer has been disposed of.
            </remarks>
            <remarks>
                The given <paramref name="stream" /> should NOT be disposed of when the returned
                <see cref="T:SharpRemote.IMethodCallWriter" /> is disposed of:
                That writer does NOT own the stream and should NOT close it either.
            </remarks>
            <param name="stream"></param>
            <param name="rpcId"></param>
            <param name="grainId"></param>
            <param name="methodName"></param>
            <param name="endPoint"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ISerializer2.CreateMethodResultWriter(System.IO.Stream,System.UInt64,SharpRemote.IRemotingEndPoint)">
            <summary>
                Creates a writer which writes the result (or exception) foa method invocation to the given
                <paramref name="stream" />.
            </summary>
            <remarks>
                It is expected that <see cref="M:SharpRemote.ISerializer2.CreateMethodReader(System.IO.Stream,SharpRemote.IMethodCallReader@,SharpRemote.IMethodResultReader@,SharpRemote.IRemotingEndPoint)" /> can read the contents of the stream
                written to by this method.
            </remarks>
            <remarks>
                The given <paramref name="stream" /> should NOT be written to any more after
                the returned writer has been disposed of.
            </remarks>
            <remarks>
                The given <paramref name="stream" /> should NOT be disposed of when the returned
                <see cref="T:SharpRemote.IMethodResultWriter" /> is disposed of:
                That writer does NOT own the stream and should NOT close it either.
            </remarks>
            <param name="stream">The stream to which the result (or exception) of the method invocation are written to</param>
            <param name="rpcId"></param>
            <param name="endPoint"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ISerializer2.CreateMethodReader(System.IO.Stream,SharpRemote.IMethodCallReader@,SharpRemote.IMethodResultReader@,SharpRemote.IRemotingEndPoint)">
            <summary>
                Creates a reader which consumes the given stream and either creates a <see cref="T:SharpRemote.IMethodCallReader" />
                if the stream was written by a compatible <see cref="T:SharpRemote.IMethodCallWriter" /> or a
                <see cref="T:SharpRemote.IMethodResultReader" /> if it was written by a <see cref="T:SharpRemote.IMethodResultWriter" />.
            </summary>
            <remarks>
                The given <paramref name="stream" /> should NOT be disposed of when the returned
                <see cref="T:SharpRemote.IMethodResultReader" /> is disposed of:
                That reader does NOT own the stream and should NOT close it either.
            </remarks>
            <param name="stream">The stream from which the result of the method invocation is read from</param>
            <param name="resultReader"></param>
            <param name="endPoint"></param>
            <param name="callReader"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.ProtocolVersion">
            <summary>
                Defines the version of the sharpremote protocol.
            </summary>
        </member>
        <member name="F:SharpRemote.ProtocolVersion.None">
            <summary>
                No version.
            </summary>
        </member>
        <member name="F:SharpRemote.ProtocolVersion.Version1">
            <summary>
                1, the first version of the protocol which has been identified this way.
            </summary>
            <remarks>
                (There were many versions before this, but they weren't particularly user friendly
                and thus haven't been added to this enumeration).
            </remarks>
        </member>
        <member name="T:SharpRemote.Serializer">
            <summary>
                Defines the type of serializer used/supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Serializer.None">
            <summary>
                No serializer.
            </summary>
        </member>
        <member name="F:SharpRemote.Serializer.BinarySerializer">
            <summary>
                A binary serializer which produces small, but not human-readable output.
            </summary>
        </member>
        <member name="F:SharpRemote.Serializer.XmlSerializer">
            <summary>
            NOT YET SUPPORTED.
            </summary>
        </member>
        <member name="T:SharpRemote.Sockets.ISocket">
            <summary>
                Offers an interface identical to <see cref="T:System.Net.Sockets.Socket" /> and can be used as a drop in replacement.
                Want to unit test code using a Socket but cannot be Microsoft didn't include any interface?
                Fear no more...
            </summary>
            <remarks>
                This should be part of the System.Extensions project and be publicly available.
            </remarks>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.AddressFamily">
            <summary>
            Gets the address family of the System.Net.Sockets.Socket.
            </summary>
            <returns>One of the System.Net.Sockets.AddressFamily values.</returns>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.Available">
            <summary>
            Gets the amount of data that has been received from the network and is available
                to be read.
            </summary>
            <returns>The number of bytes of data received from the network and available to be read.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">
            An error occurred when attempting to access the socket. See the Remarks section
                for more information.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The System.Net.Sockets.Socket has been closed.
            </exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.Blocking">
            
            <Summary>
                 Gets or sets a value that indicates whether the System.Net.Sockets.Socket is
                 in blocking mode.
            </Summary>
             <Returns>
                 true if the System.Net.Sockets.Socket will block; otherwise, false. The default
                 is true.
            </Returns>
             <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
             <exception cref="T:System.ObjectDisposedException">
             The System.Net.Sockets.Socket has been closed.
             </exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.Connected">
            <Summary>
                 Gets a value that indicates whether a System.Net.Sockets.Socket is connected
                 to a remote host as of the last Overload:System.Net.Sockets.Socket.Send or Overload:System.Net.Sockets.Socket.Receive
                 operation.
            </Summary>
             <Returns>
                 true if the System.Net.Sockets.Socket was connected to a remote resource as of
                 the most recent operation; otherwise, false.
             </Returns>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.DontFragment">
            <Summary>
                 Gets or sets a System.Boolean value that specifies whether the System.Net.Sockets.Socket
                 allows Internet Protocol (IP) datagrams to be fragmented.
            </Summary><Returns>
                 true if the System.Net.Sockets.Socket allows datagram fragmentation; otherwise,
                 false. The default is true.
             </Returns>
             <exception cref="T:System.NotSupportedException">
             This property can be set only for sockets in the System.Net.Sockets.AddressFamily.InterNetwork
                 or System.Net.Sockets.AddressFamily.InterNetworkV6 families.
             </exception>
             <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
             <exception cref="T:System.ObjectDisposedException">
             The System.Net.Sockets.Socket has been closed.
             </exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.DualMode">
            <Summary>
                 Gets or sets a System.Boolean value that specifies whether the System.Net.Sockets.Socket
                 is a dual-mode socket used for both IPv4 and IPv6.
            </Summary>
             <Returns>
                 Returns System.Boolean.true if the System.Net.Sockets.Socket is a dual-mode socket;
                 otherwise, false. The default is false.
             </Returns>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.EnableBroadcast">
            <Summary>
                 Gets or sets a System.Boolean value that specifies whether the System.Net.Sockets.Socket
                 can send or receive broadcast packets.
            </Summary>
             <Returns>
                 true if the System.Net.Sockets.Socket allows broadcast packets; otherwise, false.
                 The default is false.
             </Returns>
            <exception cref="T:System.Net.Sockets.SocketException">
             This option is valid for a datagram socket only.
             </exception>
             <exception cref="T:System.ObjectDisposedException">
             The System.Net.Sockets.Socket has been closed.
             </exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.ExclusiveAddressUse">
            <summary>
            Gets or sets a System.Boolean value that specifies whether the System.Net.Sockets.Socket
                allows only one process to bind to a port.
            </summary>
            <remarks>
            true if the System.Net.Sockets.Socket allows only one socket to bind to a specific
                port; otherwise, false. The default is true for Windows Server 2003 and Windows
                XP Service Pack 2, and false for all other versions.
            </remarks>
            <exception cref="T:System.Net.Sockets.SocketException">
                An error occurred when attempting to access the socket. See the Remarks section
                for more information.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The System.Net.Sockets.Socket has been closed.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            System.Net.Sockets.Socket.Bind(System.Net.EndPoint) has been called for this
                System.Net.Sockets.Socket.
            </exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.Handle">
            <Summary>
                 Gets the operating system handle for the System.Net.Sockets.Socket.
            </Summary>
             <Returns>
                 An System.IntPtr that represents the operating system handle for the System.Net.Sockets.Socket.
             </Returns>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.IsBound">
            <Summary>
                Gets a value that indicates whether the System.Net.Sockets.Socket is bound to
                a specific local port.
            </Summary>
            <Returns>
                true if the System.Net.Sockets.Socket is bound to a local port; otherwise, false.
            </Returns>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.LingerState">
            <Summary>
                Gets or sets a value that specifies whether the System.Net.Sockets.Socket will
                delay closing a socket in an attempt to send all pending data.
            </Summary>
            <Returns>
                A System.Net.Sockets.LingerOption that specifies how to linger while closing
                a socket.
            </Returns>
            <exception cref="T:System.Net.Sockets.SocketException">
                An error occurred when attempting to access the socket.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.LocalEndPoint">
            <Summary>
                Gets the local endpoint.
            </Summary>
            <Returns>
                The System.Net.EndPoint that the System.Net.Sockets.Socket is using for communications.
            </Returns>
            <exception cref="T:System.Net.Sockets.SocketException">
                An error occurred when attempting to access the socket. See the Remarks section
                for more information.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.MulticastLoopback">
            <Summary>
                Gets or sets a value that specifies whether outgoing multicast packets are delivered
                to the sending application.
            </Summary>
            <Returns>
                true if the System.Net.Sockets.Socket receives outgoing multicast packets; otherwise,
                false.
            </Returns>
            <exception cref="T:System.Net.Sockets.SocketException">
                An error occurred when attempting to access the socket.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.NoDelay">
            <Summary>
                Gets or sets a System.Boolean value that specifies whether the stream System.Net.Sockets.Socket
                is using the Nagle algorithm.
            </Summary>
            <Returns>
                false if the System.Net.Sockets.Socket uses the Nagle algorithm; otherwise, true.
                The default is false.
            </Returns>
            <exception cref="T:System.Net.Sockets.SocketException"></exception>
            An error occurred when attempting to access the System.Net.Sockets.Socket. See
            the Remarks section for more information.
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.ProtocolType">
            <Summary>
                Gets the protocol type of the System.Net.Sockets.Socket.
            </Summary>
            <Returns>
                One of the System.Net.Sockets.ProtocolType values.
            </Returns>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.ReceiveBufferSize">
            <Summary>
                Gets or sets a value that specifies the size of the receive buffer of the System.Net.Sockets.Socket.
            </Summary>
            <Returns>
                An System.Int32 that contains the size, in bytes, of the receive buffer. The
                default is 8192.
            </Returns>
            <exception cref="T:System.Net.Sockets.SocketException">
                An error occurred when attempting to access the socket.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                The value specified for a set operation is less than 0.
            </exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.ReceiveTimeout">
            <Summary>
                Gets or sets a value that specifies the amount of time after which a synchronous
                Overload:System.Net.Sockets.Socket.Receive call will time out.
            </Summary>
            <Returns>
                The time-out value, in milliseconds. The default value is 0, which indicates
                an infinite time-out period. Specifying -1 also indicates an infinite time-out
                period.
            </Returns>
            <exception cref="T:System.Net.Sockets.SocketException">
                An error occurred when attempting to access the socket.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                The value specified for a set operation is less than -1.
            </exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.RemoteEndPoint">
            <Summary>
                Gets the remote endpoint.
            </Summary>
            <Returns>
                The System.Net.EndPoint with which the System.Net.Sockets.Socket is communicating.
            </Returns>
            <exception cref="T:System.Net.Sockets.SocketException">
                An error occurred when attempting to access the socket. See the Remarks section
                for more information.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.SendBufferSize">
            <Summary>
                Gets or sets a value that specifies the size of the send buffer of the System.Net.Sockets.Socket.
            </Summary>
            <Returns>
                An System.Int32 that contains the size, in bytes, of the send buffer. The default
                is 8192.
            </Returns>
            <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                The value specified for a set operation is less than 0.
            </exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.SendTimeout">
            <Summary>
                Gets or sets a value that specifies the amount of time after which a synchronous
                Overload:System.Net.Sockets.Socket.Send call will time out.
            </Summary>
            <Returns>
                The time-out value, in milliseconds. If you set the property with a value between
                1 and 499, the value will be changed to 500. The default value is 0, which indicates
                an infinite time-out period. Specifying -1 also indicates an infinite time-out
                period.
            </Returns>
            <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                The value specified for a set operation is less than -1.
            </exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.SocketType">
            <Summary>
                 Gets the type of the System.Net.Sockets.Socket.
            </Summary>
             <Returns>
                 One of the System.Net.Sockets.SocketType values.
             </Returns>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.Ttl">
            <Summary>
                Gets or sets a value that specifies the Time To Live (TTL) value of Internet
                Protocol (IP) packets sent by the System.Net.Sockets.Socket.
            </Summary>
            <Returns>
                The TTL value.
            </Returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                The TTL value can't be set to a negative number.
            </exception>
            <exception cref="T:System.NotSupportedException">
                This property can be set only for sockets in the System.Net.Sockets.AddressFamily.InterNetwork
                or System.Net.Sockets.AddressFamily.InterNetworkV6 families.
            </exception>
            <exception cref="T:System.Net.Sockets.SocketException"></exception>
            An error occurred when attempting to access the socket. This error is also returned
            when an attempt was made to set TTL to a value higher than 255.
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="P:SharpRemote.Sockets.ISocket.UseOnlyOverlappedIO">
            <Summary>
                 Specifies whether the socket should only use Overlapped I/O mode.
            </Summary>
             <Returns>
                 true if the System.Net.Sockets.Socket uses only overlapped I/O; otherwise, false.
                 The default is false.
             </Returns>
             <exception cref="T:System.InvalidOperationException">
             The socket has been bound to a completion port.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Accept">
            <Summary>
                 Creates a new System.Net.Sockets.Socket for a newly created connection.
            </Summary>
             <Returns>
                 A System.Net.Sockets.Socket for a newly created connection.
             </Returns>
               <exception cref="T:System.Net.Sockets.SocketException">
             An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            <exception cref="T:System.InvalidOperationException">
             The accepting socket is not listening for connections. You must call System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
                 and System.Net.Sockets.Socket.Listen(System.Int32) before calling System.Net.Sockets.Socket.Accept.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <Summary>
                 Begins an asynchronous operation to accept an incoming connection attempt.
            </Summary>
             <param name="e">
             The System.Net.Sockets.SocketAsyncEventArgs object to use for this asynchronous
                 socket operation.</param>
             <Returns>
                 Returns true if the I/O operation is pending. The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will be raised upon completion of the operation.Returns
                 false if the I/O operation completed synchronously. The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will not be raised and the e object passed as a parameter
                 may be examined immediately after the method call returns to retrieve the result
                 of the operation.
             </Returns>
             <exception cref="T:System.ArgumentException">
             An argument is not valid. This exception occurs if the buffer provided is not
                 large enough. The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16)
                 bytes. This exception also occurs if multiple buffers are specified, the System.Net.Sockets.SocketAsyncEventArgs.BufferList
                 property is not null.
             </exception>
             <exception cref="T:System.ArgumentOutOfRangeException">
             An argument is out of range. The exception occurs if the System.Net.Sockets.SocketAsyncEventArgs.Count
                 is less than 0.
             </exception>
             <exception cref="T:System.InvalidOperationException">
             An invalid operation was requested. This exception occurs if the accepting System.Net.Sockets.Socket
                 is not listening for connections or the accepted socket is bound. You must call
                 the System.Net.Sockets.Socket.Bind(System.Net.EndPoint) and System.Net.Sockets.Socket.Listen(System.Int32)
                 method before calling the System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)
                 method.This exception also occurs if the socket is already connected or a socket
                 operation was already in progress using the specified e parameter.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
             An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
             <exception cref="T:System.NotSupportedException">
             Windows XP or later is required for this method.
             </exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginAccept(System.AsyncCallback,System.Object)">
            <Summary>
                 Begins an asynchronous operation to accept an incoming connection attempt.
            </Summary>
             <param name="callback">The System.AsyncCallback delegate.</param>
             <param name="state">An object that contains state information for this request.</param>
             <Returns>
                 An System.IAsyncResult that references the asynchronous System.Net.Sockets.Socket
                 creation.
             </Returns>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
             <exception cref="T:System.NotSupportedException">
                 Windows NT is required for this method.
             </exception>
             <exception cref="T:System.InvalidOperationException">
                 The accepting socket is not listening for connections. You must call System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
                 and System.Net.Sockets.Socket.Listen(System.Int32) before calling System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object).-or-
                 The accepted socket is bound.
             </exception>
             <exception cref="T:System.ArgumentOutOfRangeException">
             receiveSize is less than 0.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
            <Summary>
                 Begins an asynchronous operation to accept an incoming connection attempt and
                 receives the first block of data sent by the client application.
            </Summary>
             <param name="receiveSize">The number of bytes to accept from the sender.</param>
             <param name="callback">The System.AsyncCallback delegate.</param>
             <param name="state">An object that contains state information for this request.</param>
             <Returns>
                 An System.IAsyncResult that references the asynchronous System.Net.Sockets.Socket
                 creation.
             </Returns>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.NotSupportedException">
                 Windows NT is required for this method.
             </exception>
               <exception cref="T:System.InvalidOperationException">
                 The accepting socket is not listening for connections. You must call System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
                 and System.Net.Sockets.Socket.Listen(System.Int32) before calling System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object).-or-
                 The accepted socket is bound.
             </exception>
               <exception cref="T:System.ArgumentOutOfRangeException">
                 receiveSize is less than 0.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
            <Summary>
                Begins an asynchronous operation to accept an incoming connection attempt from
                a specified socket and receives the first block of data sent by the client application.
            </Summary>
            <param name="acceptSocket">The accepted System.Net.Sockets.Socket object. This value may be null.</param>
            <param name="receiveSize">The maximum number of bytes to receive.</param>
            <param name="callback">The System.AsyncCallback delegate.</param>
            <param name="state">An object that contains state information for this request.</param>
            <Returns>
                An System.IAsyncResult object that references the asynchronous System.Net.Sockets.Socket
                object creation.
            </Returns>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            The System.Net.Sockets.Socket object has been closed.
            <exception cref="T:System.NotSupportedException">
                Windows NT is required for this method.
            </exception>
            <exception cref="T:System.InvalidOperationException">
                The accepting socket is not listening for connections. You must call
                System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
                and System.Net.Sockets.Socket.Listen(System.Int32) before calling
                System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object).-or-
                The accepted socket is bound.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                receiveSize is less than 0.
            </exception>
            <exception cref="T:System.Net.Sockets.SocketException">
                An error occurred when attempting to access the socket. See the Remarks section
                for more information.
            </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
            <Summary>
                 Begins an asynchronous request for a remote host connection.
            </Summary>
             <param name="remoteEP">An System.Net.EndPoint that represents the remote host.</param>
             <param name="callback">The System.AsyncCallback delegate.</param>
             <param name="state">An object that contains state information for this request.</param>
             <Returns>
                 An System.IAsyncResult that references the asynchronous connection.
             </Returns>
               <exception cref="T:System.ArgumentNullException">
                 remoteEP is null.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.</exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.Security.SecurityException">
                 A caller higher in the call stack does not have permission for the requested
                 operation.
             </exception>
               <exception cref="T:System.InvalidOperationException">
                 The System.Net.Sockets.Socket is System.Net.Sockets.Socket.Listen(System.Int32)ing.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
            <Summary>
                 Begins an asynchronous request for a remote host connection. The host is specified
                 by an System.Net.IPAddress array and a port number.
            </Summary>
             <param name="addresses">At least one System.Net.IPAddress, designating the remote host.</param>
             <param name="port">The port number of the remote host.</param>
             <param name="requestCallback">
                 An System.AsyncCallback delegate that references the method to invoke when the
                 connect operation is complete.
             </param>
             <param name="state">
                 A user-defined object that contains information about the connect operation.
                 This object is passed to the requestCallback delegate when the operation is complete.
             </param>
             <Returns>
                 An System.IAsyncResult that references the asynchronous connections.
             </Returns>
               <exception cref="T:System.ArgumentNullException">
                 addresses is null.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.</exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.NotSupportedException">
                 This method is valid for sockets that use System.Net.Sockets.AddressFamily.InterNetwork
                 or System.Net.Sockets.AddressFamily.InterNetworkV6.
             </exception>
               <exception cref="T:System.ArgumentOutOfRangeException">
                 The port number is not valid.</exception>
               <exception cref="T:System.ArgumentException">
                 The length of address is zero.</exception>
               <exception cref="T:System.InvalidOperationException">
                 The System.Net.Sockets.Socket is System.Net.Sockets.Socket.Listen(System.Int32)ing.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
            <Summary>
                 Begins an asynchronous request for a remote host connection. The host is specified
                 by an System.Net.IPAddress and a port number.
            </Summary>
             <param name="address">The System.Net.IPAddress of the remote host.</param>
             <param name="port">The port number of the remote host.</param>
             <param name="requestCallback">
                 An System.AsyncCallback delegate that references the method to invoke when the
                 connect operation is complete.
             </param>
             <param name="state">
                 A user-defined object that contains information about the connect operation.
                 This object is passed to the requestCallback delegate when the operation is complete.
             </param>
             <Returns>
                 An System.IAsyncResult that references the asynchronous connection.
             </Returns>
               <exception cref="T:System.ArgumentNullException">
                 address is null.</exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.</exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.NotSupportedException">
                 The System.Net.Sockets.Socket is not in the socket family.</exception>
               <exception cref="T:System.ArgumentOutOfRangeException">
                 The port number is not valid.
             </exception>
               <exception cref="T:System.ArgumentException">
                 The length of address is zero.</exception>
               <exception cref="T:System.InvalidOperationException">
                 The System.Net.Sockets.Socket is System.Net.Sockets.Socket.Listen(System.Int32)ing.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
            <Summary>
                 Begins an asynchronous request for a remote host connection. The host is specified
                 by a host name and a port number.
            </Summary>
             <param name="host">The name of the remote host.</param>
             <param name="port">The port number of the remote host.</param>
             <param name="requestCallback">
                 An System.AsyncCallback delegate that references the method to invoke when the
                 connect operation is complete.</param>
             <param name="state">
                 A user-defined object that contains information about the connect operation.
                 This object is passed to the requestCallback delegate when the operation is complete.
             </param>
             <Returns>
                 An System.IAsyncResult that references the asynchronous connection.
             </Returns>
               <exception cref="T:System.ArgumentNullException">
                 host is null.</exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.NotSupportedException">
                 This method is valid for sockets in the System.Net.Sockets.AddressFamily.InterNetwork
                 or System.Net.Sockets.AddressFamily.InterNetworkV6 families.
             </exception>
               <exception cref="T:System.ArgumentOutOfRangeException">
                 The port number is not valid.
             </exception>
               <exception cref="T:System.InvalidOperationException">
                 The System.Net.Sockets.Socket is System.Net.Sockets.Socket.Listen(System.Int32)ing.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
            <Summary>
                 Begins an asynchronous request to disconnect from a remote endpoint.
            </Summary>
             <param name="reuseSocket">
                 true if this socket can be reused after the connection is closed; otherwise,
                 false.</param>
             <param name="callback">The System.AsyncCallback delegate.</param>
             <param name="state">An object that contains state information for this request.</param>
             <Returns>
                 An System.IAsyncResult object that references the asynchronous operation.
             </Returns>
               <exception cref="T:System.NotSupportedException">
                 The operating system is Windows 2000 or earlier, and this method requires Windows
                 XP.</exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
            <Summary>
                 Begins to asynchronously receive data from a connected System.Net.Sockets.Socket.
            </Summary>
             <param name="buffers">An array of type System.Byte that is the storage location for the received data.</param>
             <param name="socketFlags">A bitwise combination of the System.Net.Sockets.SocketFlags values.</param>
             <param name="callback">
                 An System.AsyncCallback delegate that references the method to invoke when the
                 operation is complete.</param>
             <param name="state">
                 A user-defined object that contains information about the receive operation.
                 This object is passed to the System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)
                 delegate when the operation is complete.
             </param>
             <Returns>
                 An System.IAsyncResult that references the asynchronous read.
             </Returns>
               <exception cref="T:System.ArgumentNullException">
                 buffer is null.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.</exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
            <Summary>
                 Begins to asynchronously receive data from a connected System.Net.Sockets.Socket.
            </Summary>
             <param name="buffers">
                 An array of type System.Byte that is the storage location for the received data.
             </param>
             <param name="socketFlags">
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
             </param>
             <param name="errorCode">
                 A System.Net.Sockets.SocketError object that stores the socket error.
             </param>
             <param name="callback">
                 An System.AsyncCallback delegate that references the method to invoke when the
                 operation is complete.
             </param>
             <param name="state">
                 A user-defined object that contains information about the receive operation.
                 This object is passed to the System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)
                 delegate when the operation is complete.
             </param>
             <Returns>
                 An System.IAsyncResult that references the asynchronous read.
             </Returns>
               <exception cref="T:System.ArgumentNullException">
                 buffer is null.</exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.</exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
            <Summary>
                 Begins to asynchronously receive data from a connected System.Net.Sockets.Socket.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for the received data.
            
               offset:
                 The zero-based position in the buffer parameter at which to store the received
                 data.
            
               size:
                 The number of bytes to receive.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               callback:
                 An System.AsyncCallback delegate that references the method to invoke when the
                 operation is complete.
            
               state:
                 A user-defined object that contains information about the receive operation.
                 This object is passed to the System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)
                 delegate when the operation is complete.
            
            </Summary><Returns>
                 An System.IAsyncResult that references the asynchronous read.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
                 System.Net.Sockets.Socket has been closed.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
            
            <Summary>
                 Begins to asynchronously receive data from a connected System.Net.Sockets.Socket.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for the received data.
            
               offset:
                 The location in buffer to store the received data.
            
               size:
                 The number of bytes to receive.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               errorCode:
                 A System.Net.Sockets.SocketError object that stores the socket error.
            
               callback:
                 An System.AsyncCallback delegate that references the method to invoke when the
                 operation is complete.
            
               state:
                 A user-defined object that contains information about the receive operation.
                 This object is passed to the System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)
                 delegate when the operation is complete.
            
            </Summary><Returns>
                 An System.IAsyncResult that references the asynchronous read.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
                 System.Net.Sockets.Socket has been closed.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
            
            <Summary>
                 Begins to asynchronously receive data from a specified network device.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for the received data.
            
               offset:
                 The zero-based position in the buffer parameter at which to store the data.
            
               size:
                 The number of bytes to receive.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               remoteEP:
                 An System.Net.EndPoint that represents the source of the data.
            
               callback:
                 The System.AsyncCallback delegate.
            
               state:
                 An object that contains state information for this request.
            
            </Summary><Returns>
                 An System.IAsyncResult that references the asynchronous read.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.-or- remoteEP is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller higher in the call stack does not have permission for the requested
                 operation.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
            
            <Summary>
                 Begins to asynchronously receive the specified number of bytes of data into the
                 specified location of the data buffer, using the specified System.Net.Sockets.SocketFlags,
                 and stores the endpoint and packet information..
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for the received data.
            
               offset:
                 The zero-based position in the buffer parameter at which to store the data.
            
               size:
                 The number of bytes to receive.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               remoteEP:
                 An System.Net.EndPoint that represents the source of the data.
            
               callback:
                 The System.AsyncCallback delegate.
            
               state:
                 An object that contains state information for this request.
            
            </Summary><Returns>
                 An System.IAsyncResult that references the asynchronous read.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.-or- remoteEP is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.NotSupportedException"></exception>
                 The operating system is Windows 2000 or earlier, and this method requires Windows
                 XP.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
            
            <Summary>
                 Sends data asynchronously to a connected System.Net.Sockets.Socket.
            
             Parameters:
               buffers:
                 An array of type System.Byte that contains the data to send.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               callback:
                 The System.AsyncCallback delegate.
            
               state:
                 An object that contains state information for this request.
            
            </Summary><Returns>
                 An System.IAsyncResult that references the asynchronous send.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffers is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 buffers is empty.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See remarks section below.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
            
            <Summary>
                 Sends data asynchronously to a connected System.Net.Sockets.Socket.
            
             Parameters:
               buffers:
                 An array of type System.Byte that contains the data to send.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               errorCode:
                 A System.Net.Sockets.SocketError object that stores the socket error.
            
               callback:
                 The System.AsyncCallback delegate.
            
               state:
                 An object that contains state information for this request.
            
            </Summary><Returns>
                 An System.IAsyncResult that references the asynchronous send.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffers is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 buffers is empty.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See remarks section below.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
            
            <Summary>
                 Sends data asynchronously to a connected System.Net.Sockets.Socket.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to send.
            
               offset:
                 The zero-based position in the buffer parameter at which to begin sending data.
            
               size:
                 The number of bytes to send.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               callback:
                 The System.AsyncCallback delegate.
            
               state:
                 An object that contains state information for this request.
            
            </Summary><Returns>
                 An System.IAsyncResult that references the asynchronous send.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See remarks section below.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is less than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
            
            <Summary>
                 Sends data asynchronously to a connected System.Net.Sockets.Socket.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to send.
            
               offset:
                 The zero-based position in the buffer parameter at which to begin sending data.
            
               size:
                 The number of bytes to send.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               errorCode:
                 A System.Net.Sockets.SocketError object that stores the socket error.
            
               callback:
                 The System.AsyncCallback delegate.
            
               state:
                 An object that contains state information for this request.
            
            </Summary><Returns>
                 An System.IAsyncResult that references the asynchronous send.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See remarks section below.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is less than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
            
            <Summary>
                 Sends the file fileName to a connected System.Net.Sockets.Socket object using
                 the System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread flag.
            
             Parameters:
               fileName:
                 A string that contains the path and name of the file to send. This parameter
                 can be null.
            
               callback:
                 The System.AsyncCallback delegate.
            
               state:
                 An object that contains state information for this request.
            
            </Summary><Returns>
                 An System.IAsyncResult object that represents the asynchronous send.
            
             </Returns>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
                 The System.Net.Sockets.Socket object has been closed.
            
               <exception cref="T:System.NotSupportedException"></exception>
                 The socket is not connected to a remote host.
            
               <exception cref="T:System.IO.FileNotFoundException"></exception>
                 The file fileName was not found.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See remarks section below.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
            
            <Summary>
                 Sends a file and buffers of data asynchronously to a connected System.Net.Sockets.Socket
                 object.
            
             Parameters:
               fileName:
                 A string that contains the path and name of the file to be sent. This parameter
                 can be null.
            
               preBuffer:
                 A System.Byte array that contains data to be sent before the file is sent. This
                 parameter can be null.
            
               postBuffer:
                 A System.Byte array that contains data to be sent after the file is sent. This
                 parameter can be null.
            
               flags:
                 A bitwise combination of System.Net.Sockets.TransmitFileOptions values.
            
               callback:
                 An System.AsyncCallback delegate to be invoked when this operation completes.
                 This parameter can be null.
            
               state:
                 A user-defined object that contains state information for this request. This
                 parameter can be null.
            
            </Summary><Returns>
                 An System.IAsyncResult object that represents the asynchronous operation.
            
             </Returns>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
                 The System.Net.Sockets.Socket object has been closed.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See remarks section below.
            
               <exception cref="T:System.NotSupportedException"></exception>
                 The operating system is not Windows NT or later.- or - The socket is not connected
                 to a remote host.
            
               <exception cref="T:System.IO.FileNotFoundException"></exception>
                 The file fileName was not found.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
            
            <Summary>
                 Sends data asynchronously to a specific remote host.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to send.
            
               offset:
                 The zero-based position in buffer at which to begin sending data.
            
               size:
                 The number of bytes to send.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               remoteEP:
                 An System.Net.EndPoint that represents the remote device.
            
               callback:
                 The System.AsyncCallback delegate.
            
               state:
                 An object that contains state information for this request.
            
            </Summary><Returns>
                 An System.IAsyncResult that references the asynchronous send.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.-or- remoteEP is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller higher in the call stack does not have permission for the requested
                 operation.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Bind(System.Net.EndPoint)">
            <Summary>
                 Associates a System.Net.Sockets.Socket with a local endpoint.
            </Summary>
             <param name="localEP">
                 The local System.Net.EndPoint to associate with the System.Net.Sockets.Socket.
             </param>
               <exception cref="T:System.ArgumentNullException">
                 localEP is null.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.Security.SecurityException">
                 A caller higher in the call stack does not have permission for the requested
                 operation.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Close">
            <Summary>
                 Closes the System.Net.Sockets.Socket connection and releases all associated resources.
             </Summary>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Close(System.Int32)">
            <Summary>
                 Closes the System.Net.Sockets.Socket connection and releases all associated resources
                 with a specified timeout to allow queued data to be sent.
             </Summary>
            <param name="timeout">Wait up to timeout seconds to send any remaining data, then close the socket.</param>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Connect(System.Net.EndPoint)">
            <Summary>
                 Establishes a connection to a remote host.
            </Summary>
             <param name="remoteEP">An System.Net.EndPoint that represents the remote device.</param>
               <exception cref="T:System.ArgumentNullException">
                 remoteEP is null.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.</exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.Security.SecurityException">
                 A caller higher in the call stack does not have permission for the requested
                 operation.</exception>
               <exception cref="T:System.InvalidOperationException">
                 The System.Net.Sockets.Socket is System.Net.Sockets.Socket.Listen(System.Int32)ing.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Connect(System.Net.IPAddress,System.Int32)">
            <Summary>
                 Establishes a connection to a remote host. The host is specified by an IP address
                 and a port number.
             </Summary>
            <param name="address">
                 The IP address of the remote host.
             </param>
             <param name="port">
                 The port number of the remote host.
             </param>
               <exception cref="T:System.ArgumentNullException">
                 address is null.
             </exception>
               <exception cref="T:System.ArgumentOutOfRangeException">
                 The port number is not valid.</exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.</exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.NotSupportedException">
                 This method is valid for sockets in the System.Net.Sockets.AddressFamily.InterNetwork
                 or System.Net.Sockets.AddressFamily.InterNetworkV6 families.</exception>
               <exception cref="T:System.ArgumentException">
                 The length of address is zero.</exception>
               <exception cref="T:System.InvalidOperationException">
                 The System.Net.Sockets.Socket is System.Net.Sockets.Socket.Listen(System.Int32)ing.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Connect(System.String,System.Int32)">
            <Summary>
                 Establishes a connection to a remote host. The host is specified by a host name
                 and a port number.
            </Summary>
             <param name="host">The name of the remote host.</param>
             <param name="port">The port number of the remote host.</param>
               <exception cref="T:System.ArgumentNullException">
                 host is null.</exception>
               <exception cref="T:System.ArgumentOutOfRangeException">
                 The port number is not valid.</exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.</exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.NotSupportedException">
                 This method is valid for sockets in the System.Net.Sockets.AddressFamily.InterNetwork
                 or System.Net.Sockets.AddressFamily.InterNetworkV6 families.</exception>
               <exception cref="T:System.InvalidOperationException">
                 The System.Net.Sockets.Socket is System.Net.Sockets.Socket.Listen(System.Int32)ing.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Connect(System.Net.IPAddress[],System.Int32)">
            <Summary>
                 Establishes a connection to a remote host. The host is specified by an array
                 of IP addresses and a port number.
            </Summary>
             <param name="addresses">
                 The IP addresses of the remote host.
             </param>
             <param name="port">
                 The port number of the remote host.
             </param>
               <exception cref="T:System.ArgumentNullException">
                 addresses is null.</exception>
               <exception cref="T:System.ArgumentOutOfRangeException">
                 The port number is not valid.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.</exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.NotSupportedException">
                 This method is valid for sockets in the System.Net.Sockets.AddressFamily.InterNetwork
                 or System.Net.Sockets.AddressFamily.InterNetworkV6 families.
             </exception>
               <exception cref="T:System.ArgumentException">
                 The length of address is zero.</exception>
               <exception cref="T:System.InvalidOperationException">
                 The System.Net.Sockets.Socket is System.Net.Sockets.Socket.Listen(System.Int32)ing.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            
            <Summary>
                 Begins an asynchronous request for a connection to a remote host.
            
             Parameters:
               e:
                 The System.Net.Sockets.SocketAsyncEventArgs object to use for this asynchronous
                 socket operation.
            
            </Summary><Returns>
                 Returns true if the I/O operation is pending. The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will be raised upon completion of the operation. Returns
                 false if the I/O operation completed synchronously. In this case, The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will not be raised and the e object passed as a parameter
                 may be examined immediately after the method call returns to retrieve the result
                 of the operation.
            
             </Returns>
               <exception cref="T:System.ArgumentException"></exception>
                 An argument is not valid. This exception occurs if multiple buffers are specified,
                 the System.Net.Sockets.SocketAsyncEventArgs.BufferList property is not null.
            
               <exception cref="T:System.ArgumentNullException"></exception>
                 The e parameter cannot be null and the System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint
                 cannot be null.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 The System.Net.Sockets.Socket is listening or a socket operation was already
                 in progress using the System.Net.Sockets.SocketAsyncEventArgs object specified
                 in the e parameter.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.NotSupportedException"></exception>
                 Windows XP or later is required for this method. This exception also occurs if
                 the local endpoint and the System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint
                 are not the same address family.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller higher in the call stack does not have permission for the requested
                 operation.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Disconnect(System.Boolean)">
            <Summary>
                 Closes the socket connection and allows reuse of the socket.
            </Summary>
             <param name="reuseSocket">
                 true if this socket can be reused after the current connection is closed; otherwise,
                 false.
             </param>
               <exception cref="T:System.PlatformNotSupportedException">
                 This method requires Windows 2000 or earlier, or the exception will be thrown.
             </exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <Summary>
                 Begins an asynchronous request to disconnect from a remote endpoint.
            </Summary>
             <param name="e">
                 The System.Net.Sockets.SocketAsyncEventArgs object to use for this asynchronous
                 socket operation.
             </param>
             <Returns>
                 Returns true if the I/O operation is pending. The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will be raised upon completion of the operation. Returns
                 false if the I/O operation completed synchronously. In this case, The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will not be raised and the e object passed as a parameter
                 may be examined immediately after the method call returns to retrieve the result
                 of the operation.
             </Returns>
               <exception cref="T:System.ArgumentNullException">
                 The e parameter cannot be null.
             </exception>
               <exception cref="T:System.InvalidOperationException">
                 A socket operation was already in progress using the System.Net.Sockets.SocketAsyncEventArgs
                 object specified in the e parameter.</exception>
               <exception cref="T:System.NotSupportedException">
                 Windows XP or later is required for this method.
             </exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.DuplicateAndClose(System.Int32)">
            
            <Summary>
                 Duplicates the socket reference for the target process, and closes the socket
                 for this process.
            
             Parameters:
               targetProcessId:
                 The ID of the target process where a duplicate of the socket reference is created.
            
            </Summary><Returns>
                 The socket reference to be passed to the target process.
            
             </Returns>
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 targetProcessID is not a valid process id.-or- Duplication of the socket reference
                 failed.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndAccept(System.IAsyncResult)">
            
            <Summary>
                 Asynchronously accepts an incoming connection attempt and creates a new System.Net.Sockets.Socket
                 to handle remote host communication.
            
             Parameters:
               asyncResult:
                 An System.IAsyncResult that stores state information for this asynchronous operation
                 as well as any user defined data.
            
            </Summary><Returns>
                 A System.Net.Sockets.Socket to handle communication with the remote host.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 asyncResult is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 asyncResult was not created by a call to System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object).
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 System.Net.Sockets.Socket.EndAccept(System.IAsyncResult) method was previously
                 called.
            
               <exception cref="T:System.NotSupportedException"></exception>
                 Windows NT is required for this method.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndAccept(System.Byte[]@,System.IAsyncResult)">
            
            <Summary>
                 Asynchronously accepts an incoming connection attempt and creates a new System.Net.Sockets.Socket
                 object to handle remote host communication. This method returns a buffer that
                 contains the initial data transferred.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the bytes transferred.
            
               asyncResult:
                 An System.IAsyncResult object that stores state information for this asynchronous
                 operation as well as any user defined data.
            
            </Summary><Returns>
                 A System.Net.Sockets.Socket object to handle communication with the remote host.
            
             </Returns>
               <exception cref="T:System.NotSupportedException"></exception>
                 Windows NT is required for this method.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
                 The System.Net.Sockets.Socket object has been closed.
            
               <exception cref="T:System.ArgumentNullException"></exception>
                 asyncResult is empty.
            
               <exception cref="T:System.ArgumentException"></exception>
                 asyncResult was not created by a call to System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object).
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 System.Net.Sockets.Socket.EndAccept(System.IAsyncResult) method was previously
                 called.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the System.Net.Sockets.Socket See
                 the Remarks section for more information.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
            
            <Summary>
                 Asynchronously accepts an incoming connection attempt and creates a new System.Net.Sockets.Socket
                 object to handle remote host communication. This method returns a buffer that
                 contains the initial data and the number of bytes transferred.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the bytes transferred.
            
               bytesTransferred:
                 The number of bytes transferred.
            
               asyncResult:
                 An System.IAsyncResult object that stores state information for this asynchronous
                 operation as well as any user defined data.
            
            </Summary><Returns>
                 A System.Net.Sockets.Socket object to handle communication with the remote host.
            
             </Returns>
               <exception cref="T:System.NotSupportedException"></exception>
                 Windows NT is required for this method.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
                 The System.Net.Sockets.Socket object has been closed.
            
               <exception cref="T:System.ArgumentNullException"></exception>
                 asyncResult is empty.
            
               <exception cref="T:System.ArgumentException"></exception>
                 asyncResult was not created by a call to System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object).
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 System.Net.Sockets.Socket.EndAccept(System.IAsyncResult) method was previously
                 called.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the System.Net.Sockets.Socket. See
                 the Remarks section for more information.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndConnect(System.IAsyncResult)">
            <Summary>
                 Ends a pending asynchronous connection request.
            </Summary>
             <param name="asyncResult">
                 An System.IAsyncResult that stores state information and any user defined data
                 for this asynchronous operation.
             </param>
               <exception cref="T:System.ArgumentNullException">
                 asyncResult is null.
             </exception>
               <exception cref="T:System.ArgumentException">
                 asyncResult was not returned by a call to the System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)
                 method.
             </exception>
               <exception cref="T:System.InvalidOperationException">
                 System.Net.Sockets.Socket.EndConnect(System.IAsyncResult) was previously called
                 for the asynchronous connection.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndDisconnect(System.IAsyncResult)">
            <Summary>
                 Ends a pending asynchronous disconnect request.
            </Summary>
             <param name="asyncResult">
                 An System.IAsyncResult object that stores state information and any user-defined
                 data for this asynchronous operation.
             </param>
               <exception cref="T:System.NotSupportedException">
                 The operating system is Windows 2000 or earlier, and this method requires Windows
                 XP.
             </exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.ArgumentNullException">
                 asyncResult is null.
             </exception>
               <exception cref="T:System.ArgumentException">
                 asyncResult was not returned by a call to the System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)
                 method.
             </exception>
               <exception cref="T:System.InvalidOperationException">
                 System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult) was previously called
                 for the asynchronous connection.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
               <exception cref="T:System.Net.WebException">
                 The disconnect request has timed out.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndReceive(System.IAsyncResult)">
            
            <Summary>
                 Ends a pending asynchronous read.
            
             Parameters:
               asyncResult:
                 An System.IAsyncResult that stores state information and any user defined data
                 for this asynchronous operation.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 asyncResult is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 asyncResult was not returned by a call to the System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
                 method.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 System.Net.Sockets.Socket.EndReceive(System.IAsyncResult) was previously called
                 for the asynchronous read.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
            
            <Summary>
                 Ends a pending asynchronous read.
            
             Parameters:
               asyncResult:
                 An System.IAsyncResult that stores state information and any user defined data
                 for this asynchronous operation.
            
               errorCode:
                 A System.Net.Sockets.SocketError object that stores the socket error.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 asyncResult is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 asyncResult was not returned by a call to the System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
                 method.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 System.Net.Sockets.Socket.EndReceive(System.IAsyncResult) was previously called
                 for the asynchronous read.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
            
            <Summary>
                 Ends a pending asynchronous read from a specific endpoint.
            
             Parameters:
               asyncResult:
                 An System.IAsyncResult that stores state information and any user defined data
                 for this asynchronous operation.
            
               endPoint:
                 The source System.Net.EndPoint.
            
            </Summary><Returns>
                 If successful, the number of bytes received. If unsuccessful, returns 0.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 asyncResult is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 asyncResult was not returned by a call to the System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)
                 method.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)
                 was previously called for the asynchronous read.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
            
            <Summary>
                 Ends a pending asynchronous read from a specific endpoint. This method also reveals
                 more information about the packet than System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@).
            
             Parameters:
               asyncResult:
                 An System.IAsyncResult that stores state information and any user defined data
                 for this asynchronous operation.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values for the received
                 packet.
            
               endPoint:
                 The source System.Net.EndPoint.
            
               ipPacketInformation:
                 The System.Net.IPAddress and interface of the received packet.
            
            </Summary><Returns>
                 If successful, the number of bytes received. If unsuccessful, returns 0.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 asyncResult is null-or- endPoint is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 asyncResult was not returned by a call to the System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)
                 method.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)
                 was previously called for the asynchronous read.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndSend(System.IAsyncResult)">
            
            <Summary>
                 Ends a pending asynchronous send.
            
             Parameters:
               asyncResult:
                 An System.IAsyncResult that stores state information for this asynchronous operation.
            
            </Summary><Returns>
                 If successful, the number of bytes sent to the System.Net.Sockets.Socket; otherwise,
                 an invalid System.Net.Sockets.Socket error.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 asyncResult is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 asyncResult was not returned by a call to the System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
                 method.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 System.Net.Sockets.Socket.EndSend(System.IAsyncResult) was previously called
                 for the asynchronous send.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
            
            <Summary>
                 Ends a pending asynchronous send.
            
             Parameters:
               asyncResult:
                 An System.IAsyncResult that stores state information for this asynchronous operation.
            
               errorCode:
                 A System.Net.Sockets.SocketError object that stores the socket error.
            
            </Summary><Returns>
                 If successful, the number of bytes sent to the System.Net.Sockets.Socket; otherwise,
                 an invalid System.Net.Sockets.Socket error.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 asyncResult is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 asyncResult was not returned by a call to the System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
                 method.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 System.Net.Sockets.Socket.EndSend(System.IAsyncResult) was previously called
                 for the asynchronous send.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndSendFile(System.IAsyncResult)">
            <Summary>
                 Ends a pending asynchronous send of a file.
            </Summary>
             Parameters:
               asyncResult:
                 An System.IAsyncResult object that stores state information for this asynchronous
                 operation.
               <exception cref="T:System.NotSupportedException"></exception>
                 Windows NT is required for this method.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
                 The System.Net.Sockets.Socket object has been closed.
            
               <exception cref="T:System.ArgumentNullException"></exception>
                 asyncResult is empty.
            
               <exception cref="T:System.ArgumentException"></exception>
                 asyncResult was not returned by a call to the System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)
                 method.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult) was previously called
                 for the asynchronous System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object).
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See remarks section below.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.EndSendTo(System.IAsyncResult)">
            <Summary>
                 Ends a pending asynchronous send to a specific location.
            
             Parameters:
               asyncResult:
                 An System.IAsyncResult that stores state information and any user defined data
                 for this asynchronous operation.
            
            </Summary><Returns>
                 If successful, the number of bytes sent; otherwise, an invalid System.Net.Sockets.Socket
                 error.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 asyncResult is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 asyncResult was not returned by a call to the System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)
                 method.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult) was previously called
                 for the asynchronous send.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
            
            <Summary>
                 Returns the value of a specified System.Net.Sockets.Socket option, represented
                 as an object.
            
             Parameters:
               optionLevel:
                 One of the System.Net.Sockets.SocketOptionLevel values.
            
               optionName:
                 One of the System.Net.Sockets.SocketOptionName values.
            
            </Summary><Returns>
                 An object that represents the value of the option. When the optionName parameter
                 is set to System.Net.Sockets.SocketOptionName.Linger the return value is an instance
                 of the System.Net.Sockets.LingerOption class. When optionName is set to System.Net.Sockets.SocketOptionName.AddMembership
                 or System.Net.Sockets.SocketOptionName.DropMembership, the return value is an
                 instance of the System.Net.Sockets.MulticastOption class. When optionName is
                 any other value, the return value is an integer.
            
             </Returns>
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.-or-optionName was set to the unsupported value System.Net.Sockets.SocketOptionName.MaxConnections.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
            
            <Summary>
                 Returns the value of the specified System.Net.Sockets.Socket option in an array.
            
             Parameters:
               optionLevel:
                 One of the System.Net.Sockets.SocketOptionLevel values.
            
               optionName:
                 One of the System.Net.Sockets.SocketOptionName values.
            
               optionLength:
                 The length, in bytes, of the expected return value.
            
            </Summary><Returns>
                 An array of type System.Byte that contains the value of the socket option.
            
             </Returns>
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information. - or -In .NET Compact Framework applications, the Windows
                 CE default buffer space is set to 32768 bytes. You can change the per socket
                 buffer space by calling Overload:System.Net.Sockets.Socket.SetSocketOption.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
            
            <Summary>
                 Returns the specified System.Net.Sockets.Socket option setting, represented as
                 a byte array.
            </Summary>
             Parameters:
               optionLevel:
                 One of the System.Net.Sockets.SocketOptionLevel values.
            
               optionName:
                 One of the System.Net.Sockets.SocketOptionName values.
            
               optionValue:
                 An array of type System.Byte that is to receive the option setting.
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information. - or -In .NET Compact Framework applications, the Windows
                 CE default buffer space is set to 32768 bytes. You can change the per socket
                 buffer space by calling Overload:System.Net.Sockets.Socket.SetSocketOption.
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.IOControl(System.Int32,System.Byte[],System.Byte[])">
            <Summary>
                 Sets low-level operating modes for the System.Net.Sockets.Socket using numerical
                 control codes.
            
             Parameters:
               ioControlCode:
                 An System.Int32 value that specifies the control code of the operation to perform.
            
               optionInValue:
                 A System.Byte array that contains the input data required by the operation.
            
               optionOutValue:
                 A System.Byte array that contains the output data returned by the operation.
            
            </Summary><Returns>
                 The number of bytes in the optionOutValue parameter.
            
             </Returns>
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 An attempt was made to change the blocking mode without using the System.Net.Sockets.Socket.Blocking
                 property.
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller in the call stack does not have the required permissions.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
            
            <Summary>
                 Sets low-level operating modes for the System.Net.Sockets.Socket using the System.Net.Sockets.IOControlCode
                 enumeration to specify control codes.
            
             Parameters:
               ioControlCode:
                 A System.Net.Sockets.IOControlCode value that specifies the control code of the
                 operation to perform.
            
               optionInValue:
                 An array of type System.Byte that contains the input data required by the operation.
            
               optionOutValue:
                 An array of type System.Byte that contains the output data returned by the operation.
            
            </Summary><Returns>
                 The number of bytes in the optionOutValue parameter.
            
             </Returns>
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 An attempt was made to change the blocking mode without using the System.Net.Sockets.Socket.Blocking
                 property.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Listen(System.Int32)">
            
            <Summary>
                 Places a System.Net.Sockets.Socket in a listening state.
            </Summary>
             Parameters:
               backlog:
                 The maximum length of the pending connections queue.
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
            <Summary>
                 Determines the status of the System.Net.Sockets.Socket.
            
             Parameters:
               microSeconds:
                 The time to wait for a response, in microseconds.
            
               mode:
                 One of the System.Net.Sockets.SelectMode values.
            
            </Summary><Returns>
                 The status of the System.Net.Sockets.Socket based on the polling mode value passed
                 in the mode parameter.Mode Return Value System.Net.Sockets.SelectMode.SelectReadtrue
                 if System.Net.Sockets.Socket.Listen(System.Int32) has been called and a connection
                 is pending; -or- true if data is available for reading; -or- true if the connection
                 has been closed, reset, or terminated; otherwise, returns false. System.Net.Sockets.SelectMode.SelectWritetrue,
                 if processing a System.Net.Sockets.Socket.Connect(System.Net.EndPoint), and the
                 connection has succeeded; -or- true if data can be sent; otherwise, returns false.
                 System.Net.Sockets.SelectMode.SelectErrortrue if processing a System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
                 that does not block, and the connection has failed; -or- true if System.Net.Sockets.SocketOptionName.OutOfBandInline
                 is not set and out-of-band data is available; otherwise, returns false.
            
             </Returns>
               <exception cref="T:System.NotSupportedException"></exception>
                 The mode parameter is not one of the System.Net.Sockets.SelectMode values.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See remarks below.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Receive(System.Byte[])">
            
            <Summary>
                 Receives data from a bound System.Net.Sockets.Socket into a receive buffer.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for the received data.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller in the call stack does not have the required permissions.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            
            <Summary>
                 Receives data from a bound System.Net.Sockets.Socket into the list of receive
                 buffers.
            
             Parameters:
               buffers:
                 A list of System.ArraySegment`1s of type System.Byte that contains the received
                 data.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 The buffer parameter is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred while attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
            
            <Summary>
                 Receives data from a bound System.Net.Sockets.Socket into the list of receive
                 buffers, using the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffers:
                 A list of System.ArraySegment`1s of type System.Byte that contains the received
                 data.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffers is null.-or-buffers.Count is zero.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred while attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
            
            <Summary>
                 Receives data from a bound System.Net.Sockets.Socket into a receive buffer, using
                 the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for the received data.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller in the call stack does not have the required permissions.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
            
            <Summary>
                 Receives data from a bound System.Net.Sockets.Socket into the list of receive
                 buffers, using the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffers:
                 A list of System.ArraySegment`1s of type System.Byte that contains the received
                 data.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               errorCode:
                 A System.Net.Sockets.SocketError object that stores the socket error.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffers is null.-or-buffers.Count is zero.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred while attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
            
            <Summary>
                 Receives the specified number of bytes of data from a bound System.Net.Sockets.Socket
                 into a receive buffer, using the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for the received data.
            
               size:
                 The number of bytes to receive.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 size exceeds the size of buffer.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller in the call stack does not have the required permissions.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
            
            <Summary>
                 Receives the specified number of bytes from a bound System.Net.Sockets.Socket
                 into the specified offset position of the receive buffer, using the specified
                 System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for received data.
            
               offset:
                 The location in buffer to store the received data.
            
               size:
                 The number of bytes to receive.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 socketFlags is not a valid combination of values.-or- The System.Net.Sockets.Socket.LocalEndPoint
                 property was not set.-or- An operating system error occurs while accessing the
                 System.Net.Sockets.Socket.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller in the call stack does not have the required permissions.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
            
            <Summary>
                 Receives data from a bound System.Net.Sockets.Socket into a receive buffer, using
                 the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for the received data.
            
               offset:
                 The position in the buffer parameter to store the received data.
            
               size:
                 The number of bytes to receive.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               errorCode:
                 A System.Net.Sockets.SocketError object that stores the socket error.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 socketFlags is not a valid combination of values.-or- The System.Net.Sockets.Socket.LocalEndPoint
                 property is not set.-or- An operating system error occurs while accessing the
                 System.Net.Sockets.Socket.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller in the call stack does not have the required permissions.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            
            <Summary>
                 Begins an asynchronous request to receive data from a connected System.Net.Sockets.Socket
                 object.
            
             Parameters:
               e:
                 The System.Net.Sockets.SocketAsyncEventArgs object to use for this asynchronous
                 socket operation.
            
            </Summary><Returns>
                 Returns true if the I/O operation is pending. The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will be raised upon completion of the operation. Returns
                 false if the I/O operation completed synchronously. In this case, The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will not be raised and the e object passed as a parameter
                 may be examined immediately after the method call returns to retrieve the result
                 of the operation.
            
             </Returns>
               <exception cref="T:System.ArgumentException"></exception>
                 An argument was invalid. The System.Net.Sockets.SocketAsyncEventArgs.Buffer or
                 System.Net.Sockets.SocketAsyncEventArgs.BufferList properties on the e parameter
                 must reference valid buffers. One or the other of these properties may be set,
                 but not both at the same time.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 A socket operation was already in progress using the System.Net.Sockets.SocketAsyncEventArgs
                 object specified in the e parameter.
            
               <exception cref="T:System.NotSupportedException"></exception>
                 Windows XP or later is required for this method.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
            
            <Summary>
                 Receives a datagram into the data buffer and stores the endpoint.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for received data.
            
               remoteEP:
                 An System.Net.EndPoint, passed by reference, that represents the remote server.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.-or- remoteEP is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller in the call stack does not have the required permissions.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
            
            <Summary>
                 Receives a datagram into the data buffer, using the specified System.Net.Sockets.SocketFlags,
                 and stores the endpoint.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for the received data.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               remoteEP:
                 An System.Net.EndPoint, passed by reference, that represents the remote server.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.-or- remoteEP is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller in the call stack does not have the required permissions.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
            
            <Summary>
                 Receives the specified number of bytes into the data buffer, using the specified
                 System.Net.Sockets.SocketFlags, and stores the endpoint.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for received data.
            
               size:
                 The number of bytes to receive.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               remoteEP:
                 An System.Net.EndPoint, passed by reference, that represents the remote server.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.-or- remoteEP is null.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 size is less than 0.-or- size is greater than the length of buffer.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 socketFlags is not a valid combination of values.-or- The System.Net.Sockets.Socket.LocalEndPoint
                 property was not set.-or- An operating system error occurs while accessing the
                 System.Net.Sockets.Socket.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller in the call stack does not have the required permissions.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
            
            <Summary>
                 Receives the specified number of bytes of data into the specified location of
                 the data buffer, using the specified System.Net.Sockets.SocketFlags, and stores
                 the endpoint.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for received data.
            
               offset:
                 The position in the buffer parameter to store the received data.
            
               size:
                 The number of bytes to receive.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               remoteEP:
                 An System.Net.EndPoint, passed by reference, that represents the remote server.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.-or- remoteEP is null.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of the buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 socketFlags is not a valid combination of values.-or- The System.Net.Sockets.Socket.LocalEndPoint
                 property was not set.-or- An error occurred when attempting to access the socket.
                 See the Remarks section for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            
            <Summary>
                 Begins to asynchronously receive data from a specified network device.
            
             Parameters:
               e:
                 The System.Net.Sockets.SocketAsyncEventArgs object to use for this asynchronous
                 socket operation.
            
            </Summary><Returns>
                 Returns true if the I/O operation is pending. The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will be raised upon completion of the operation. Returns
                 false if the I/O operation completed synchronously. In this case, The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will not be raised and the e object passed as a parameter
                 may be examined immediately after the method call returns to retrieve the result
                 of the operation.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 The System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint cannot be null.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 A socket operation was already in progress using the System.Net.Sockets.SocketAsyncEventArgs
                 object specified in the e parameter.
            
               <exception cref="T:System.NotSupportedException"></exception>
                 Windows XP or later is required for this method.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
            
            <Summary>
                 Receives the specified number of bytes of data into the specified location of
                 the data buffer, using the specified System.Net.Sockets.SocketFlags, and stores
                 the endpoint and packet information.
            
             Parameters:
               buffer:
                 An array of type System.Byte that is the storage location for received data.
            
               offset:
                 The position in the buffer parameter to store the received data.
            
               size:
                 The number of bytes to receive.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               remoteEP:
                 An System.Net.EndPoint, passed by reference, that represents the remote server.
            
               ipPacketInformation:
                 An System.Net.Sockets.IPPacketInformation holding address and interface information.
            
            </Summary><Returns>
                 The number of bytes received.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.- or- remoteEP is null.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of the buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 socketFlags is not a valid combination of values.-or- The System.Net.Sockets.Socket.LocalEndPoint
                 property was not set.-or- The .NET Framework is running on an AMD 64-bit processor.-or-
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.NotSupportedException"></exception>
                 The operating system is Windows 2000 or earlier, and this method requires Windows
                 XP.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            
            <Summary>
                 Begins to asynchronously receive the specified number of bytes of data into the
                 specified location in the data buffer, using the specified System.Net.Sockets.SocketAsyncEventArgs.SocketFlags,
                 and stores the endpoint and packet information.
            
             Parameters:
               e:
                 The System.Net.Sockets.SocketAsyncEventArgs object to use for this asynchronous
                 socket operation.
            
            </Summary><Returns>
                 Returns true if the I/O operation is pending. The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will be raised upon completion of the operation. Returns
                 false if the I/O operation completed synchronously. In this case, The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will not be raised and the e object passed as a parameter
                 may be examined immediately after the method call returns to retrieve the result
                 of the operation.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 The System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint cannot be null.
            
               <exception cref="T:System.NotSupportedException"></exception>
                 Windows XP or later is required for this method.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Send(System.Byte[])">
            
            <Summary>
                 Sends data to a connected System.Net.Sockets.Socket.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to be sent.
            
            </Summary><Returns>
                 The number of bytes sent to the System.Net.Sockets.Socket.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            
            <Summary>
                 Sends the set of buffers in the list to a connected System.Net.Sockets.Socket.
            
             Parameters:
               buffers:
                 A list of System.ArraySegment`1s of type System.Byte that contains the data to
                 be sent.
            
            </Summary><Returns>
                 The number of bytes sent to the System.Net.Sockets.Socket.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffers is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 buffers is empty.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See remarks section below.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
            
            <Summary>
                 Sends data to a connected System.Net.Sockets.Socket using the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to be sent.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
            </Summary><Returns>
                 The number of bytes sent to the System.Net.Sockets.Socket.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
            
            <Summary>
                 Sends the set of buffers in the list to a connected System.Net.Sockets.Socket,
                 using the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffers:
                 A list of System.ArraySegment`1s of type System.Byte that contains the data to
                 be sent.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
            </Summary><Returns>
                 The number of bytes sent to the System.Net.Sockets.Socket.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffers is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 buffers is empty.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
            
            <Summary>
                 Sends the specified number of bytes of data to a connected System.Net.Sockets.Socket,
                 using the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to be sent.
            
               size:
                 The number of bytes to send.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
            </Summary><Returns>
                 The number of bytes sent to the System.Net.Sockets.Socket.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 size is less than 0 or exceeds the size of the buffer.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 socketFlags is not a valid combination of values.-or- An operating system error
                 occurs while accessing the socket. See the Remarks section for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
            
            <Summary>
                 Sends the set of buffers in the list to a connected System.Net.Sockets.Socket,
                 using the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffers:
                 A list of System.ArraySegment`1s of type System.Byte that contains the data to
                 be sent.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               errorCode:
                 A System.Net.Sockets.SocketError object that stores the socket error.
            
            </Summary><Returns>
                 The number of bytes sent to the System.Net.Sockets.Socket.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffers is null.
            
               <exception cref="T:System.ArgumentException"></exception>
                 buffers is empty.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
            
            <Summary>
                 Sends the specified number of bytes of data to a connected System.Net.Sockets.Socket,
                 starting at the specified offset, and using the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to be sent.
            
               offset:
                 The position in the data buffer at which to begin sending data.
            
               size:
                 The number of bytes to send.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
            </Summary><Returns>
                 The number of bytes sent to the System.Net.Sockets.Socket.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 socketFlags is not a valid combination of values.-or- An operating system error
                 occurs while accessing the System.Net.Sockets.Socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
            
            <Summary>
                 Sends the specified number of bytes of data to a connected System.Net.Sockets.Socket,
                 starting at the specified offset, and using the specified System.Net.Sockets.SocketFlags
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to be sent.
            
               offset:
                 The position in the data buffer at which to begin sending data.
            
               size:
                 The number of bytes to send.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               errorCode:
                 A System.Net.Sockets.SocketError object that stores the socket error.
            
            </Summary><Returns>
                 The number of bytes sent to the System.Net.Sockets.Socket.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 socketFlags is not a valid combination of values.-or- An operating system error
                 occurs while accessing the System.Net.Sockets.Socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            
            <Summary>
                 Sends data asynchronously to a connected System.Net.Sockets.Socket object.
            
             Parameters:
               e:
                 The System.Net.Sockets.SocketAsyncEventArgs object to use for this asynchronous
                 socket operation.
            
            </Summary><Returns>
                 Returns true if the I/O operation is pending. The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will be raised upon completion of the operation. Returns
                 false if the I/O operation completed synchronously. In this case, The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will not be raised and the e object passed as a parameter
                 may be examined immediately after the method call returns to retrieve the result
                 of the operation.
            
             </Returns>
               <exception cref="T:System.ArgumentException"></exception>
                 The System.Net.Sockets.SocketAsyncEventArgs.Buffer or System.Net.Sockets.SocketAsyncEventArgs.BufferList
                 properties on the e parameter must reference valid buffers. One or the other
                 of these properties may be set, but not both at the same time.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 A socket operation was already in progress using the System.Net.Sockets.SocketAsyncEventArgs
                 object specified in the e parameter.
            
               <exception cref="T:System.NotSupportedException"></exception>
                 Windows XP or later is required for this method.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 The System.Net.Sockets.Socket is not yet connected or was not obtained via an
                 System.Net.Sockets.Socket.Accept, System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs),or
                 Overload:System.Net.Sockets.Socket.BeginAccept, method.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SendFile(System.String)">
            
            <Summary>
                 Sends the file fileName to a connected System.Net.Sockets.Socket object with
                 the System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread transmit flag.
            </Summary>
             <param name="fileName">
                 A System.String that contains the path and name of the file to be sent. This
                 parameter can be null.
             </param>
               <exception cref="T:System.NotSupportedException">
                 The socket is not connected to a remote host.
             </exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.InvalidOperationException">
                 The System.Net.Sockets.Socket object is not in blocking mode and cannot accept
                 this synchronous call.
             </exception>
               <exception cref="T:System.IO.FileNotFoundException">
                 The file fileName was not found.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
            <Summary>
                 Sends the file fileName and buffers of data to a connected System.Net.Sockets.Socket
                 object using the specified System.Net.Sockets.TransmitFileOptions value.
             </Summary>
            
             Parameters:
               fileName:
                 A System.String that contains the path and name of the file to be sent. This
                 parameter can be null.
            
               preBuffer:
                 A System.Byte array that contains data to be sent before the file is sent. This
                 parameter can be null.
            
               postBuffer:
                 A System.Byte array that contains data to be sent after the file is sent. This
                 parameter can be null.
            
               flags:
                 One or more of System.Net.Sockets.TransmitFileOptions values.
            
               <exception cref="T:System.NotSupportedException">
                 The operating system is not Windows NT or later.- or - The socket is not connected
                 to a remote host.
             </exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.InvalidOperationException">
                 The System.Net.Sockets.Socket object is not in blocking mode and cannot accept
                 this synchronous call.
             </exception>
               <exception cref="T:System.IO.FileNotFoundException">
                 The file fileName was not found.
             </exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            
            <Summary>
                 Sends a collection of files or in memory data buffers asynchronously to a connected
                 System.Net.Sockets.Socket object.
            </Summary>
             <param name="e">
                 The System.Net.Sockets.SocketAsyncEventArgs object to use for this asynchronous
                 socket operation.
             </param>
             <Returns>
                 Returns true if the I/O operation is pending. The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will be raised upon completion of the operation. Returns
                 false if the I/O operation completed synchronously. In this case, The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will not be raised and the e object passed as a parameter
                 may be examined immediately after the method call returns to retrieve the result
                 of the operation.
             </Returns>
               <exception cref="T:System.IO.FileNotFoundException">
                 The file specified in the System.Net.Sockets.SendPacketsElement.FilePath property
                 was not found.
             </exception>
               <exception cref="T:System.InvalidOperationException">
                 A socket operation was already in progress using the System.Net.Sockets.SocketAsyncEventArgs
                 object specified in the e parameter.
             </exception>
               <exception cref="T:System.NotSupportedException">
                 Windows XP or later is required for this method. This exception also occurs if
                 the System.Net.Sockets.Socket is not connected to a remote host.
             </exception>
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 A connectionless System.Net.Sockets.Socket is being used and the file being sent
                 exceeds the maximum packet size of the underlying transport.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SendTo(System.Byte[],System.Net.EndPoint)">
            
            <Summary>
                 Sends data to the specified endpoint.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to be sent.
            
               remoteEP:
                 The System.Net.EndPoint that represents the destination for the data.
            
            </Summary><Returns>
                 The number of bytes sent.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.-or- remoteEP is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
            
            <Summary>
                 Sends data to a specific endpoint using the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to be sent.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               remoteEP:
                 The System.Net.EndPoint that represents the destination location for the data.
            
            </Summary><Returns>
                 The number of bytes sent.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.-or- remoteEP is null.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
            
            <Summary>
                 Sends the specified number of bytes of data to the specified endpoint using the
                 specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to be sent.
            
               size:
                 The number of bytes to send.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               remoteEP:
                 The System.Net.EndPoint that represents the destination location for the data.
            
            </Summary><Returns>
                 The number of bytes sent.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.-or- remoteEP is null.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 The specified size exceeds the size of buffer.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
            
            <Summary>
                 Sends the specified number of bytes of data to the specified endpoint, starting
                 at the specified location in the buffer, and using the specified System.Net.Sockets.SocketFlags.
            
             Parameters:
               buffer:
                 An array of type System.Byte that contains the data to be sent.
            
               offset:
                 The position in the data buffer at which to begin sending data.
            
               size:
                 The number of bytes to send.
            
               socketFlags:
                 A bitwise combination of the System.Net.Sockets.SocketFlags values.
            
               remoteEP:
                 The System.Net.EndPoint that represents the destination location for the data.
            
            </Summary><Returns>
                 The number of bytes sent.
            
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 buffer is null.-or- remoteEP is null.
            
               <exception cref="T:System.ArgumentOutOfRangeException"></exception>
                 offset is less than 0.-or- offset is greater than the length of buffer.-or- size
                 is less than 0.-or- size is greater than the length of buffer minus the value
                 of the offset parameter.
            
               <exception cref="T:System.Net.Sockets.SocketException"></exception>
                 socketFlags is not a valid combination of values.-or- An operating system error
                 occurs while accessing the System.Net.Sockets.Socket. See the Remarks section
                 for more information.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
            
               <exception cref="T:System.Security.SecurityException"></exception>
                 A caller in the call stack does not have the required permissions.
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <Summary>
                 Sends data asynchronously to a specific remote host.
            </Summary>
             <param name="e">
                 The System.Net.Sockets.SocketAsyncEventArgs object to use for this asynchronous
                 socket operation.
             </param>
             <Returns>
                 Returns true if the I/O operation is pending. The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will be raised upon completion of the operation. Returns
                 false if the I/O operation completed synchronously. In this case, The System.Net.Sockets.SocketAsyncEventArgs.Completed
                 event on the e parameter will not be raised and the e object passed as a parameter
                 may be examined immediately after the method call returns to retrieve the result
                 of the operation.
             </Returns>
               <exception cref="T:System.ArgumentNullException"></exception>
                 The System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint cannot be null.
            
               <exception cref="T:System.InvalidOperationException"></exception>
                 A socket operation was already in progress using the System.Net.Sockets.SocketAsyncEventArgs
                 object specified in the e parameter.
            
               <exception cref="T:System.NotSupportedException"></exception>
                 Windows XP or later is required for this method.
            
               <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
               <exception cref="T:System.Net.Sockets.SocketException">
                 The protocol specified is connection-oriented, but the System.Net.Sockets.Socket
                 is not yet connected.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
            <Summary>
                 Set the IP protection level on a socket.
             </Summary>
             <param name="level">The IP protection level to set on this socket.</param>
               <exception cref="T:System.ArgumentException">
                 The level parameter cannot be System.Net.Sockets.IPProtectionLevel.Unspecified.
                 The IP protection level cannot be set to unspecified.
             </exception>
               <exception cref="T:System.NotSupportedException">
                 The System.Net.Sockets.AddressFamily of the socket must be either System.Net.Sockets.AddressFamily.InterNetworkV6
                 or System.Net.Sockets.AddressFamily.InterNetwork.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
            <Summary>
                 Sets the specified System.Net.Sockets.Socket option to the specified integer
                 value.
            </Summary>
             <param name="optionLevel">One of the System.Net.Sockets.SocketOptionLevel values.</param>
             <param name="optionName">One of the System.Net.Sockets.SocketOptionName values.</param>
             <param name="optionValue">A value of the option.</param>
             <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
             <exception cref="T:System.ObjectDisposedException">
             The System.Net.Sockets.Socket has been closed.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
            <Summary>
                 Sets the specified System.Net.Sockets.Socket option to the specified value, represented
                 as a byte array.
             </Summary>
            <param name="optionLevel">One of the System.Net.Sockets.SocketOptionLevel values.</param>
             <param name="optionName">One of the System.Net.Sockets.SocketOptionName values.</param>
             <param name="optionValue">An array of type System.Byte that represents the value of the option.</param>
             <exception cref="T:System.Net.Sockets.SocketException">
                 An error occurred when attempting to access the socket. See the Remarks section
                 for more information.
             </exception>
             <exception cref="T:System.ObjectDisposedException">
             The System.Net.Sockets.Socket has been closed.
             </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
            <Summary>
                Sets the specified System.Net.Sockets.Socket option to the specified value, represented
                as an object.
            </Summary>
            <param name="optionLevel">
                One of the System.Net.Sockets.SocketOptionLevel values.
            </param>
            <param name="optionName">
                One of the System.Net.Sockets.SocketOptionName values.
            </param>
            <param name="optionValue">
                A System.Net.Sockets.LingerOption or System.Net.Sockets.MulticastOption that
                contains the value of the option.
            </param>
            <exception cref="T:System.ArgumentNullException">
                optionValue is null.
            </exception>
            <exception cref="T:System.Net.Sockets.SocketException">
                An error occurred when attempting to access the socket. See the Remarks section
                for more information.
            </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
            <exception cref="T:System.Net.Sockets.SocketException">
                An error occurred when attempting to access the socket. See the Remarks section
                for more information.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The System.Net.Sockets.Socket has been closed.
            </exception>
        </member>
        <member name="M:SharpRemote.Sockets.ISocket.Shutdown(System.Net.Sockets.SocketShutdown)">
            <summary>
                Disables sends and receives on a System.Net.Sockets.Socket.
            </summary>
            <param name="how">
                One of the System.Net.Sockets.SocketShutdown values that specifies the operation
                that will no longer be allowed.
            </param>
            <exception cref="T:System.Net.Sockets.SocketException">
                An error occurred when attempting to access the socket. See the Remarks section
                for more information.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The System.Net.Sockets.Socket has been closed.
            </exception>
        </member>
        <member name="T:SharpRemote.Sockets.Socket2">
            <summary>
                Proxy around a <see cref="T:System.Net.Sockets.Socket" /> object.
            </summary>
            <remarks>
                This should be part of the System.Extensions project and be publicly available.
            </remarks>
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.#ctor(System.Net.Sockets.Socket)">
            <summary>
                Initializes this object.
            </summary>
            <param name="socket"></param>
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
            <summary>
                Initializes this object.
            </summary>
            <param name="addressFamily"></param>
            <param name="socketType"></param>
            <param name="protocolType"></param>
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.#ctor(System.Net.Sockets.SocketInformation)">
            <summary>
                Initializes this object.
            </summary>
            <param name="socketInformation"></param>
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
            <summary>
                Initializes this object.
            </summary>
            <param name="socketType"></param>
            <param name="protocolType"></param>
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.AddressFamily">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.Available">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.Blocking">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.Connected">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.DontFragment">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.DualMode">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.EnableBroadcast">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.ExclusiveAddressUse">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.Handle">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.IsBound">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.LingerState">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.LocalEndPoint">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.MulticastLoopback">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.NoDelay">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.ProtocolType">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.ReceiveBufferSize">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.ReceiveTimeout">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.RemoteEndPoint">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.SendBufferSize">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.SendTimeout">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.SocketType">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.Ttl">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Sockets.Socket2.UseOnlyOverlappedIO">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Accept">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginAccept(System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Bind(System.Net.EndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Close">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Close(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Connect(System.Net.EndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Connect(System.Net.IPAddress,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Connect(System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Connect(System.Net.IPAddress[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Disconnect(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Dispose">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.DuplicateAndClose(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndAccept(System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndAccept(System.Byte[]@,System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndConnect(System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndDisconnect(System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndReceive(System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndSend(System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndSendFile(System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.EndSendTo(System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.IOControl(System.Int32,System.Byte[],System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Listen(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Poll(System.Int32,System.Net.Sockets.SelectMode)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Receive(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Send(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SendFile(System.String)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SendTo(System.Byte[],System.Net.EndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.Shutdown(System.Net.Sockets.SocketShutdown)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.CreateSocketAndBindToAnyPort(System.Net.IPAddress,System.Net.IPEndPoint@)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="localAddress"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.Sockets.Socket2.CreateSocketAndBindToAnyPort(System.Net.IPAddress,System.UInt16,System.UInt16,System.Net.IPEndPoint@)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="minPort"></param>
            <param name="maxPort"></param>
            <param name="localAddress"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.TimeSpanStatisticsContainer">
            <summary>
                Collects statistics about a series of timespan measurements.
            </summary>
        </member>
        <member name="P:SharpRemote.TimeSpanStatisticsContainer.Average">
            <summary>
            </summary>
        </member>
        <member name="M:SharpRemote.TimeSpanStatisticsContainer.Enqueue(System.TimeSpan)">
            <summary>
                Adds a sample to this container.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:SharpRemote.ParameterCountMismatch">
            <summary>
                Indicates that a method has a different amount of parameters than expected.
            </summary>
        </member>
        <member name="T:SharpRemote.EnumValueDescription">
            <summary>
            Describes a specific value of a particular enum.
            </summary>
        </member>
        <member name="P:SharpRemote.EnumValueDescription.Name">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.EnumValueDescription.Value">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.EnumValueDescription.NumericValue">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.EnumValueDescription.ToString">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.FieldDescription">
            <summary>
                Similar to <see cref="T:System.Reflection.FieldInfo" /> (in that it describes a particular .NET field), but only
                describes its static structure that is important to a <see cref="T:SharpRemote.ISerializer" />.
            </summary>
        </member>
        <member name="M:SharpRemote.FieldDescription.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.FieldDescription.FieldTypeId">
            <summary>
                The id of the <see cref="T:SharpRemote.TypeDescription" /> which describes the type of this field.
            </summary>
        </member>
        <member name="P:SharpRemote.FieldDescription.FieldType">
            <summary>
                The type of this field, equivalent of <see cref="P:System.Reflection.FieldInfo.FieldType" />.
            </summary>
        </member>
        <member name="P:SharpRemote.FieldDescription.Name">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.FieldDescription.TypeDescription">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.FieldDescription.Type">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.FieldDescription.MemberInfo">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.FieldDescription.Field">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpRemote.FieldDescription.ToString">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.FieldDescription.Create(System.Reflection.FieldInfo,System.Collections.Generic.IDictionary{System.String,SharpRemote.TypeDescription})">
            <summary>
                Creates a new description for the given field.
            </summary>
            <param name="field"></param>
            <param name="typesByAssemblyQualifiedName"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.HeartbeatSettings">
            <summary>
                Used to configure the heartbeat mechanism of <see cref="T:SharpRemote.Hosting.ISilo" />s.
            </summary>
        </member>
        <member name="P:SharpRemote.HeartbeatSettings.Dont">
            <summary>
                NEVER, EVER USE THIS SETTING IN PRODUCTION CODE. NEVER!!!!
            </summary>
        </member>
        <member name="F:SharpRemote.HeartbeatSettings.AllowRemoteHeartbeatDisable">
            <summary>
                Whether or not a remote endpoint can request to disable heartbeat detection on this
                endpoint.
            </summary>
            <remarks>
                This setting can be set to true to make interactive debugging easier: When an endpoint detects that
                a debugger is attached to its process, then it will request the other endpoint to disable its heartbeat
                detection UNTIL the debugger is detached again. This way a debugger can be attached to just one of the
                two processes AND set breakpoints, without having the endpoint of the other process perform a disconnection.
            </remarks>
            <remarks>
                Is set to false by default.
            </remarks>
        </member>
        <member name="F:SharpRemote.HeartbeatSettings.Interval">
            <summary>
                The minimum amount of time that shall pass between heartbeat checks.
            </summary>
            <remarks>
                Is set to 1 second by default.
            </remarks>
        </member>
        <member name="F:SharpRemote.HeartbeatSettings.ReportDebuggerAttached">
            <summary>
                When set to true, the other endpoint is notified if a debugger is attached to this endpoint.
                When set to false, the other endpoint is never notified of this fact.
            </summary>
            <remarks>
                Is set to true by default.
            </remarks>
        </member>
        <member name="F:SharpRemote.HeartbeatSettings.ReportSkippedHeartbeatsAsFailureWithDebuggerAttached">
            <summary>
                Whether or not skipped heartbeats are reported as failures when the debugger
                is attached on the monitoring process.
            </summary>
            <remarks>
                Having a debugger attached and actually pausing the monitoring process can cause
                a lot of heartbeats to be missed which is why this feature can be disabled for debugging sessions.
            </remarks>
            <remarks>
                Is set to false by default.
            </remarks>
        </member>
        <member name="F:SharpRemote.HeartbeatSettings.SkippedHeartbeatThreshold">
            <summary>
                The amount of heartbeats it takes for failure to be assumed.
            </summary>
            <remarks>
                Is set to 10 by default.
            </remarks>
        </member>
        <member name="F:SharpRemote.HeartbeatSettings.UseHeartbeatFailureDetection">
            <summary>
                Whether or not a "heartbeat" is used to regularly check the status of the host process.
                If the host process should fail to check in, then it is assumed to have faulted and is killed.
            </summary>
            <remarks>
                This value should always be set to true in production environments.
            </remarks>
        </member>
        <member name="M:SharpRemote.HeartbeatSettings.#ctor">
            <summary>
                Initializes this class with its default values.
            </summary>
        </member>
        <member name="T:SharpRemote.FileInfoExtensions">
            <summary>
                Extension methods for the <see cref="T:System.IO.FileInfo" /> class.
            </summary>
        </member>
        <member name="M:SharpRemote.FileInfoExtensions.TryDelete(System.IO.FileInfo)">
            <summary>
                Tries to delete the given file.
                If deleting fails, multiple subsequent tries to delete the file may be performed.
            </summary>
            <remarks>
                This method may block up to 10 seconds.
            </remarks>
            <param name="file"></param>
        </member>
        <member name="T:SharpRemote.Hosting.OutOfProcess.Decision">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.Decision.RestartHost">
            <summary>
            The host process shall be restarted in order to resolve the failure.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.Decision.Stop">
            <summary>
            The failure will be ignored, the host process, if still alive, be killed
            and from then on the <see cref="T:SharpRemote.Hosting.OutOfProcessSilo"/> will behave as having Stop()ed.
            </summary>
        </member>
        <member name="T:SharpRemote.Hosting.OutOfProcess.OutOfProcessQueue">
            <summary>
                Responsible for starting, restarting and stopping another application.
            </summary>
            <remarks>
                This classes' right to exist comes from the fact that synchronizing the Start() and HandleFailure()
                events is quite complicated and brittle (a lot of callbacks => chance for deadlocks would increase) and
                therefore serialization using a worker thread and a queue is way simpler.
                The main problem is having to deal with late failures while we're in the process of starting the host
                application. Ideally we only want to handle those (successive) failures once the current process is finished,
                hence the approach using a queue.
            </remarks>
        </member>
        <member name="E:SharpRemote.Hosting.OutOfProcess.OutOfProcessQueue.OnHostStarted">
            <summary>
                This event is invoked whenever the host process was successfully started, and a connection
                to it was established.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.OutOfProcessQueue.EndPointOnOnFailure(SharpRemote.EndPointDisconnectReason,SharpRemote.ConnectionId)">
            <summary>
                Is called when the endpoint reports a failure.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.OutOfProcessQueue.StartOnce(System.Int32,System.Int32@,SharpRemote.ConnectionId@,System.Collections.Generic.List{System.Exception}@)">
            <summary>
                Tries to start the host application exactly once.
            </summary>
            <param name="currentRestart">The index of this restart, e.g. 0 for the first try, 1 for the 2nd, etc...</param>
            <param name="pid">The process id of the resulting process, if successfully started</param>
            <param name="connectionId"></param>
            <param name="exceptions">The list that will be filled with the exception(s) relevant to the Start, should any be thrown</param>
            <returns>True when the application was started and a connection established, false otherwise</returns>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.OutOfProcessQueue.DoHandleFailure(SharpRemote.Hosting.OutOfProcess.OutOfProcessQueue.Operation)">
            <summary>
                Handles the given failure.
            </summary>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.OutOfProcessQueue.ResolveFailure(SharpRemote.Hosting.OutOfProcess.Failure,SharpRemote.Hosting.OutOfProcess.Decision)">
            <summary>
                Actually tries to resolve the failure (if possible).
            </summary>
            <param name="failure"></param>
            <param name="decision"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.Hosting.OutOfProcess.RestartOnFailureStrategy">
            <summary>
            A <see cref="T:SharpRemote.Hosting.OutOfProcess.IFailureHandler"/> implementation that simply restarts the host process when failures occur.
            Both failures during start as well as failures during normal operation are expected, and if they happen, they
            are resolved by restarting the host process.
            </summary>
            <remarks>
            Tolerates a maximum of 10 successive Start() failures before giving up, unless the host process reported
            a <see cref="T:System.IO.FileNotFoundException"/> in which case it gives up immediately.
            </remarks>
            <remarks>
            Tolerates an unlimited amount of failures during normal operations and simply restarts the host process if one occurs.
            </remarks>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.RestartOnFailureStrategy.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="startFailureThreshold">The maximum amount of times the host process may fail starting until it is assumed to be broken and no more restart is tried</param>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.RestartOnFailureStrategy.OnStartFailure(System.Int32,System.Exception,System.TimeSpan@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.RestartOnFailureStrategy.OnFailure(SharpRemote.Hosting.OutOfProcess.Failure)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.RestartOnFailureStrategy.OnResolutionFailed(SharpRemote.Hosting.OutOfProcess.Failure,SharpRemote.Hosting.OutOfProcess.Decision,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.RestartOnFailureStrategy.OnResolutionFinished(SharpRemote.Hosting.OutOfProcess.Failure,SharpRemote.Hosting.OutOfProcess.Decision,SharpRemote.Hosting.OutOfProcess.Resolution)">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.Hosting.OutOfProcess.FailureSettings">
            <summary>
            Used to configure how (or if at all) an <see cref="T:SharpRemote.Hosting.OutOfProcessSilo"/> assumes that an error occured.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.FailureSettings.ProcessReadyTimeout">
            <summary>
            The maximum amount of time that may pass between starting the host process and it
            signalling to be ready to accept incoming connections. After this time has passed
            the host process is assumed to have faulted and is killed. A <see cref="T:SharpRemote.Hosting.OutOfProcess.IFailureHandler"/>
            can then control when, or if at all, the host process is started again.
            </summary>
            <remarks>
            Is set to 10 seconds by default.
            </remarks>
            <remarks>
            If your (custom) application requires a lot of startup time then you can change this setting to a higher
            value to tolerate this.
            </remarks>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.FailureSettings.EndPointConnectTimeout">
            <summary>
            The maximum amount of time that may pass until the <see cref="T:SharpRemote.Hosting.OutOfProcessSilo"/>
            establishes a connection with the host process before the process is assumed to have failed
            and is killed.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.FailureSettings.HeartbeatSettings">
            <summary>
            The settings specifying how (or if at all) the heartbeat mechanism is employed
            to detect (assumed) failures in the host process.
            </summary>
            <remarks>
            By default a heartbeat mechanism is employed - if the host process doesn't respond
            within 10 seconds then it's assumed to have failed and is killed. A <see cref="T:SharpRemote.Hosting.OutOfProcess.IFailureHandler"/>
            is invoked to determine what happens next.
            </remarks>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.FailureSettings.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpRemote.Hosting.OutOfProcess.IFailureHandler">
            <summary>
            This interface can be used to control how, if and when failures of the host process or its connection
            to this one is handled.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.IFailureHandler.OnStartFailure(System.Int32,System.Exception,System.TimeSpan@)">
            <summary>
            This method is called when the host process failed to start, did not report to be ready or no connection
            could be established with the host process.
            </summary>
            <param name="numSuccessiveFailures">The amount of previous successive failures to start the host process</param>
            <param name="hostProcessException">The exception caught and reported by the host process during startup - or null if the failure occured due to a timeout / connection problem</param>
            <param name="waitTime">The amount of time the <see cref="T:SharpRemote.Hosting.OutOfProcessSilo"/> shall wait before attempting to start the host process again</param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.IFailureHandler.OnFailure(SharpRemote.Hosting.OutOfProcess.Failure)">
            <summary>
            This method is called when a failure in the host process or between the connection occured.
            </summary>
            <param name="failure">The type of failure that occurred</param>
            <returns>How the failure shall be resolved, or null if the <see cref="T:SharpRemote.Hosting.OutOfProcessSilo"/> shall decide</returns>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.IFailureHandler.OnResolutionFailed(SharpRemote.Hosting.OutOfProcess.Failure,SharpRemote.Hosting.OutOfProcess.Decision,System.Exception)">
            <summary>
            This method is called when resolving the failure by restarting the host didn't work and <see cref="T:SharpRemote.Hosting.OutOfProcessSilo"/>
            had to give up.
            </summary>
            <remarks>
            This method is called before <see cref="M:SharpRemote.Hosting.OutOfProcess.IFailureHandler.OnResolutionFinished(SharpRemote.Hosting.OutOfProcess.Failure,SharpRemote.Hosting.OutOfProcess.Decision,SharpRemote.Hosting.OutOfProcess.Resolution)"/>.
            </remarks>
            <param name="failure"></param>
            <param name="decision"></param>
            <param name="exception"></param>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.IFailureHandler.OnResolutionFinished(SharpRemote.Hosting.OutOfProcess.Failure,SharpRemote.Hosting.OutOfProcess.Decision,SharpRemote.Hosting.OutOfProcess.Resolution)">
            <summary>
            This method is called when the <see cref="T:SharpRemote.Hosting.OutOfProcessSilo"/> is finished with the failure resolution.
            This can indicate that the failure could be successfully resolved OR NOT, check the <paramref name="resolution"/>
            parameter to find out what happened.
            </summary>
            <param name="failure"></param>
            <param name="decision"></param>
            <param name="resolution"></param>
        </member>
        <member name="T:SharpRemote.Hosting.OutOfProcess.ZeroFailureToleranceStrategy">
            <summary>
            A <see cref="T:SharpRemote.Hosting.OutOfProcess.IFailureHandler"/> implementation that doesn't tolerate any kind of failure and
            immediately stops the <see cref="T:SharpRemote.Hosting.OutOfProcessSilo"/>.
            </summary>
        </member>
        <member name="E:SharpRemote.Hosting.OutOfProcess.ZeroFailureToleranceStrategy.OnResolutionFailedEvent">
            <summary>
            This event is fired when <see cref="M:SharpRemote.Hosting.OutOfProcess.ZeroFailureToleranceStrategy.OnResolutionFailed(SharpRemote.Hosting.OutOfProcess.Failure,SharpRemote.Hosting.OutOfProcess.Decision,System.Exception)"/> is called.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.ZeroFailureToleranceStrategy.OnStartFailure(System.Int32,System.Exception,System.TimeSpan@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.ZeroFailureToleranceStrategy.OnFailure(SharpRemote.Hosting.OutOfProcess.Failure)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.ZeroFailureToleranceStrategy.OnResolutionFailed(SharpRemote.Hosting.OutOfProcess.Failure,SharpRemote.Hosting.OutOfProcess.Decision,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcess.ZeroFailureToleranceStrategy.OnResolutionFinished(SharpRemote.Hosting.OutOfProcess.Failure,SharpRemote.Hosting.OutOfProcess.Decision,SharpRemote.Hosting.OutOfProcess.Resolution)">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.Hosting.OutOfProcess.Failure">
            <summary>
            Describes the various reasons why the out of process silo faulted.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.Failure.HeartbeatFailure">
            <summary>
            The configured amount of heartbeats were unanswered and thus the heartbeat monitor
            deemed the silo to have faulted.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.Failure.ConnectionFailure">
            <summary>
            The connection between both endpoints failed unexpectedly.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.Failure.UnhandledException">
            <summary>
            The connection between both endpoints has been closed due to an unexpected exception
            on this endpoint.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.Failure.ConnectionClosed">
            <summary>
            The connection between both endpoints was closed intentionally.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.Failure.HostProcessExited">
            <summary>
            The host process has exited for an unknown reason.
            One possible reason is that it crashed due to an unhandled exception.
            Another reason is that it might have been killed (either by a person or another program).
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.Failure.Unknown">
            <summary>
            An unknown failure occured.
            </summary>
        </member>
        <member name="T:SharpRemote.Hosting.OutOfProcess.Resolution">
            <summary>
            Describes the various states of how (and if) a failure has been resolved.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.Resolution.Resolved">
            <summary>
            The problem has been resolved but failed calls on remote objects may or may not have been
            completely executed.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.Resolution.Restarted">
            <summary>
            The problem could not be resolved, but the host process was restarted and is now in its
            initial state.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcess.Resolution.Stopped">
            <summary>
            The problem could not be resolved and restarting the host process failed or was not allowed.
            The silo can no longer be used.
            </summary>
        </member>
        <member name="T:SharpRemote.Hosting.CRuntimeVersions">
            <summary>
            Defines the list of all supported C-Runtime versions that are supported.
            Runtime failures can only be handled for supported versions.
            The list of failures that are handled are:
            - assert() failures - dialog can be suppressed, a minidump can be created
            - abort() calls - dialog can be suppressed, a minidump can be created
            - pure virtual function calls
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions.None">
            <summary>
            No CRT version should be supported - the default.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions._71">
            <summary>
            CRT version 7.1 (Visual Studio 2003) should be supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions._80">
            <summary>
            CRT version 8.0 (Visual Studio 2005) should be supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions._90">
            <summary>
            CRT version 9.0 (Visual Studio 2008) should be supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions._100">
            <summary>
            CRT version 10.0 (Visual Studio 2010) should be supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions._110">
            <summary>
            CRT version 11.0 (Visual Studio 2012) should be supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions._120">
            <summary>
            CRT version 12.0 (Visual Studio 2013) should be supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions._140">
            <summary>
            CRT version 14.0 (Visual Studio 2015) should be supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions._141">
            <summary>
            CRT version 14.1 (Visual Studio 2017) should be supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions.Debug">
            <summary>
            Debug version(s) of the CRT should be supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions.Release">
            <summary>
            Release version(s) of the CRT should be supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions.AllDebug">
            <summary>
            All possible debug CRT versions should be supported.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.CRuntimeVersions.AllRelease">
            <summary>
            All possible release CRT versions should be supported.
            </summary>
        </member>
        <member name="T:SharpRemote.Hosting.OutOfProcessSiloServer">
            <summary>
                Used in conjunction with a <see cref="T:SharpRemote.Hosting.OutOfProcessSilo" /> to host objects in a remote process.
            </summary>
            <example>
                public static void main(string[] arguments)
                {
                   try
                   {
                      // Put any additional/required initialization here.
                      using (var silo = new OutOfProcessSiloServer(arguments))
                      {
                         // This is the place to register any additional interfaces with this silo
                         // silo.CreateServant(id, (IMyCustomInterface)new MyCustomImplementation());
                         silo.Run();
                      }
                   }
                   catch(Exception e)
                   {
                      // This will marshall the exception back to the parent process so you can
                      // actually know and programmatically react to the failure.
                      OutOfProcessSiloServer.ReportException(e);
                   }
                }
            </example>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.#ctor(System.String[],SharpRemote.ITypeResolver,SharpRemote.CodeGeneration.ICodeGenerator,SharpRemote.HeartbeatSettings,SharpRemote.LatencySettings,SharpRemote.EndPointSettings,System.String)">
            <summary>
                Initializes a new silo server.
            </summary>
            <param name="args">The command line arguments given to the Main() method</param>
            <param name="customTypeResolver">The type resolver, if any, responsible for resolving Type objects by their assembly qualified name</param>
            <param name="codeGenerator">The code generator to create proxy and servant types</param>
            <param name="heartbeatSettings">The settings for heartbeat mechanism, if none are specified, then default settings are used</param>
            <param name="latencySettings">The settings for latency measurements, if none are specified, then default settings are used</param>
            <param name="endPointSettings">The settings for the endpoint itself (max. number of concurrent calls, etc...)</param>
            <param name="endPointName">The name of this silo, used for debugging (and logging)</param>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.ParentProcessId">
            <summary>
                The process id of the parent process, as specified in the command line arguments or null
                when no id was specified.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.Dispose">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.Name">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.IsConnected">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.NumProxiesCollected">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.NumServantsCollected">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.NumBytesSent">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.NumBytesReceived">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.NumMessagesSent">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.NumMessagesReceived">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.NumCallsInvoked">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.NumCallsAnswered">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.NumPendingMethodCalls">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.NumPendingMethodInvocations">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.AverageRoundTripTime">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.TotalGarbageCollectionTime">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.EndPointSettings">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.LatencySettings">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.HeartbeatSettings">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.CurrentConnectionId">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.LocalEndPoint">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.RemoteEndPoint">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSiloServer.Proxies">
            <inheritdoc />
        </member>
        <member name="E:SharpRemote.Hosting.OutOfProcessSiloServer.OnConnected">
            <summary>
            
            </summary>
        </member>
        <member name="E:SharpRemote.Hosting.OutOfProcessSiloServer.OnDisconnected">
            <summary>
            
            </summary>
        </member>
        <member name="E:SharpRemote.Hosting.OutOfProcessSiloServer.OnFailure">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.Disconnect">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.CreateProxy``1(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.GetProxy``1(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.CreateServant``1(System.UInt64,``0)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.RetrieveSubject``1(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.GetExistingOrCreateNewProxy``1(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.GetExistingOrCreateNewServant``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.RegisterDefaultImplementation``2">
            <summary>
                Registers a default implementation for the given interface so that
                <see cref="M:SharpRemote.Hosting.ISilo.CreateGrain``1(System.Object[])" /> can be used to create grains.
            </summary>
            <typeparam name="TInterface"></typeparam>
            <typeparam name="TImplementation"></typeparam>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.Run">
            <summary>
                Runs the server and blocks until a shutdown command is received because the
                <see cref="T:SharpRemote.Hosting.OutOfProcessSilo" /> is being disposed of or because the parent process
                quits unexpectedly.
            </summary>
            <remarks>
            Binds the endpoint to <see cref="F:System.Net.IPAddress.Any"/>.
            </remarks>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.Run(System.Net.IPAddress)">
            <summary>
                Runs the server and blocks until a shutdown command is received because the
                <see cref="T:SharpRemote.Hosting.OutOfProcessSilo" /> is being disposed of or because the parent process
                quits unexpectedly.
            </summary>
            <param name="address">The ip-address this endpoint shall bind itself to</param>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.Run(System.Net.IPAddress,System.UInt16,System.UInt16)">
            <summary>
                Runs the server and blocks until a shutdown command is received because the
                <see cref="T:SharpRemote.Hosting.OutOfProcessSilo" /> is being disposed of or because the parent process
                quits unexpectedly.
            </summary>
            <param name="address">The ip-address this endpoint shall bind itself to</param>
            <param name="minPort">The minimum port number to which this endpoint may be bound to</param>
            <param name="maxPort">The maximum port number to which this endpoint may be bound to</param>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSiloServer.ReportException(System.Exception)">
            <summary>
            Shall be called by user code when an exception occurred during startup of the server
            and shall be reported back to the <see cref="T:SharpRemote.Hosting.OutOfProcessSilo"/>.
            </summary>
            <param name="exception"></param>
        </member>
        <member name="T:SharpRemote.Hosting.ProcessFailureReason">
            <summary>
            Describes the various reasons why a process faulted.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.ProcessFailureReason.UnhandledException">
            <summary>
            The connection between both endpoints has been closed due to an unexpected exception
            on this <see cref="T:SharpRemote.Hosting.ProcessWatchdog"/>.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.ProcessFailureReason.HostProcessExitedUnexpectedly">
            <summary>
            The host process has exited.
            </summary>
        </member>
        <member name="T:SharpRemote.Hosting.ProcessWatchdog">
            <summary>
                Responsible for starting and monitoring another process.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.ProcessWatchdog.#ctor(System.String,SharpRemote.Hosting.ProcessOptions,System.Nullable{System.TimeSpan})">
            <summary>
                Initializes a new instance of this ProcessWatchdog with the specified options.
                The given host process will only be started once <see cref="M:SharpRemote.Hosting.ProcessWatchdog.Start" /> is called.
            </summary>
            <param name="executable"></param>
            <param name="options"></param>
            <param name="processReadyTimeout">The amount of time the host process has to report being ready before it is assumed to be dead</param>
            <exception cref="T:System.ArgumentNullException">
                When <paramref name="executable" /> is null
            </exception>
            <exception cref="T:System.ArgumentException">
                When <paramref name="executable" /> is contains only whitespace
            </exception>
        </member>
        <member name="M:SharpRemote.Hosting.ProcessWatchdog.Start">
            <summary>
                Starts the child process.
            </summary>
            <exception cref="T:System.IO.FileNotFoundException">When the specified executable could not be found</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">When the </exception>
            <exception cref="T:SharpRemote.HandshakeException">
                The handshake between this and the <see cref="T:SharpRemote.Hosting.OutOfProcessSiloServer" /> of the remote process failed
            </exception>
        </member>
        <member name="M:SharpRemote.Hosting.ProcessWatchdog.Start(System.Int32@)">
            <summary>
                Starts the child process.
            </summary>
            <exception cref="T:System.IO.FileNotFoundException">When the specified executable could not be found</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">When the </exception>
            <exception cref="T:SharpRemote.HandshakeException">
                The handshake between this and the <see cref="T:SharpRemote.Hosting.OutOfProcessSiloServer" /> of the remote process failed
            </exception>
        </member>
        <member name="M:SharpRemote.Hosting.ProcessWatchdog.TryKill">
            <summary>
            Tries to kill the hosted process.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.ProcessWatchdog.Dispose">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.Hosting.ProcessWatchdog.RemotePort">
            <summary>
            The port used by the hosted process.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.ProcessWatchdog.HostedProcessState">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.ProcessWatchdog.IsProcessRunning">
            <summary>
            </summary>
            <remarks>
                This property is set to true once <see cref="M:SharpRemote.Hosting.ProcessWatchdog.Start"/> is called.
            </remarks>
        </member>
        <member name="P:SharpRemote.Hosting.ProcessWatchdog.HasProcessFailed">
            <summary>
                Whether or not the process has failed.
            </summary>
            <remarks>
                False means that the process is either running or has exited on purpose.
            </remarks>
            <remarks>
                This property is set to false once <see cref="M:SharpRemote.Hosting.ProcessWatchdog.Start"/> is called.
            </remarks>
        </member>
        <member name="P:SharpRemote.Hosting.ProcessWatchdog.IsDisposed">
            <summary>
            Whether or not this watchdog has been disposed of.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.ProcessWatchdog.HostedProcessId">
            <summary>
                The process-id of the host process, or null, if it's not running.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.ProcessWatchdog.HostExecutableName">
            <summary>
            The filename of the executable, as given in the constructor.
            </summary>
        </member>
        <member name="E:SharpRemote.Hosting.ProcessWatchdog.OnHostOutputWritten">
            <summary>
                This event is invoked whenever the host has written a complete line to its console.
            </summary>
        </member>
        <member name="E:SharpRemote.Hosting.ProcessWatchdog.OnFaultDetected">
            <summary>
                Is invoked when a failure in the remote process has been detected and is invoked prior to handling
                this failure.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.ProcessWatchdog.ProcessFailureReason">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpRemote.Hosting.HostState">
            <summary>
                Defines the various states of the host process.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.HostState.None">
            <summary>
                Default state, should not appear in the wild.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.HostState.BootPending">
            <summary>
                The host will boot in the near future.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.HostState.Booting">
            <summary>
                The host is booting up, but hasn't finished yet.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.HostState.Ready">
            <summary>
                The host has booted up and is ready to be used.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.HostState.ShuttingDown">
            <summary>
                The host is shutting down.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.HostState.Dead">
            <summary>
                The host process is no longer running.
            </summary>
        </member>
        <member name="T:SharpRemote.Hosting.ProcessOptions">
            <summary>
            Defines whether or not a console window for the host process should be shown, or not.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.ProcessOptions.ShowConsole">
            <summary>
            A console shall be shown.
            </summary>
        </member>
        <member name="F:SharpRemote.Hosting.ProcessOptions.HideConsole">
            <summary>
            No console shall be shown - the host process is invisible to a user (besides
            inspection of the process list).
            </summary>
        </member>
        <member name="T:SharpRemote.Hosting.InProcessRemotingSilo">
            <summary>
            Silo implementation not meant for production code as it uses the entire remoting chain without an actual need for it.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.InProcessRemotingSilo.#ctor(SharpRemote.ITypeResolver)">
            <summary>
            Initializes a new silo that hosts all objects in the same process it is used in, but with
            proxy and servant implementations in between.
            Is only really useful for debugging remoting.
            </summary>
            <param name="customTypeResolver">The type resolver, if any, that is used to resolve types by their assembly qualified name</param>
        </member>
        <member name="P:SharpRemote.Hosting.InProcessRemotingSilo.IsDisposed">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessRemotingSilo.RegisterDefaultImplementation``2">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessRemotingSilo.CreateGrain``1(System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessRemotingSilo.CreateGrain``1(System.String,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessRemotingSilo.CreateGrain``1(System.Type,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessRemotingSilo.CreateGrain``2(System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessRemotingSilo.Dispose">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.Hosting.InProcessSilo">
            <summary>
                Hosts all objects in the calling process without any remoting overhead.
                The object returned is the object being created - not some proxy.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.InProcessSilo.#ctor(SharpRemote.ITypeResolver)">
            <summary>
                Initializes a new silo that hosts objects in the very same process it is used from.
            </summary>
            <param name="customTypeResolver">The type resolver, if any, that is used to resolve types by their assembly qualified name</param>
        </member>
        <member name="P:SharpRemote.Hosting.InProcessSilo.IsDisposed">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessSilo.RegisterDefaultImplementation``2">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessSilo.RegisterDefaultImplementation``1(System.String)">
            <summary>
            Registers the default implementation for the given interface <paramref name="implementationTypeName"/>
            so that <see cref="M:SharpRemote.Hosting.InProcessSilo.CreateGrain``1(System.Object[])"/> can be used.
            </summary>
            <typeparam name="TInterface"></typeparam>
        </member>
        <member name="M:SharpRemote.Hosting.InProcessSilo.CreateGrain``1(System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessSilo.CreateGrain``1(System.String,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessSilo.CreateGrain``1(System.Type,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessSilo.CreateGrain``2(System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.InProcessSilo.Dispose">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.Hosting.ISilo">
            <summary>
            Responsible for creating and providing grains.
            It's sole purpose is to hide away the location of an object.
            An object can be located in any of the following (relative to the caller):
            - The same AppDomain
            - A different AppDomain
            - A different Process
            - A different Machine
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.ISilo.IsDisposed">
            <summary>
            Whether or not this silo has been disposed of.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.ISilo.RegisterDefaultImplementation``2">
            <summary>
            Registers the default implementation for the given interface <typeparamref name="TInterface"/>
            so that <see cref="M:SharpRemote.Hosting.ISilo.CreateGrain``1(System.Object[])"/> can be used.
            </summary>
            <typeparam name="TInterface"></typeparam>
            <typeparam name="TImplementation"></typeparam>
        </member>
        <member name="M:SharpRemote.Hosting.ISilo.CreateGrain``1(System.Object[])">
            <summary>
            Creates a new object that implements the given interface.
            The type of the implementation is defined via <see cref="M:SharpRemote.Hosting.ISilo.RegisterDefaultImplementation``2"/>
            or via <see cref="M:SharpRemote.Hosting.OutOfProcessSiloServer.RegisterDefaultImplementation``2"/>.
            </summary>
            <typeparam name="TInterface"></typeparam>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.Hosting.ISilo.CreateGrain``1(System.String,System.Object[])">
            <summary>
            Creates a new instance of the given type and returns an interface to it.
            </summary>
            <typeparam name="TInterface"></typeparam>
            <param name="assemblyQualifiedTypeName">The fully qualified typename of the type to instantiate</param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.Hosting.ISilo.CreateGrain``1(System.Type,System.Object[])">
            <summary>
            Creates a new instance of the given type and returns an interface to it.
            </summary>
            <typeparam name="TInterface"></typeparam>
            <param name="implementation">The type to instantiate</param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.Hosting.ISilo.CreateGrain``2(System.Object[])">
            <summary>
            Creates a new instance of the given type and returns an interface to it.
            </summary>
            <typeparam name="TInterface"></typeparam>
            <typeparam name="TImplementation">The type to instantiate</typeparam>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.Hosting.ISubjectHost">
            <summary>
            Responsible for creating and hosting objects.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.ISubjectHost.CreateSubject1(System.UInt64,System.Type,System.Type)">
            <summary>
            
            </summary>
            <param name="objectId"></param>
            <param name="type"></param>
            <param name="interfaceType"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.Hosting.ISubjectHost.CreateSubject2(System.UInt64,System.String,System.Type)">
            <summary>
            
            </summary>
            <param name="objectId"></param>
            <param name="assemblyQualifiedTypeName"></param>
            <param name="interfaceType"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.Hosting.ISubjectHost.CreateSubject3(System.UInt64,System.Type)">
            <summary>
            
            </summary>
            <param name="objectId"></param>
            <param name="interfaceType"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.Hosting.ISubjectHost.RegisterDefaultImplementation(System.Type,System.Type)">
            <summary>
            
            </summary>
            <param name="implementation"></param>
            <param name="interfaceType"></param>
        </member>
        <member name="T:SharpRemote.Hosting.OutOfProcessSilo">
            <summary>
                <see cref="T:SharpRemote.Hosting.ISilo" /> implementation that allows client code to host objects in another
                process via <see cref="T:SharpRemote.Hosting.OutOfProcessSiloServer" />.
            </summary>
            <remarks>
                Can be used to host objects either in the SharpRemote.Host.exe or in a custom application
                of your choice by creating a <see cref="T:SharpRemote.Hosting.OutOfProcessSiloServer" /> and calling
                <see cref="M:SharpRemote.Hosting.OutOfProcessSiloServer.Run" />.
            </remarks>
            <example>
                using (var silo = new OutOfProcessSilo())
                {
                var grain = silo.CreateGrain{IMyInterestingInterface}(typeof(MyRemoteType));
                grain.DoSomethingInteresting();
                }
            </example>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSilo.#ctor(System.String,SharpRemote.Hosting.ProcessOptions,SharpRemote.CodeGeneration.ICodeGenerator,SharpRemote.LatencySettings,SharpRemote.EndPointSettings,SharpRemote.Hosting.OutOfProcess.FailureSettings,SharpRemote.Hosting.OutOfProcess.IFailureHandler,System.String)">
            <summary>
                Initializes a new instance of this silo with the specified options.
                The given host process will only be started once <see cref="M:SharpRemote.Hosting.OutOfProcessSilo.Start" /> is called.
            </summary>
            <param name="process"></param>
            <param name="options"></param>
            <param name="codeGenerator">The code generator to create proxy and servant types</param>
            <param name="latencySettings">
                The settings for latency measurements, if none are specified, then default settings are
                used
            </param>
            <param name="endPointSettings">The settings for the endpoint itself (max. number of concurrent calls, etc...)</param>
            <param name="failureSettings">
                The settings specifying when a failure is assumed to have occured in the host process -
                if none are specified, then defaults are used
            </param>
            <param name="failureHandler">
                The object responsible for deciding how failures are dealt with - if none is specified
                then a new <see cref="T:SharpRemote.Hosting.OutOfProcess.ZeroFailureToleranceStrategy" /> is used
            </param>
            <param name="endPointName">The name of the endpoint - used in log messages to differentiate between different endpoints</param>
            <exception cref="T:System.ArgumentNullException">When <paramref name="process" /> is null</exception>
            <exception cref="T:System.ArgumentException">When <paramref name="process" /> is contains only whitespace</exception>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.HasProcessFailed">
            <summary>
                Whether or not the process has failed.
            </summary>
            <remarks>
                False means that the process is either running or has exited on purpose.
            </remarks>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.RoundtripTime">
            <summary>
                The current average round trip time or <see cref="F:System.TimeSpan.Zero" /> in
                case nothing was measured.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.HostState">
            <summary>
                Returns a more precise state (than <see cref="P:SharpRemote.Hosting.OutOfProcessSilo.IsProcessRunning" />) the process managed by this silo
                is currently in.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.IsProcessRunning">
            <summary>
                Returns true if the process managed by this silo is currently running, false otherwise.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.IsConnected">
            <summary>
                Returns true if the process managed by this silo is currently running and the connection to it is healthy,
                false otherwise.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.HostProcessId">
            <summary>
                The process-id of the host process, or null, if it's not running.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.GarbageCollectionTime">
            <summary>
                The total amount of time this endpoint spent collecting garbage.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.IsDisposed">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSilo.RegisterDefaultImplementation``2">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSilo.CreateGrain``1(System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSilo.CreateGrain``1(System.String,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSilo.CreateGrain``1(System.Type,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSilo.CreateGrain``2(System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSilo.Dispose">
            <inheritdoc />
        </member>
        <member name="E:SharpRemote.Hosting.OutOfProcessSilo.OnHostOutputWritten">
            <summary>
                This event is invoked whenever the host has written a complete line to its console.
            </summary>
        </member>
        <member name="E:SharpRemote.Hosting.OutOfProcessSilo.OnHostStarted">
            <summary>
                This event is invoked whenever the host process was successfully started, and a connection
                to it was established.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSilo.Start">
            <summary>
                Starts this silo.
            </summary>
            <exception cref="T:System.IO.FileNotFoundException">When the specified executable could not be found</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">When the </exception>
            <exception cref="T:SharpRemote.HandshakeException">
                The handshake between this and the <see cref="T:SharpRemote.Hosting.OutOfProcessSiloServer" /> of the
                remote process failed
            </exception>
            <exception cref="T:SharpRemote.SharpRemoteException"></exception>
            <exception cref="T:System.AggregateException">
                The application was started multiple times, but failed to be started and connect
                every single time - examine <see cref="P:System.AggregateException.InnerExceptions" /> property
            </exception>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSilo.Stop">
            <summary>
               Stops this silo.
            </summary>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSilo.CreateProxy``1(System.UInt64)">
            <summary>
                Creates and registers an object that implements the given interface <typeparamref name="T" />.
                Calls to properties / methods of the given interface are marshalled to connected endpoint, if an appropriate
                servant of the same interface an <paramref name="objectId" /> has been created using
                <see cref="M:SharpRemote.Hosting.OutOfProcessSilo.CreateServant``1(System.UInt64,``0)" />.
            </summary>
            <remarks>
                A proxy can be created independent from its servant and the order in which both are created is unimportant, for as
                long
                as no interface methods / properties are invoked.
            </remarks>
            <remarks>
                Every method / property on the given object is now capable of throwing an additional set of exceptions, in addition
                to whatever exceptions any implementation already throws:
                - <see cref="T:SharpRemote.NoSuchServantException" />: There's no servant with the id of the proxy and therefore no subject on
                which the method could possibly be executed
                - <see cref="T:SharpRemote.NotConnectedException" />: At the time of calling the proxy's method, no connection to a remote end
                point was available
                - <see cref="T:SharpRemote.ConnectionLostException" />: The method call was canceled because the connection between proxy and
                servant was interrupted / lost / disconnected
                - <see cref="T:SharpRemote.UnserializableException" />: The remote method was executed, threw an exception, but the exception
                could not be serialized
            </remarks>
            <remarks>
                This method is thread-safe.
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="objectId"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When there already exists a proxy of id <paramref name="objectId" />.
            </exception>
            <exception cref="T:System.ArgumentException">
                When <typeparamref name="T" /> does not refer to an interface.
            </exception>
        </member>
        <member name="M:SharpRemote.Hosting.OutOfProcessSilo.CreateServant``1(System.UInt64,``0)">
            <summary>
                Creates and registers an object for the given subject <paramref name="subject" /> and invokes its methods, when
                they
                have been called on the corresponding proxy.
            </summary>
            <remarks>
                A servant can be created independent from any proxy and the order in which both are created is unimportant, for as
                long
                as no interface methods / properties are invoked.
            </remarks>
            <remarks>
                This method is thread-safe.
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="objectId"></param>
            <param name="subject"></param>
            <returns></returns>
        </member>
        <member name="F:SharpRemote.Hosting.OutOfProcessSilo.Constants.SubjectHostId">
            <summary>
                The id of the grain that is used to instantiate further subjects.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.NumBytesSent">
            <summary>
                The total amount of bytes that have been sent over the underlying socket endpoint.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.NumBytesReceived">
            <summary>
                The total amount of bytes that have been received over the underlying endpoint.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.NumCallsInvoked">
            <summary>
                The total amount of remote procedure calls that have been invoked from this end.
            </summary>
        </member>
        <member name="P:SharpRemote.Hosting.OutOfProcessSilo.NumCallsAnswered">
            <summary>
                The total amount of remote procedure calls that have been invoked from the other end.
            </summary>
        </member>
        <member name="T:SharpRemote.Hosting.SubjectHost">
            <summary>
            <see cref="T:SharpRemote.Hosting.ISubjectHost"/> implementation that uses an <see cref="T:System.Activator"/> to
            create object instances.
            </summary>
        </member>
        <member name="T:SharpRemote.IEnumValueDescription">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.IEnumValueDescription.Name">
            <summary>
                The name of the enum value.
            </summary>
        </member>
        <member name="P:SharpRemote.IEnumValueDescription.Value">
            <summary>
                The actual enum value.
            </summary>
        </member>
        <member name="P:SharpRemote.IEnumValueDescription.NumericValue">
            <summary>
                The numeric value of the enum value.
                Might be false in case the enum's storage type is <see cref="T:System.UInt64" />.
            </summary>
        </member>
        <member name="T:SharpRemote.IFieldDescription">
            <summary>
                Similar to <see cref="T:System.Reflection.FieldInfo" /> (in that it describes a particular .NET field), but only
                describes its static structure that is important to a <see cref="T:SharpRemote.ISerializer" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IFieldDescription.Field">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.IFieldDescription.FieldType">
            <summary>
                The type of this field, equivalent of <see cref="P:System.Reflection.FieldInfo.FieldType" />.
            </summary>
        </member>
        <member name="T:SharpRemote.IMemberDescription">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.IMemberDescription.Name">
            <summary>
                The equivalent of <see cref="P:System.Reflection.MemberInfo.Name" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IMemberDescription.TypeDescription">
            <summary>
                The type of this field/property.
            </summary>
        </member>
        <member name="P:SharpRemote.IMemberDescription.MemberInfo">
            <summary>
            </summary>
        </member>
        <member name="T:SharpRemote.IMethodDescription">
            <summary>
                Similar to <see cref="T:System.Reflection.MethodInfo" /> (in that it describes a particular .NET method), but only
                describes its static structure that is important to a <see cref="T:SharpRemote.ISerializer" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IMethodDescription.Method">
            <summary>
                The method being described.
            </summary>
        </member>
        <member name="P:SharpRemote.IMethodDescription.Name">
            <summary>
                The equivalent of <see cref="P:System.Reflection.MemberInfo.Name" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IMethodDescription.SpecialMethod">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.IMethodDescription.IsAsync">
            <summary>
                True when the method returns a <see cref="T:System.Threading.Tasks.Task" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IMethodDescription.ReturnParameter">
            <summary>
                The equivalent of <see cref="P:System.Reflection.MethodInfo.ReturnParameter" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IMethodDescription.ReturnType">
            <summary>
                The equivalent of <see cref="P:System.Reflection.MethodInfo.ReturnType" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IMethodDescription.Parameters">
            <summary>
                The equivalent of <see cref="M:System.Reflection.MethodBase.GetParameters" />.
            </summary>
        </member>
        <member name="T:SharpRemote.IncompatibleMethodSignature">
            <summary>
            The signature of a method is incompatible because of any combination of the following:
            - The return type has been changed (i.e. int => long)
            - The number of parameters is different (i.e. (int, string) to (int, string, byte))
            - A parameter type has changed (i.e. int => uint)
            </summary>
        </member>
        <member name="T:SharpRemote.IParameterDescription">
            <summary>
                Similar to <see cref="T:System.Reflection.ParameterInfo" /> (in that it describes a particular .NET method), but only
                describes its static structure that is important to a <see cref="T:SharpRemote.ISerializer" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IParameterDescription.Name">
            <summary>
                The equivalent of <see cref="P:System.Reflection.ParameterInfo.Name" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IParameterDescription.IsIn">
            <summary>
                Gets a value indicating whether this is an input parameter.
                The equivalent of <see cref="P:System.Reflection.ParameterInfo.IsIn" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IParameterDescription.IsOut">
            <summary>
                Gets a value indicating whether this is an output parameter.
                The equivalent of <see cref="P:System.Reflection.ParameterInfo.IsOut" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IParameterDescription.IsRetval">
            <summary>
                Gets a value indicating whether this is a Retval parameter.
                The equivalent of <see cref="P:System.Reflection.ParameterInfo.IsRetval" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IParameterDescription.Position">
            <summary>
                Gets the zero-based position of the parameter in the formal parameter list.
                The equivalent of <see cref="P:System.Reflection.ParameterInfo.Position" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IParameterDescription.ParameterType">
            <summary>
                The equivalent of <see cref="P:System.Reflection.ParameterInfo.ParameterType" />.
            </summary>
        </member>
        <member name="T:SharpRemote.IPropertyDescription">
            <summary>
                Similar to <see cref="T:System.Reflection.PropertyInfo" /> (in that it describes a particular .NET property), but only
                describes its static structure that is important to a <see cref="T:SharpRemote.ISerializer" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IPropertyDescription.PropertyType">
            <summary>
                The type of this property, equivalent of <see cref="P:System.Reflection.PropertyInfo.PropertyType" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IPropertyDescription.GetMethod">
            <summary>
                The method through which the value of this property can be accessed.
                Equivalent of <see cref="P:System.Reflection.PropertyInfo.GetMethod" />.
            </summary>
        </member>
        <member name="P:SharpRemote.IPropertyDescription.SetMethod">
            <summary>
                The method through which the value of this property can be changed.
                Equivalent of <see cref="P:System.Reflection.PropertyInfo.SetMethod" />.
            </summary>
        </member>
        <member name="T:SharpRemote.ITypeDescription">
            <summary>
                Similar to <see cref="P:SharpRemote.ITypeDescription.Type" /> (in that it describes a particular .NET type), but only
                describes its static structure that is important to a <see cref="T:SharpRemote.ISerializer" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.Type">
            <summary>
            The type being described by this object.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.BaseType">
            <summary>
                Equivalent of <see cref="P:System.Type.BaseType" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.ByReferenceInterfaceType">
            <summary>
            The type being described by this object.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.StorageType">
            <summary>
                The underlying type used for storing values.
            </summary>
            <remarks>
                Relevant for enums.
            </remarks>
        </member>
        <member name="P:SharpRemote.ITypeDescription.AssemblyQualifiedName">
            <summary>
                Equivalent of <see cref="P:System.Type.AssemblyQualifiedName" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.SerializationType">
            <summary>
                A classification of this type which is helpful for the serializer.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.IsClass">
            <summary>
                Equivalent of <see cref="P:System.Type.IsClass" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.IsEnum">
            <summary>
                Equivalent of <see cref="P:System.Type.IsEnum" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.IsEnumerable">
            <summary>
                True when this type implements <see cref="T:System.Collections.IEnumerable"/>.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.IsInterface">
            <summary>
                Equivalent of <see cref="P:System.Type.IsInterface" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.IsValueType">
            <summary>
                Equivalent of <see cref="P:System.Type.IsValueType" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.IsSealed">
            <summary>
                Equivalent of <see cref="P:System.Type.IsSealed" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.IsBuiltIn">
            <summary>
                The type doesn't strictly adhere to the rules of its <see cref="P:SharpRemote.ITypeDescription.SerializationType" />,
                however it's part of the .NET framework and thus serialization methods have been built-in.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.IsGenericType">
            <summary>
                Equivalent of <see cref="P:System.Type.IsGenericType" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.Properties">
            <summary>
                The list of public non-static properties with the <see cref="T:System.Runtime.Serialization.DataMemberAttribute" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.Fields">
            <summary>
                The list of public non-static fields with the <see cref="T:System.Runtime.Serialization.DataMemberAttribute" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.Methods">
            <summary>
                The list of public non-static methods in case this is a <see cref="F:SharpRemote.SerializationType.ByReference" />
                type.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.EnumValues">
            <summary>
               The list of enum values.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeDescription.GenericArguments">
            <summary>
                The list of generic type arguments, if there are any.
            </summary>
        </member>
        <member name="T:SharpRemote.ITypeModel">
            <summary>
                A representation of all types registered with a <see cref="T:SharpRemote.ISerializer" />.
                This representation describes each type (as far as serialization is concerned) and
                may be serialized/deserialized *without* requiring that the types describes by this type model
                can be loaded.
            </summary>
        </member>
        <member name="P:SharpRemote.ITypeModel.Types">
            <summary>
                The types part of this model.
            </summary>
        </member>
        <member name="T:SharpRemote.MissingMethod">
            <summary>
               An interface is missing a method.
            </summary>
        </member>
        <member name="T:SharpRemote.ITypeModelDifference">
            <summary>
            Explains the difference between two type models.
            An object of this type usually explains only ONE difference which may be as little as one type
            having been changed from struct to class.
            </summary>
        </member>
        <member name="T:SharpRemote.MissingValueType">
            <summary>
               An expected type is completely missing (maybe it has been renamed).
            </summary>
        </member>
        <member name="T:SharpRemote.ParameterDescription">
            <summary>
                Similar to <see cref="T:System.Reflection.ParameterInfo" /> (in that it describes a particular .NET method), but only
                describes its static structure that is important to a <see cref="T:SharpRemote.ISerializer" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ParameterDescription.ParameterTypeId">
            <summary>
                The id of the <see cref="P:SharpRemote.ParameterDescription.ParameterType" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ParameterDescription.ParameterType">
            <summary>
                The equivalent of <see cref="P:System.Reflection.ParameterInfo.ParameterType" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ParameterDescription.Name">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.ParameterDescription.IsIn">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.ParameterDescription.IsOut">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.ParameterDescription.IsRetval">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.ParameterDescription.Position">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.ParameterDescription.ToString">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.ParameterDescription.Create(System.Reflection.ParameterInfo,System.Collections.Generic.IDictionary{System.String,SharpRemote.TypeDescription})">
            <summary>
                Creates a new parameter description for the given type.
            </summary>
            <param name="parameter"></param>
            <param name="typesByAssemblyQualifiedName"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.PropertyDescription">
            <summary>
                Similar to <see cref="T:System.Reflection.PropertyInfo" /> (in that it describes a particular .NET property), but only
                describes its static structure that is important to a <see cref="T:SharpRemote.ISerializer" />.
            </summary>
        </member>
        <member name="M:SharpRemote.PropertyDescription.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.PropertyDescription.PropertyTypeId">
            <summary>
                The id of the <see cref="T:SharpRemote.TypeDescription" /> which describes the type of this property.
            </summary>
        </member>
        <member name="P:SharpRemote.PropertyDescription.PropertyType">
            <summary>
                The type of this property, equivalent of <see cref="P:System.Reflection.PropertyInfo.PropertyType" />.
            </summary>
        </member>
        <member name="P:SharpRemote.PropertyDescription.Type">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.PropertyDescription.GetMethod">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.PropertyDescription.SetMethod">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.PropertyDescription.Name">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.PropertyDescription.TypeDescription">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.PropertyDescription.MemberInfo">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.PropertyDescription.ToString">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.PropertyDescription.Create(SharpRemote.TypeDescription,System.Reflection.PropertyInfo,System.Collections.Generic.IDictionary{System.String,SharpRemote.TypeDescription})">
            <summary>
                Creates a new description for the given property.
            </summary>
            <param name="declaringType"></param>
            <param name="property"></param>
            <param name="typesByAssemblyQualifiedName"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.SerializationType">
            <summary>
                Describes how a given type is treated by the <see cref="T:SharpRemote.ISerializer" />.
            </summary>
        </member>
        <member name="F:SharpRemote.SerializationType.NotSerializable">
            <summary>
                The type cannot be serialized.
            </summary>
        </member>
        <member name="F:SharpRemote.SerializationType.Unknown">
            <summary>
                The type of serialization is currently unknown.
                This is usually the case when building type models for non-closed polymorphic type where
                the serialization method used differents by implementation.
            </summary>
        </member>
        <member name="F:SharpRemote.SerializationType.ByValue">
            <summary>
                The type is assumed to be an acyclic graph where each node is itself one
                of the three types.
            </summary>
        </member>
        <member name="F:SharpRemote.SerializationType.ByReference">
            <summary>
                The type is assumed to be a reference type and thus no serialization is performed:
                Instead whenever a method/property of the type is accessed, another RPC is performed.
            </summary>
        </member>
        <member name="F:SharpRemote.SerializationType.Singleton">
            <summary>
                The type is assumed to be a singleton and the instance can be retrieved via
                the method with the <see cref="T:SharpRemote.SingletonFactoryMethodAttribute" />.
            </summary>
        </member>
        <member name="T:SharpRemote.ServiceDiscovery.BinaryReaderExt">
            <summary>
                An extension to <see cref="T:System.IO.BinaryReader" />:
                Contains many methods to read values from the stream without throwing exceptions
                if the stream is too small.
            </summary>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryReaderExt.#ctor(System.IO.Stream)">
            <summary>
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryReaderExt.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            </summary>
            <param name="input"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryReaderExt.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>
            </summary>
            <param name="input"></param>
            <param name="encoding"></param>
            <param name="leaveOpen"></param>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.BinaryReaderExt.BytesLeft">
            <summary>
                The amount of bytes left in the <see cref="P:System.IO.BinaryReader.BaseStream" />.
            </summary>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryReaderExt.TryReadBoolean(System.Boolean@)">
            <summary>
                Tries to read a boolean value from the stream or returns false
                if there isn't enough bytes left.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryReaderExt.TryRead(System.String@)">
            <summary>
                Tries to read a string from the stream or returns false
                if there isn't enough bytes left.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryReaderExt.TryReadBytes(System.Int32,System.Byte[]@)">
            <summary>
                Tries to read the given amount of bytes from the stream or returns false
                if there isn't enough bytes left.
            </summary>
            <param name="length"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryReaderExt.TryRead(System.UInt16@)">
            <summary>
                Tries to read an integer from the stream or returns false
                if there isn't enough bytes left.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryReaderExt.TryRead(System.Int32@)">
            <summary>
                Tries to read an integer from the stream or returns false
                if there isn't enough bytes left.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryReaderExt.TryRead(System.UInt32@)">
            <summary>
                Tries to read an integer from the stream or returns false
                if there isn't enough bytes left.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryReaderExt.TryRead(System.Net.IPEndPoint@)">
            <summary>
            </summary>
            <param name="endPoint"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.ServiceDiscovery.BinaryWriterEx">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryWriterEx.#ctor(System.IO.Stream)">
            <summary>
            
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryWriterEx.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            
            </summary>
            <param name="output"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryWriterEx.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>
            
            </summary>
            <param name="output"></param>
            <param name="encoding"></param>
            <param name="leaveOpen"></param>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.BinaryWriterEx.Write(System.Net.IPEndPoint)">
            <summary>
            
            </summary>
            <param name="endPoint"></param>
        </member>
        <member name="T:SharpRemote.ServiceDiscovery.INetworkServiceDiscoverer">
            <summary>
                Responsible for performing queries of services in the local network as well as to answer
                those queries.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.INetworkServiceDiscoverer.LocalServices">
            <summary>
            The services registered at this instance.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.INetworkServiceDiscoverer.Settings">
            <summary>
            The settings this service operates under.
            Cannot be changed after the fact.
            </summary>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.INetworkServiceDiscoverer.RegisterService(System.String,System.Net.IPEndPoint,System.Byte[])">
            <summary>
            Registers a new service with the given name and endPoint.
            The given service remains registered and therefore is discoverable
            until either:
            - the service is disposed of
            - the AppDomain is shut down
            </summary>
            <remarks>
            There can only be one one service per (name, endPoint) tuple.
            Registering the same tuple again throws.
            </remarks>
            <param name="name"></param>
            <param name="endPoint"></param>
            <param name="payload">An optional payload</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">When <paramref name="name"/> or <paramref name="endPoint"/> is null</exception>
            <exception cref="T:System.ArgumentException">When <paramref name="name"/> is empty</exception>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.INetworkServiceDiscoverer.FindAllServices">
            <summary>
            Finds all services with the given name in the local network that respond within the one second.
            </summary>
            <remarks>
            Blocks for at least one second, but not much longer.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.INetworkServiceDiscoverer.FindAllServices(System.TimeSpan)">
            <summary>
            Finds all services in the local network that respond within the given time span.
            </summary>
            <remarks>
            Blocks for at least the given timeout, but not much longer.
            </remarks>
            <param name="timeout">The amount of time this method should wait for a response</param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.INetworkServiceDiscoverer.FindServices(System.String)">
            <summary>
            Finds all services with the given name in the local network that respond within one second.
            </summary>
            <remarks>
            Blocks for at least one second, but not much longer.
            </remarks>
            <param name="name">The name of the service to look for - case sensitive</param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.INetworkServiceDiscoverer.FindServices(System.String,System.TimeSpan)">
            <summary>
            Finds all services with the given name in the local network that respond within the given time span.
            </summary>
            <remarks>
            Blocks for at least the given timeout, but not much longer.
            </remarks>
            <param name="name">The name of the service to look for - case sensitive</param>
            <param name="timeout">The amount of time this method should wait for a response</param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverySettings">
            <summary>
            Configuration of a <see cref="T:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer"/>.
            </summary>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverySettings.#ctor">
            <summary>
            Creates a new instance of this class with all fields set to their default values.
            </summary>
        </member>
        <member name="F:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverySettings.Port">
            <summary>
            The port used by the network service discoverer.
            </summary>
            <remarks>
            Defaults to 65335.
            </remarks>
        </member>
        <member name="F:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverySettings.MulticastAddress">
            <summary>
            The address of the multicast group used by all network service discoverers.
            </summary>
            <remarks>
            Defaults to 239.255.255.255.
            </remarks>
        </member>
        <member name="F:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverySettings.TTL">
            <summary>
            The maximum number of hops the network discovery service takes.
            </summary>
        </member>
        <member name="T:SharpRemote.ServiceDiscovery.ServiceDiscoveryAnySocket">
            <summary>
            Service discovery socket that is bound to any address (and thus any network interface).
            </summary>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.ServiceDiscoveryAnySocket.GetAllNetworkInterfaces">
            <summary>
            Retrieves the list of all current network interfaces on this computer.
            </summary>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.ServiceDiscovery.IServiceDiscoverySocket">
            <summary>
            Represents a socket that is capable of querying the network for services
            as well as to answer to queries as to which services are available.
            </summary>
        </member>
        <member name="T:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer">
            <summary>
            Responsible for performing queries of services in the local network as well as to answer
            those queries.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.IsDisposed">
            <summary>
            Whether or not <see cref="M:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.Dispose"/> has been called.
            </summary>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.#ctor(SharpRemote.ServiceDiscovery.NetworkServiceDiscoverySettings,System.Boolean)">
            <summary>
            Initializes a new instance of this class with the specified settings, or
            default values when none are given.
            </summary>
            <param name="settings"></param>
            <param name="sendLegacyResponse">Whether or not legacy responses should be sent. When this is set to true, then SharpRemote V0.3 (and earlier) is able to understand a response sent from this discoverer.</param>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.LocalServices">
            <summary>
            The services registered at this instance.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.Settings">
            <summary>
            The settings this service operates under.
            Cannot be changed after the fact.
            </summary>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.RegisterService(System.String,System.Net.IPEndPoint,System.Byte[])">
            <summary>
            Registers a new service with the given name and endPoint.
            The given service remains registered and therefore is discoverable
            until either:
            - the service is disposed of
            - the AppDomain is shut down
            </summary>
            <remarks>
            There can only be one one service per (name, endPoint) tuple.
            Registering the same tuple again throws.
            </remarks>
            <param name="name">The name of the service</param>
            <param name="endPoint">The endpoint the service can be contacted at</param>
            <param name="payload">An optional payload</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">When <paramref name="name"/> or <paramref name="endPoint"/> is null</exception>
            <exception cref="T:System.ArgumentException">When <paramref name="name"/> is empty</exception>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.FindAllServices">
            <summary>
            Finds all services with the given name in the local network that respond within the one second.
            </summary>
            <remarks>
            Blocks for at least one second, but not much longer.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.FindAllServices(System.TimeSpan)">
            <summary>
            Finds all services in the local network that respond within the given time span.
            </summary>
            <remarks>
            Blocks for at least the given timeout, but not much longer.
            </remarks>
            <param name="timeout">The amount of time this method should wait for a response</param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.FindServices(System.String)">
            <summary>
            Finds all services with the given name in the local network that respond within one second.
            </summary>
            <remarks>
            Blocks for at least one second, but not much longer.
            </remarks>
            <param name="name">The name of the service to look for - case sensitive</param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.FindServices(System.String,System.TimeSpan)">
            <summary>
            Finds all services with the given name in the local network that respond within the given time span.
            </summary>
            <remarks>
            Blocks for at least the given timeout, but not much longer.
            </remarks>
            <param name="name">The name of the service to look for - case sensitive</param>
            <param name="timeout">The amount of time this method should wait for a response</param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.Dispose">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.ServiceDiscovery.ServiceDiscoverySocket">
            <summary>
                Service discovery socket implementation that is bound to a single address (and thus to a single network interface).
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.ServiceDiscoverySocket.InterfaceName">
            <summary>
                The name of the network interface this socket is bound to.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.ServiceDiscoverySocket.InterfaceStatus">
            <summary>
                The current status of the network interface this socket is bound to.
            </summary>
        </member>
        <member name="F:SharpRemote.ServiceDiscovery.Message.P2PResponseLegacyToken">
            <summary>
                Token to identify a response from software using SharpRemote V0.3 or earlier.
            </summary>
        </member>
        <member name="F:SharpRemote.ServiceDiscovery.Message.P2PResponse2Token">
            <summary>
                Token to identify a response from software using SharpRemote V0.4 or later.
            </summary>
            <remarks>
                This is the preferred response to use because it is forward and backwards compatible.
            </remarks>
        </member>
        <member name="F:SharpRemote.ServiceDiscovery.Message.MaximumMessageLength">
            <summary>
                The maximum allowed length of a network discovery message.
            </summary>
            <remarks>
                This limit exists in order to follow the guideline that a UDP packet shouldn't
                be greater than 512 in order to have good chances of getting reassembled
                in case the IPv4 MTU of any intermediate host is exceeded.
            </remarks>
        </member>
        <member name="T:SharpRemote.ServiceDiscovery.RegisteredService">
            <summary>
                Represents a registered network service that can be found
                via <see cref="M:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer.FindServices(System.String)" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.RegisteredService.Name">
            <summary>
                The name of the registered service.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.RegisteredService.EndPoint">
            <summary>
                The endpoint the registered service operates on.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.RegisteredService.Payload">
            <summary>
                An optional payload that better describes the service.
            </summary>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.RegisteredService.Dispose">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.RegisteredService.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.RegisteredService.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.ServiceDiscovery.Service">
            <summary>
                Describes a service that was located using a <see cref="T:SharpRemote.ServiceDiscovery.NetworkServiceDiscoverer" />.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.Service.Name">
            <summary>
                The name of the service.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.Service.EndPoint">
            <summary>
                The endpoint the service is bound to.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.Service.LocalAddress">
            <summary>
                The IP-Address of the adapter that received the answer from the service.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.Service.NetworkInterfaceId">
            <summary>
                The <see cref="P:System.Net.NetworkInformation.NetworkInterface.Id" /> of the <see cref="T:System.Net.NetworkInformation.NetworkInterface" />
                that received the response.
            </summary>
        </member>
        <member name="P:SharpRemote.ServiceDiscovery.Service.Payload">
            <summary>
                The payload that was added to the service entry via <see cref="M:SharpRemote.ServiceDiscovery.INetworkServiceDiscoverer.RegisterService(System.String,System.Net.IPEndPoint,System.Byte[])"/>.
            </summary>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.Service.Equals(SharpRemote.ServiceDiscovery.Service)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.Service.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.Service.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.Service.op_Equality(SharpRemote.ServiceDiscovery.Service,SharpRemote.ServiceDiscovery.Service)">
            <summary>
                Compares the two given services for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.Service.op_Inequality(SharpRemote.ServiceDiscovery.Service,SharpRemote.ServiceDiscovery.Service)">
            <summary>
                Compares the two given services for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.ServiceDiscovery.Service.ToString">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.BinarySerializer">
            <summary>
                <see cref="T:SharpRemote.ISerializer" /> implementation that just-in-time compiles the code responsible
                for serializing arbitrary types. <see cref="M:SharpRemote.BinarySerializer.WriteObject(System.IO.BinaryWriter,System.Object,SharpRemote.IRemotingEndPoint)" /> serializes an object graph to
                a <see cref="T:System.IO.BinaryWriter" /> and <see cref="M:SharpRemote.BinarySerializer.ReadObject(System.IO.BinaryReader,SharpRemote.IRemotingEndPoint)" /> deserializes one from a <see cref="T:System.IO.BinaryReader" />.
            </summary>
            <remarks>
                An object graph (or sub-graph) can only be serialized if its type is either:
                - Natively supported: <see cref="T:System.String" />, <see cref="T:System.TimeSpan" />, etc...
                - Attributed with the <see cref="T:System.Runtime.Serialization.DataContractAttribute" /> and <see cref="T:System.Runtime.Serialization.DataMemberAttribute" />
            </remarks>
        </member>
        <member name="M:SharpRemote.BinarySerializer.WriteCustomType(System.Reflection.Emit.ILGenerator,System.Type,System.Action,System.Action)">
            <summary>
                Emits the code to write an object of the given type to a <see cref="T:System.IO.BinaryWriter"/>.
            </summary>
            <param name="gen"></param>
            <param name="type"></param>
            <param name="loadWriter"></param>
            <param name="loadRemotingEndPoint"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer.EmitWriteProperties(System.Reflection.Emit.ILGenerator,System.Action,System.Type)">
            <summary>
                Emits code to write all properties of the given type into a <see cref="T:System.IO.BinaryWriter" />.
            </summary>
            <param name="gen"></param>
            <param name="loadRemotingEndPoint"></param>
            <param name="type"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer.EmitWriteFields(System.Reflection.Emit.ILGenerator,System.Action,System.Action,System.Type)">
            <summary>
                Emits code to write all fields of the given type into a <see cref="T:System.IO.BinaryWriter" />.
            </summary>
            <param name="gen"></param>
            <param name="loadValue"></param>
            <param name="loadRemotingEndPoint"></param>
            <param name="type"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer.EmitWriteValue(System.Reflection.Emit.ILGenerator,System.Action,System.Action,System.Action,System.Action,System.Action,System.Type)">
            <summary>
            Emits the code necessary to write a value of the given compile-time type to
            a <see cref="T:System.IO.BinaryWriter"/>.
            </summary>
            <param name="gen"></param>
            <param name="loadWriter"></param>
            <param name="loadValue"></param>
            <param name="loadValueAddress"></param>
            <param name="loadSerializer"></param>
            <param name="loadRemotingEndPoint"></param>
            <param name="valueType"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer.EmitReadValue(System.Reflection.Emit.ILGenerator,System.Action,System.Action,System.Action,System.Type)">
            <summary>
            Emits the code necessary to read a value of the given compile-time type from
            a <see cref="T:System.IO.BinaryReader"/>.
            </summary>
            <param name="gen"></param>
            <param name="loadReader"></param>
            <param name="loadSerializer"></param>
            <param name="loadRemotingEndPoint"></param>
            <param name="valueType"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer.CreateAndStoreNewInstance(System.Reflection.Emit.ILGenerator,SharpRemote.TypeInformation,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Creates a new instance of the given type and stores it in the given target variable.
            </summary>
            <param name="gen"></param>
            <param name="typeInformation"></param>
            <param name="tmp"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer.EmitWriteEnumeration(System.Reflection.Emit.ILGenerator,SharpRemote.TypeInformation,System.Action,System.Action,System.Action,System.Action)">
            <summary>
                Emits the code necessary to write an enumeration into a <see cref="T:System.IO.BinaryWriter" />.
            </summary>
            <param name="gen"></param>
            <param name="typeInformation"></param>
            <param name="loadWriter"></param>
            <param name="loadValue"></param>
            <param name="loadSerializer"></param>
            <param name="loadRemotingEndPoint"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer.#ctor(System.Reflection.Emit.ModuleBuilder,SharpRemote.ITypeResolver)">
            <summary>
            Creates a new serializer that dynamically compiles serialization methods to the given
            <see cref="T:System.Reflection.Emit.ModuleBuilder"/>.
            </summary>
            <param name="module"></param>
            <param name="customTypeResolver">The instance of the type resolver, if any, that is used to resolve types upon deserialization</param>
        </member>
        <member name="P:SharpRemote.BinarySerializer.Module">
            <summary>
            The module where all newly created types reside in.
            </summary>
        </member>
        <member name="M:SharpRemote.BinarySerializer.#ctor(SharpRemote.ITypeResolver)">
            <summary>
            Creates a new serializer that dynamically compiles serialization methods to a new DynamicAssembly.
            </summary>
        </member>
        <member name="M:SharpRemote.BinarySerializer.GetType(System.String)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer.RegisterType``1">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer.WriteObject(System.IO.BinaryWriter,System.Object,SharpRemote.IRemotingEndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer.ReadObject(System.IO.BinaryReader,SharpRemote.IRemotingEndPoint)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer.GetWriteValueMethodInfo(System.Type)">
            <summary>
                Returns the method to write a value of the given type to a writer.
                Signature: WriteSealed(BinaryWriter writer, T value, ISerializer serializer)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer.GetReadValueMethodInfo(System.Type)">
            <summary>
                Returns the method to write a value of the given type to a writer.
                Signature: ReadSealed(BinaryReader reader, ISerializer serializer)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.BinarySerializer.RegisterType(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer.RegisterType(System.Type,SharpRemote.BinarySerializer.SerializationMethods@)">
            <summary>
            TODO: Replace with <see cref="M:SharpRemote.CodeGeneration.Serialization.SerializationMethodStorage`1.GetOrAdd(System.Type)"/>.
            </summary>
            <param name="type"></param>
            <param name="serializationMethods"></param>
        </member>
        <member name="M:SharpRemote.BinarySerializer.IsTypeRegistered``1">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.BinarySerializer.IsTypeRegistered(System.Type)">
            <inheritdoc />
        </member>
        <member name="F:SharpRemote.BinarySerializer.SerializationMethods.WriteValueMethod">
            <summary>
                Writes a value that can be null.
            </summary>
        </member>
        <member name="T:SharpRemote.IBuiltInTypeSerializer">
            <summary>
                Responsible for providing the IL-code to serialize a value of the given type <see cref="T:System.Type" />.
            </summary>
        </member>
        <member name="M:SharpRemote.IBuiltInTypeSerializer.Supports(System.Type)">
            <summary>
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.IBuiltInTypeSerializer.EmitWriteValue(System.Reflection.Emit.ILGenerator,SharpRemote.ISerializerCompiler,System.Action,System.Action,System.Action,System.Action,System.Action,System.Type,System.Boolean)">
            <summary>
                Emits the code necessary to write a value of type <see cref="T:System.Type" /> into a <see cref="T:System.IO.BinaryWriter" />.
            </summary>
            <param name="gen"></param>
            <param name="serializerCompiler"></param>
            <param name="loadWriter"></param>
            <param name="loadValue"></param>
            <param name="loadValueAddress"></param>
            <param name="loadSerializer"></param>
            <param name="loadRemotingEndPoint"></param>
            <param name="type"></param>
            <param name="valueCanBeNull"></param>
        </member>
        <member name="M:SharpRemote.IBuiltInTypeSerializer.EmitReadValue(System.Reflection.Emit.ILGenerator,SharpRemote.ISerializerCompiler,System.Action,System.Action,System.Action,System.Type,System.Boolean)">
            <summary>
                Emits the code necessary to read a value of type <see cref="T:System.Type" /> from <see cref="T:System.IO.BinaryReader" /> that was
                previously
                written to by the code emitted by <see cref="M:SharpRemote.IBuiltInTypeSerializer.EmitWriteValue(System.Reflection.Emit.ILGenerator,SharpRemote.ISerializerCompiler,System.Action,System.Action,System.Action,System.Action,System.Action,System.Type,System.Boolean)" />.
            </summary>
            <param name="gen"></param>
            <param name="serializerCompiler"></param>
            <param name="loadReader"></param>
            <param name="loadSerializer"></param>
            <param name="loadRemotingEndPoint"></param>
            <param name="type"></param>
            <param name="valueCanBeNull"></param>
        </member>
        <member name="T:SharpRemote.AbstractTypeSerializer">
            <summary>
                Base class for <see cref="T:SharpRemote.IBuiltInTypeSerializer" /> implementations.
                Adds methods to read / write nullable values.
            </summary>
        </member>
        <member name="T:SharpRemote.Dispatch">
            <summary>
            Defines the possible modes of method dispatch that exist in this framework.
            </summary>
        </member>
        <member name="F:SharpRemote.Dispatch.DoNotSerialize">
            <summary>
            Methods are not serialized and may be called in parallel, if and when
            the <see cref="P:System.Threading.Tasks.TaskScheduler.Default"/> deems it necessary.
            </summary>
            <remarks>
            This is the default mode (as this is how every .NET method is invoked).
            </remarks>
            <remarks>
            Concurrent calls to an implementation method (on the same object) occur only under any of the following conditions:
            - there are multiple callees of the same method and object through two threads, processes or machines
            - the method returns a <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>
            
            If neither of those are true then calls to a method (either tagged with this mode or not tagged because it's the default value)
            are guarantueed to be synchronous.
            </remarks>
        </member>
        <member name="F:SharpRemote.Dispatch.SerializePerMethod">
            <summary>
            Methods are serialized on a per object AND per method basis.
            There can never be more than one invocation of the tagged method on the same object at any time.
            </summary>
            <remarks>
            Behaves exactly as locking this method with an exclusive instance level lock.
            </remarks>
        </member>
        <member name="F:SharpRemote.Dispatch.SerializePerObject">
            <summary>
            Methods are serialized on a per object basis.
            There can never be more than one invocation of ANY tagged method on the same object at any time.
            </summary>
            <remarks>
            This behaves exactly like the synchronized keyword in java. All pending calls are serialized and
            executed in sequence.
            </remarks>
        </member>
        <member name="F:SharpRemote.Dispatch.SerializePerType">
            <summary>
            Methods are serialized on a per type (interface) basis.
            There can never be more than one invocation of ANY tagged method on the same TYPE at any time (regardless of object instance).
            </summary>
            <remarks>
            This behaves exactly like locking all tagged methods with the same STATIC sync root / exclusive lock.
            </remarks>
        </member>
        <member name="T:SharpRemote.EndPointDisconnectReason">
            <summary>
                Describes the reason why a previously connected socket is now disconnected.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.RequestedByEndPoint">
            <summary>
                The connection was ended because <see cref="M:SharpRemote.IRemotingEndPoint.Disconnect"/> was called.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.RequestedByRemotEndPoint">
            <summary>
                The connection was ended because somebody called <see cref="M:SharpRemote.IRemotingEndPoint.Disconnect"/> on
                the remote endpoint.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.ReadFailure">
            <summary>
                The connection was dropped because a read operation on the socket failed.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.WriteFailure">
            <summary>
                The connection was dropped because a write operation on the socket failed.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.RpcDuplicateRequest">
            <summary>
                The connection was dropped because a request with the same RPC id than an alrady
                pending request was made.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.RpcInvalidResponse">
            <summary>
                The connection was dropped because a response to a non-existant pending RPC was received.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.UnhandledException">
            <summary>
                The connection was dropped because an unexpected exception.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.HeartbeatFailure">
            <summary>
                The connection was dropped because the heartbeat monitor reported a failure.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.ConnectionReset">
            <summary>
                The connection was reset by the remote peer.
            </summary>
            <remarks>
                This error usually happens when the remote process exits unexpectedly without properly disconnecting first.
            </remarks>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.ConnectionAborted">
            <summary>
                The connection was aborted by the underlying software on either this or the remote
                computer.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.ConnectionTimedOut">
            <summary>
                A read or write operation timed out. This usually means that the
                remote host can no longer be reached (for example a cable could have been disconnected
                or the peer computer could have powered down unexpectedly).
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointDisconnectReason.Unknown">
            <summary>
                The reason for the disconnect is unknown.
            </summary>
        </member>
        <member name="T:SharpRemote.SocketEndPoint">
            <summary>
                An endpoint which can establish a connection with exactly one other <see cref="T:SharpRemote.SocketEndPoint" />.
                One endpoints needs to <see cref="M:SharpRemote.SocketEndPoint.Bind(System.Net.IPAddress)" /> itself to an address/endpoint while
                the other needs to <see cref="M:SharpRemote.SocketEndPoint.Connect(System.String)" /> to it (just like <see cref="T:System.Net.Sockets.Socket" />).
            </summary>
            <remarks>
                A <see cref="F:SharpRemote.EndPointType.Server" /> can only accept one concurrent connection at the moment.
                See issue #36 on github for more information on how a true server endpoint will be implemented.
            </remarks>
        </member>
        <member name="T:SharpRemote.SocketEndPoint.Constants">
            <summary>
               Constants used throughout the project.
            </summary>
        </member>
        <member name="F:SharpRemote.SocketEndPoint.Constants.MinDefaultPort">
            <summary>
            The minimum port used *by default* when no explicit port and / or range is given.
            </summary>
        </member>
        <member name="F:SharpRemote.SocketEndPoint.Constants.MaxDefaultPort">
            <summary>
            The maximum port used *by default* when no explicit port and / or range is given.
            </summary>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.LogSystemSettings">
            <summary>
               Logs relevant socket, tcp/ip, etc... settings to this classes logger (SharpRemote.SocketEndPoint).
            </summary>
            <remarks>
               This method may be called upon startup (or more often depending on your needs) in order to log relevant
               settings (such as certain timeouts, the dynamic port range, etc...). Can be helpful when troubleshooting
               network problems.
            </remarks>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.#ctor(SharpRemote.EndPointType,System.String,SharpRemote.IAuthenticator,SharpRemote.IAuthenticator,SharpRemote.ServiceDiscovery.INetworkServiceDiscoverer,SharpRemote.CodeGeneration.ICodeGenerator,SharpRemote.HeartbeatSettings,SharpRemote.LatencySettings,SharpRemote.EndPointSettings,System.Boolean)">
            <summary>
                Creates a new socket end point that (optionally) is bound to the given
                P2P name, if PNRP is available, otherwise the name is only used for debugging.
            </summary>
            <param name="type">The type of endpoint to create</param>
            <param name="name">
                The name of this socket, used to publish it via PNRP as well as to refer to this endpoint in
                diagnostic output
            </param>
            <param name="clientAuthenticator">
                The authenticator, if any, to authenticate a client against a server (both need to
                use the same authenticator)
            </param>
            <param name="serverAuthenticator">
                The authenticator, if any, to authenticate a server against a client (both need to
                use the same authenticator)
            </param>
            <param name="networkServiceDiscoverer">The discoverer used to find services by name within the local network</param>
            <param name="codeGenerator">The code generator to create proxy and servant types</param>
            <param name="heartbeatSettings">
                The settings for heartbeat mechanism, if none are specified, then default settings are
                used
            </param>
            <param name="latencySettings">
                The settings for latency measurements, if none are specified, then default settings are
                used
            </param>
            <param name="endPointSettings">The settings for the endpoint itself (max. number of concurrent calls, etc...)</param>
            <param name="waitUponReadWriteError">When set to true, then read/write errors are reported with a minimum latency of 100ms</param>
        </member>
        <member name="P:SharpRemote.SocketEndPoint.InternalRemoteEndPoint">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.SocketEndPoint.InternalLocalEndPoint">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketEndPoint.TryConnect(System.String)">
            <summary>
                Tries to connect to another endPoint with the given name.
            </summary>
            <param name="endPointName"></param>
            <returns>True when a connection could be established, false otherwise</returns>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.TryConnect(System.String,System.TimeSpan)">
            <summary>
                Tries to connects to another endPoint with the given name.
            </summary>
            <param name="endPointName"></param>
            <param name="timeout"></param>
            <returns>True when the connection succeeded, false otherwise</returns>
            <exception cref="T:System.ArgumentNullException">When <paramref name="endPointName" /> is null</exception>
            <exception cref="T:System.ArgumentException">When <paramref name="endPointName" /> is empty</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When <paramref name="timeout" /> is less or equal to
                <see cref="F:System.TimeSpan.Zero" />
            </exception>
            <exception cref="T:System.InvalidOperationException">When no network service discoverer was specified when creating this client</exception>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.TryConnect(System.Net.IPEndPoint)">
            <summary>
                Tries to connects to another endPoint with the given name.
            </summary>
            <param name="endPoint"></param>
            <returns>True when the connection succeeded, false otherwise</returns>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.TryConnect(System.Net.IPEndPoint,System.TimeSpan)">
            <summary>
                Tries to connect this endPoint to the given one.
            </summary>
            <param name="endPoint"></param>
            <param name="timeout">
                The amount of time this method should block and await a successful connection from the remote
                end-point
            </param>
            <exception cref="T:System.ArgumentNullException">
                When <paramref name="endPoint" /> is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When <paramref name="timeout" /> is equal or less than <see cref="F:System.TimeSpan.Zero" />
            </exception>
            <exception cref="T:System.InvalidOperationException">
                When this endPoint is already connected to another endPoint.
            </exception>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.TryConnect(System.Net.IPEndPoint,System.TimeSpan,System.Exception@,SharpRemote.ConnectionId@)">
            <summary>
                Tries to connect this endPoint to the given one.
            </summary>
            <param name="endPoint"></param>
            <param name="timeout">
                The amount of time this method should block and await a successful connection from the remote
                end-point
            </param>
            <param name="connectionId"></param>
            <param name="exception"></param>
            <exception cref="T:System.ArgumentNullException">
                When <paramref name="endPoint" /> is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When <paramref name="timeout" /> is equal or less than <see cref="F:System.TimeSpan.Zero" />
            </exception>
            <exception cref="T:System.InvalidOperationException">
                When this endPoint is already connected to another endPoint.
            </exception>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.Connect(System.String,System.TimeSpan)">
            <summary>
                Connects to another endPoint with the given name.
            </summary>
            <param name="endPointName"></param>
            <param name="timeout"></param>
            <exception cref="T:System.ArgumentException">
                In case <paramref name="endPointName" /> is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When <paramref name="timeout" /> is equal or less than <see cref="F:System.TimeSpan.Zero" />
            </exception>
            <exception cref="T:System.InvalidOperationException">
                When this endPoint is already connected to another endPoint.
            </exception>
            <exception cref="T:SharpRemote.NoSuchIPEndPointException">
                When no such endPoint could be *found* - it might exist but this one is
                incapable of establishing a successfuly connection
            </exception>
            <exception cref="T:SharpRemote.AuthenticationException">
                - The given endPoint is no <see cref="F:SharpRemote.EndPointType.Server" />
                - The given endPoint failed authentication
            </exception>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.Connect(System.Net.IPEndPoint)">
            <summary>
                Connects this endPoint to the given one.
            </summary>
            <param name="endPoint"></param>
            ///
            <exception cref="T:System.ArgumentNullException">
                When <paramref name="endPoint" /> is null
            </exception>
            <exception cref="T:System.InvalidOperationException">
                When this endPoint is already connected to another endPoint.
            </exception>
            <exception cref="T:SharpRemote.NoSuchIPEndPointException">
                When no such endPoint could be *found* - it might exist but this one is
                incapable of establishing a successfuly connection
            </exception>
            <exception cref="T:SharpRemote.AuthenticationException">
                - The given endPoint is no <see cref="F:SharpRemote.EndPointType.Server" />
                - The given endPoint failed authentication
            </exception>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.Connect(System.Net.IPEndPoint,System.TimeSpan)">
            <summary>
                Connects this endPoint to the given one.
            </summary>
            <param name="endPoint"></param>
            <param name="timeout">
                The amount of time this method should block and await a successful connection from the remote
                end-point
            </param>
            <exception cref="T:System.ArgumentNullException">
                When <paramref name="endPoint" /> is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When <paramref name="timeout" /> is equal or less than <see cref="F:System.TimeSpan.Zero" />
            </exception>
            <exception cref="T:System.InvalidOperationException">
                When this endPoint is already connected to another endPoint.
            </exception>
            <exception cref="T:SharpRemote.NoSuchIPEndPointException">
                When no such endPoint could be *found* - it might exist but this one is
                incapable of establishing a successfuly connection
            </exception>
            <exception cref="T:SharpRemote.AuthenticationException">
                - The given endPoint is no <see cref="F:SharpRemote.EndPointType.Server" />
                - The given endPoint failed authentication
            </exception>
            <exception cref="T:SharpRemote.AuthenticationRequiredException">
                - The given endPoint requires authentication, but this one didn't provide any
            </exception>
            <exception cref="T:SharpRemote.HandshakeException">
                - The handshake between this and the given endpoint failed
            </exception>
        </member>
        <member name="P:SharpRemote.SocketEndPoint.RemoteEndPoint">
            <summary>
                IPAddress+Port pair of the connected endPoint in case <see cref="M:SharpRemote.SocketEndPoint.Connect(System.Net.IPEndPoint)" /> has been
                called.
                Otherwise null.
            </summary>
        </member>
        <member name="P:SharpRemote.SocketEndPoint.LocalEndPoint">
            <summary>
                IPAddress+Port pair of this endPoint in case <see cref="M:SharpRemote.SocketEndPoint.Bind(System.Net.IPAddress)" />
                or
                has been called.
                Otherwise null.
            </summary>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.Bind(System.Net.IPEndPoint)">
            <summary>
                Binds this socket
            </summary>
            <param name="ep"></param>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.Bind(System.Net.IPAddress)">
            <summary>
                Binds this socket to the given address.
                The listening port will in the range of [49152, 65535] and can be retrieved
                via <see cref="P:SharpRemote.SocketEndPoint.LocalEndPoint"/> after this call has succeeded.
            </summary>
            <param name="localAddress"></param>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.Bind(System.Net.IPAddress,System.UInt16,System.UInt16)">
            <summary>
                Binds this socket to the given address.
                The listening port will in the range of [<paramref name="minPort"/>, <paramref name="maxPort"/>] and can be retrieved
                via <see cref="P:SharpRemote.SocketEndPoint.LocalEndPoint"/> after this call has succeeded.
            </summary>
            <remarks>
                The current implementation tries to bind the socket to <paramref name="minPort"/> and then increments
                it by one until either a Bind() operation succeeds or maxPort has been reached. If the latter occured
                (and Bind() still didn't succeed, then a <see cref="T:System.SystemException"/> is thrown.
            </remarks>
            <param name="localAddress"></param>
            <param name="minPort">The minimum port number to which this endpoint may be bound to</param>
            <param name="maxPort">The maximum port number to which this endpoint may be bound to</param>
            <exception cref="T:System.SystemException">When none of the given ports is available</exception>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.Bind(SharpRemote.Sockets.ISocket)">
            <summary>
                Binds this endpoint endpoint to the given socket.
            </summary>
            <param name="serverSocket"></param>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.Connect(System.String)">
            <summary>
                Connects to another endPoint with the given name.
            </summary>
            <param name="endPointName"></param>
        </member>
        <member name="M:SharpRemote.SocketEndPoint.DisposeAdditional">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketEndPoint.Send(SharpRemote.Sockets.ISocket,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketEndPoint.SynchronizedWrite(SharpRemote.Sockets.ISocket,System.Byte[],System.Int32,SharpRemote.EndPointDisconnectReason@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketEndPoint.SynchronizedRead(SharpRemote.Sockets.ISocket,System.Byte[],System.TimeSpan,SharpRemote.EndPointDisconnectReason@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketEndPoint.SynchronizedRead(SharpRemote.Sockets.ISocket,System.Byte[],SharpRemote.EndPointDisconnectReason@)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketEndPoint.GetRemoteEndPointOf(SharpRemote.Sockets.ISocket)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketEndPoint.TryParseEndPoint(System.String)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketEndPoint.DisconnectTransport(SharpRemote.Sockets.ISocket,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketEndPoint.DisposeAfterDisconnect(SharpRemote.Sockets.ISocket)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.SocketEndPoint.SendGoodbye(SharpRemote.Sockets.ISocket,System.Int64,System.TimeSpan)">
            <summary>
                Sends a goodbye message over the socket.
            </summary>
            <param name="socket"></param>
            <param name="rpcId"></param>
            <param name="waitTime"></param>
            <returns>True when the goodbye message could be sent, false otherwise</returns>
        </member>
        <member name="T:SharpRemote.EndPointType">
            <summary>
                Describes to a <see cref="T:SharpRemote.AbstractBinaryStreamEndPoint`1" /> if the current endpoint
                is supposed to be a server or a client.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointType.Client">
            <summary>
                The endpoint is a client:
                Methods such as <see cref="M:SharpRemote.ISocketEndPoint.Connect(System.String,System.TimeSpan)" />
                and <see cref="M:SharpRemote.ISocketEndPoint.TryConnect(System.String)" /> may be used.
            </summary>
        </member>
        <member name="F:SharpRemote.EndPointType.Server">
            <summary>
                The endpoint is a server:
                Methods such as <see cref="M:SharpRemote.ISocketEndPoint.Bind(System.Net.IPEndPoint)" /> or
                <see cref="M:SharpRemote.ISocketEndPoint.Bind(System.Net.IPAddress)" /> may be used.
            </summary>
        </member>
        <member name="T:SharpRemote.GrainIdGenerator">
            <summary>
            </summary>
        </member>
        <member name="F:SharpRemote.GrainIdGenerator.MaxValue">
            <summary>
                The maximum possible <see cref="P:SharpRemote.IGrain.ObjectId" /> which can be generated by this object.
            </summary>
        </member>
        <member name="F:SharpRemote.GrainIdGenerator.MinValue">
            <summary>
                The minimum <see cref="P:SharpRemote.IGrain.ObjectId" /> which can be generated by this object.
            </summary>
        </member>
        <member name="F:SharpRemote.GrainIdGenerator.TotalReservedRange">
            <summary>
                The range of values that is reserved by this generator.
                Spans 2^63 continuous values from 2^63-1 to 2^64-1.
                This leaves 0 to 2^63-2 for user-defined ids.
            </summary>
        </member>
        <member name="M:SharpRemote.GrainIdGenerator.GetRangeFor(SharpRemote.EndPointType)">
            <summary>
               Returns the range of ObjectIds which may be used by the given endpoint.
               Both server and client have completely distinct ranges.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.GrainIdGenerator.#ctor(SharpRemote.EndPointType)">
            <summary>
                Initializes this generator for the given endpoint type.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:SharpRemote.GrainIdGenerator.GetGrainId">
            <summary>
                Generates an id for the next grain.
                For the same <see cref="T:SharpRemote.GrainIdGenerator"/> instance, this method will never generate the same value twice.
            </summary>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.GrainIdRange">
            <summary>
                Describes a range of <see cref="P:SharpRemote.IGrain.ObjectId" />s.
            </summary>
        </member>
        <member name="F:SharpRemote.GrainIdRange.Minimum">
            <summary>
                The minimum possible grain id in this range.
            </summary>
        </member>
        <member name="F:SharpRemote.GrainIdRange.Maximum">
            <summary>
                The maximum possible grain id in this range.
            </summary>
        </member>
        <member name="M:SharpRemote.GrainIdRange.#ctor(System.UInt64,System.UInt64)">
            <summary>
                Initializes this object.
            </summary>
            <param name="minimum"></param>
            <param name="maximum"></param>
        </member>
        <member name="M:SharpRemote.GrainIdRange.ToString">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.LatencySettings">
            <summary>
            This class is used to describe if and how latency measurements are performed.
            </summary>
        </member>
        <member name="P:SharpRemote.LatencySettings.DontMeasure">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.LatencySettings.Interval">
            <summary>
            The interval at which latency measurements are performed.
            </summary>
            <remarks>
            Settings this to a very low (a few milliseconds) value might have a negative impact on performance.
            </remarks>
            <remarks>
            The default value is 100ms.
            </remarks>
            <remarks>
            Settings this to zero disables all latency measurements.
            </remarks>
        </member>
        <member name="F:SharpRemote.LatencySettings.NumSamples">
            <summary>
            The amount of samples over which the average roundtrip time is calulated.
            </summary>
            <remarks>
            The default value is 100.
            </remarks>
        </member>
        <member name="F:SharpRemote.LatencySettings.PerformLatencyMeasurements">
            <summary>
            Whether or not latency measurements shall be performed.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="M:SharpRemote.LatencySettings.#ctor">
            <summary>
            Initializes a new instance of this class with default values.
            </summary>
        </member>
        <member name="T:SharpRemote.GrainIdRangeExhaustedException">
            <summary>
                This exception is thrown when no more <see cref="P:SharpRemote.IGrain.ObjectId" />s can be generated
                because the key range is exhausted.
            </summary>
        </member>
        <member name="M:SharpRemote.GrainIdRangeExhaustedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.GrainIdRangeExhaustedException.#ctor">
            <summary>
                Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="T:SharpRemote.PendingMethodsQueue">
            <summary>
                Handles remote method calls that are not completed yet.
            </summary>
        </member>
        <member name="M:SharpRemote.PendingMethodsQueue.#ctor(System.String,System.Int32)">
            <summary>
            </summary>
            <param name="endPointName"></param>
            <param name="maxConcurrentCalls">The total number of concurrent calls that may be pending at any given time, any further call stalls the calling thread, even if async</param>
        </member>
        <member name="P:SharpRemote.PendingMethodsQueue.IsConnected">
            <summary>
                Whether or not this endpoint is currently connected.
            </summary>
            <remarks>
                While set to false, all calls to <see cref="M:SharpRemote.PendingMethodsQueue.Enqueue(System.UInt64,System.String,System.String,System.IO.MemoryStream,System.Int64,System.Action{SharpRemote.PendingMethodCall})" /> throw a
            </remarks>
        </member>
        <member name="M:SharpRemote.PendingMethodsQueue.TakePendingWrite(System.Int32@)">
            <summary>
                Retrieves the next message for writing from the queue.
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.PendingMethodsQueue.HandleResponse(System.Int64,SharpRemote.EndPoints.MessageType,System.IO.BinaryReader)">
            <summary>
                Shall be called once an answer to a pending call has been received.
                Causes the <see cref="T:System.Threading.WaitHandle" /> of the pending call to be set.
            </summary>
            <param name="rpcId"></param>
            <param name="messageType"></param>
            <param name="reader"></param>
        </member>
        <member name="M:SharpRemote.PendingMethodsQueue.Recycle(SharpRemote.PendingMethodCall)">
            <summary>
                Shall be called once a pending call has been completely handled.
            </summary>
            <param name="methodCall"></param>
        </member>
        <member name="T:SharpRemote.PendingMethodCall">
            <summary>
                Represents a method call that has yet to be completed.
            </summary>
            <remarks>
                Helps to reduce the amount of resources (handles, streams) that are created and destroyed over and
                over in order to reduce the amount of pressure on the GC as well as to reduce the amount of native
                resources that are created and destroyed.
            </remarks>
        </member>
        <member name="T:SharpRemote.ProcessAccessFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.All">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.Terminate">
            <summary>
            Required to terminate a process using TerminateProcess.
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.CreateThread">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.VirtualMemoryOperation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.VirtualMemoryRead">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.VirtualMemoryWrite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.DuplicateHandle">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.CreateProcess">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.SetQuota">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.SetInformation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.QueryInformation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.QueryLimitedInformation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.ProcessAccessFlags.Synchronize">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpRemote.HeartbeatMonitor">
            <summary>
                Responsible for invoking the heartbeat interface regularly.
                Notifies in case of skipped beats.
            </summary>
        </member>
        <member name="M:SharpRemote.HeartbeatMonitor.#ctor(SharpRemote.IHeartbeat,SharpRemote.Diagnostics.IDebugger,SharpRemote.HeartbeatSettings,SharpRemote.ConnectionId,System.String,System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
                Initializes this heartbeat monitor with the given heartbeat interface and
                settings that define how often a heartbeat measurement is performed.
            </summary>
            <param name="heartbeat"></param>
            <param name="debugger"></param>
            <param name="settings"></param>
            <param name="connectionId"></param>
            <param name="endPointName"></param>
            <param name="localEndPoint"></param>
            <param name="remoteEndPoint"></param>
        </member>
        <member name="M:SharpRemote.HeartbeatMonitor.#ctor(SharpRemote.IHeartbeat,SharpRemote.Diagnostics.IDebugger,System.TimeSpan,System.Int32,System.Boolean,System.Boolean,System.Boolean,SharpRemote.ConnectionId,System.String,System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
                Initializes this heartbeat monitor with the given heartbeat interface and
                settings that define how often a heartbeat measurement is performed.
            </summary>
            <param name="heartbeat"></param>
            <param name="debugger"></param>
            <param name="heartBeatInterval"></param>
            <param name="failureThreshold"></param>
            <param name="enabledWithAttachedDebugger"></param>
            <param name="useHeartbeatFailureDetection"></param>
            <param name="allowRemoteHeartbeatDisable"></param>
            <param name="connectionId"></param>
            <param name="endPointName"></param>
            <param name="locEndPoint"></param>
            <param name="remoteEndPoint"></param>
        </member>
        <member name="P:SharpRemote.HeartbeatMonitor.Interval">
            <summary>
                The configured heartbeat interval, e.g. the amount of time that shall pass before
                a new heartbeat is started.
            </summary>
        </member>
        <member name="P:SharpRemote.HeartbeatMonitor.FailureInterval">
            <summary>
                The amount of time for which a heartbeat may not return (e.g. fail) before the connection is assumed
                to be dead.
            </summary>
        </member>
        <member name="P:SharpRemote.HeartbeatMonitor.NumHeartbeats">
            <summary>
                The total number of heartbeats performed since <see cref="M:SharpRemote.HeartbeatMonitor.Start" />.
            </summary>
        </member>
        <member name="P:SharpRemote.HeartbeatMonitor.LastHeartbeat">
            <summary>
                The point in time where the last heartbeat was performed.
            </summary>
        </member>
        <member name="P:SharpRemote.HeartbeatMonitor.IsDisposed">
            <summary>
                Whether or not this heartbeat is disposed of.
            </summary>
        </member>
        <member name="P:SharpRemote.HeartbeatMonitor.IsStarted">
            <summary>
                Whether or not <see cref="M:SharpRemote.HeartbeatMonitor.Start" /> has been called (and <see cref="M:SharpRemote.HeartbeatMonitor.Stop" /> has not since then).
            </summary>
        </member>
        <member name="P:SharpRemote.HeartbeatMonitor.FailureDetected">
            <summary>
                Whether or not a failure has been detected.
            </summary>
        </member>
        <member name="P:SharpRemote.HeartbeatMonitor.ReportFailures">
            <summary>
                Whether or not a failure shall currently be reported - or ignored
            </summary>
            <returns>True when a failure shall be reported, false when it shall be ignored</returns>
        </member>
        <member name="M:SharpRemote.HeartbeatMonitor.Start">
            <summary>
                Starts this heartbeat monitor.
            </summary>
            <remarks>
                Resets the <see cref="P:SharpRemote.HeartbeatMonitor.FailureDetected" /> property to false.
            </remarks>
        </member>
        <member name="M:SharpRemote.HeartbeatMonitor.Stop">
            <summary>
                Stops the heartbeat monitor, failures will no longer be reported, nor
                will the proxy be accessed in any way.
            </summary>
        </member>
        <member name="M:SharpRemote.HeartbeatMonitor.WaitForHeartbeat(System.Threading.Tasks.Task)">
            <summary>
                Performs a single heartbeat.
            </summary>
            <param name="task"></param>
            <returns>True when the heartbeat succeeded, false otherwise</returns>
        </member>
        <member name="E:SharpRemote.HeartbeatMonitor.OnFailure">
            <summary>
                This event is fired when and if this monitor detects a failure of the heartbeat
                interface because too many heartbeats passed
            </summary>
        </member>
        <member name="T:SharpRemote.Heartbeat">
            <summary>
                Default <see cref="T:SharpRemote.IHeartbeat" /> implementation that returns immediately.
            </summary>
        </member>
        <member name="T:SharpRemote.LatencyMonitor">
            <summary>
                This class is responsible for measuring the average latency of a <see cref="M:SharpRemote.ILatency.Roundtrip" />
                invocation. It can be used by installing a <see cref="T:SharpRemote.ILatency" /> proxy on the side that wants to
                measure the latency and a <see cref="T:SharpRemote.Latency" /> servant on the other side.
            </summary>
        </member>
        <member name="M:SharpRemote.LatencyMonitor.#ctor(SharpRemote.ILatency,System.TimeSpan,System.Int32,System.Boolean,System.String)">
            <summary>
                Initializes this latency monitor with the given interval and number of samples over which
                the average latency is determined.
            </summary>
            <param name="latencyGrain"></param>
            <param name="interval"></param>
            <param name="numSamples"></param>
            <param name="performLatencyMeasurements"></param>
            <param name="endPointName"></param>
        </member>
        <member name="M:SharpRemote.LatencyMonitor.#ctor(SharpRemote.ILatency,SharpRemote.LatencySettings,System.String)">
            <summary>
                Initializes this latency monitor with the given interval and number of samples over which
                the average latency is determined.
            </summary>
            <param name="latencyGrain"></param>
            <param name="settings"></param>
            <param name="endPointName"></param>
        </member>
        <member name="P:SharpRemote.LatencyMonitor.RoundtripTime">
            <summary>
                The average roundtrip time of a <see cref="M:SharpRemote.ILatency.Roundtrip" /> call.
                Can be used to determine the base overhead of the remoting system.
            </summary>
        </member>
        <member name="P:SharpRemote.LatencyMonitor.IsDisposed">
            <summary>
                Whether or not this latency monitor has been disposed of.
            </summary>
        </member>
        <member name="P:SharpRemote.LatencyMonitor.IsStarted">
            <summary>
                Whether or not <see cref="M:SharpRemote.LatencyMonitor.Start" /> has been called (and <see cref="M:SharpRemote.LatencyMonitor.Stop" /> has not since then).
            </summary>
        </member>
        <member name="M:SharpRemote.LatencyMonitor.Start">
            <summary>
                Starts this latency monitor, e.g. begins measuring the latency.
            </summary>
        </member>
        <member name="M:SharpRemote.LatencyMonitor.Stop">
            <summary>
                Stops the latency monitor from perform any further measurements.
            </summary>
        </member>
        <member name="M:SharpRemote.LatencyMonitor.MeasureLatency">
            <summary>
                Measures the current latency and calculates the average latency.
            </summary>
        </member>
        <member name="T:SharpRemote.IHeartbeat">
            <summary>
                This interface is used to detected failures of remote endpoints.
            </summary>
        </member>
        <member name="E:SharpRemote.IHeartbeat.RemoteDebuggerAttached">
            <summary>
                This method is called when a debugger has been attached to the process of the caller.
                If allowed, the callee will disable its heartbeat detection until the next call to
                <see cref="E:SharpRemote.IHeartbeat.RemoteDebuggerDetached" />.
            </summary>
        </member>
        <member name="E:SharpRemote.IHeartbeat.RemoteDebuggerDetached">
            <summary>
                This method is called when a debugger has been detached from the process of the caller.
                If allowed, the callee will enable its heartbeat detection again until the next call to
                <see cref="E:SharpRemote.IHeartbeat.RemoteDebuggerAttached" />.
            </summary>
        </member>
        <member name="M:SharpRemote.IHeartbeat.Beat">
            <summary>
                Called regularly in order to detect whether or not the remote endpoint is still alive or not.
            </summary>
        </member>
        <member name="T:SharpRemote.MethodInvocation">
            <summary>
                Represents a currently executing or pending method invocation.
            </summary>
        </member>
        <member name="F:SharpRemote.MethodInvocation.RequestTime">
            <summary>
            The time the method invocation request was initially processed (but not yet executed).
            </summary>
        </member>
        <member name="F:SharpRemote.MethodInvocation.RpcId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.MethodInvocation.Grain">
            <summary>
            The grain that on which a method (or event) is to be executed.
            </summary>
        </member>
        <member name="F:SharpRemote.MethodInvocation.MethodName">
            <summary>
            The name of the method that is about to be executed.
            </summary>
        </member>
        <member name="F:SharpRemote.MethodInvocation.Task">
            <summary>
            The task that actually executes the method.
            </summary>
        </member>
        <member name="T:SharpRemote.AuthenticationException">
            <summary>
            This exception is thrown when client or server failed authentication.
            </summary>
        </member>
        <member name="M:SharpRemote.AuthenticationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.AuthenticationException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="M:SharpRemote.AuthenticationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of this exception with the given message and inner exception that
            is the cause of this exception.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:SharpRemote.AuthenticationRequiredException">
            <summary>
            This exception is thrown when client or server requires authentication, but the other side
            doesn't provide any.
            </summary>
        </member>
        <member name="M:SharpRemote.AuthenticationRequiredException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.AuthenticationRequiredException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="M:SharpRemote.AuthenticationRequiredException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of this exception with the given message and inner exception that
            is the cause of this exception.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:SharpRemote.ConnectionLostException">
            <summary>
                This exception is thrown when a synchronous method on the proxy, or an event on the servant, is called and the
                connection
                has been interrupted while the call was ongoing.
            </summary>
        </member>
        <member name="F:SharpRemote.ConnectionLostException.EndPointName">
            <summary>
                The name of the endpoint who's connection dropped.
            </summary>
        </member>
        <member name="F:SharpRemote.ConnectionLostException.LocalEndPoint">
            <summary>
                The address of the local endpoint which lost the connection.
            </summary>
        </member>
        <member name="F:SharpRemote.ConnectionLostException.RemoteEndPoint">
            <summary>
                The address of the endpoint to which the connection has been lost.
            </summary>
        </member>
        <member name="M:SharpRemote.ConnectionLostException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.ConnectionLostException.#ctor">
            <summary>
                Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="M:SharpRemote.ConnectionLostException.#ctor(System.String,System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
                Initializes a new instance of this exception.
            </summary>
            <param name="endPointName"></param>
            <param name="localEndPoint"></param>
            <param name="remoteEndPoint"></param>
        </member>
        <member name="M:SharpRemote.ConnectionLostException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.HandshakeException">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpRemote.HandshakeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.HandshakeException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="M:SharpRemote.HandshakeException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of this exception with the given message and inner exception that
            is the cause of this exception.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:SharpRemote.NoSuchApplicationException">
            <summary>
            This exception is thrown when an application was referenced (by name) that doesn't exist.
            </summary>
        </member>
        <member name="M:SharpRemote.NoSuchApplicationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.NoSuchApplicationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.NoSuchApplicationException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="M:SharpRemote.NoSuchApplicationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of this exception with the application name in question and the
            inner exception, that was the cause of this exception.
            </summary>
            <param name="applicationName"></param>
            <param name="e"></param>
        </member>
        <member name="F:SharpRemote.NoSuchApplicationException.ApplicationName">
            <summary>
            The name of the application in question.
            </summary>
        </member>
        <member name="T:SharpRemote.NoSuchIPEndPointException">
            <summary>
            This exception is thrown when a connection to a non-existing / unreachable ip-endpoint is established.
            </summary>
        </member>
        <member name="M:SharpRemote.NoSuchIPEndPointException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.NoSuchIPEndPointException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.NoSuchIPEndPointException.#ctor(System.Net.IPEndPoint,System.Exception)">
            <summary>
            Initializes an instance of this exception with the given ipendpoint and inner exception
            that caused this exception.
            </summary>
            <param name="endPoint"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:SharpRemote.NoSuchIPEndPointException.#ctor(System.Net.IPEndPoint,System.TimeSpan,System.Exception)">
            <summary>
            Initializes an instance of this exception with the given ipendpoint and inner exception
            that caused this exception.
            </summary>
            <param name="endPoint"></param>
            <param name="timeout">The amount of time that passed until the connection-establishment was dropped</param>
            <param name="innerException"></param>
        </member>
        <member name="M:SharpRemote.NoSuchIPEndPointException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes an instance of this exception with the given endpoint name and inner exception
            that caused this exception.
            </summary>
            <param name="endPointName"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:SharpRemote.NoSuchIPEndPointException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="F:SharpRemote.NoSuchIPEndPointException.EndPoint">
            <summary>
            The ip-endpoint in question, if given.
            </summary>
        </member>
        <member name="F:SharpRemote.NoSuchIPEndPointException.EndPointName">
            <summary>
            The name of the endpoint in question, if given.
            </summary>
        </member>
        <member name="T:SharpRemote.NoSuchServantException">
            <summary>
                This exception is thrown when a synchronous call on a proxy, or an event on a subject is invoked, but the other endpoint currently
                does not have a servant with the given id registered.
            </summary>
        </member>
        <member name="F:SharpRemote.NoSuchServantException.ObjectId">
            <summary>
                The <see cref="P:SharpRemote.IGrain.ObjectId" /> that could not be found on the callee's side.
            </summary>
        </member>
        <member name="M:SharpRemote.NoSuchServantException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.NoSuchServantException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.NoSuchServantException.#ctor(System.UInt64)">
            <summary>
                Initializes a new instance of this exception with the given object id.
            </summary>
            <param name="objectId"></param>
        </member>
        <member name="M:SharpRemote.NoSuchServantException.#ctor(System.String,System.UInt64,System.String,System.String,System.Int32,System.Int32)">
            <summary>
                Initializes a new instance of this exception with the given object id.
            </summary>
            <param name="endPointName">The name of the endpoint</param>
            <param name="objectId">
                The object id of the <see cref="T:SharpRemote.IGrain" /> that could not be found
            </param>
            <param name="typeName">
                The interface the <see cref="T:SharpRemote.IGrain" /> should implement
            </param>
            <param name="methodName">The method that should have been invoked in the process</param>
            <param name="numServants">The amount of servants currently registered with the endpoint</param>
            <param name="numProxies">The amount of proxies currently registered with the endpoint</param>
        </member>
        <member name="M:SharpRemote.NoSuchServantException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="T:SharpRemote.NotConnectedException">
            <summary>
                This exception is thrown when a method is called on a proxy and the underlying connection
                to where its subject lies has is not connected (either because no connection attempt was made,
                or the connection was disconnected / dropped **before** the method call was invoked).
            </summary>
            <remarks>
                When this exception is thrown then it is guarantueed that the method on the subject 
            </remarks>
        </member>
        <member name="F:SharpRemote.NotConnectedException.EndPointName">
            <summary>
                The name of the endpoint that was not connected.
            </summary>
        </member>
        <member name="M:SharpRemote.NotConnectedException.#ctor(System.String)">
            <summary>
                Initializes a new instance of this exception with the given endpoint name.
            </summary>
            <param name="endPointName"></param>
        </member>
        <member name="M:SharpRemote.NotConnectedException.#ctor">
            <summary>
                Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="M:SharpRemote.NotConnectedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Deserilization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.NotConnectedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:SharpRemote.SharpRemoteException">
            <summary>
            Base exception for various exceptions (but not all) thrown by this library.
            </summary>
        </member>
        <member name="M:SharpRemote.SharpRemoteException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="M:SharpRemote.SharpRemoteException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.SharpRemoteException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance with the given message and inner exception that is the cause
            for this exception.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:SharpRemote.SerializationException">
            <summary>
            This exception is thrown when a type or message is encountered that cannot be serialized / deserialized.
            </summary>
        </member>
        <member name="M:SharpRemote.SerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.SerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of this exception with the given message and inner exception
            that is the cause of this exception.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:SharpRemote.SerializationException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="T:SharpRemote.TypeMismatchException">
            <summary>
            This exception is thrown when a remote method call is executed between
            incompatible <see cref="T:SharpRemote.IProxy"/> and <see cref="T:SharpRemote.IServant"/> instances, for example
            because they implement different interfaces.
            </summary>
        </member>
        <member name="M:SharpRemote.TypeMismatchException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.TypeMismatchException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of this exception with the given message and inner exception
            that is the cause of this exception.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:SharpRemote.TypeMismatchException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="T:SharpRemote.UnserializableException">
            <summary>
            This exception is thrown when a thrown exception should be marshalled (because it crosses the proxy / servant threshold)
            but cannot, for example because it is missing the <see cref="T:System.SerializableAttribute"/> or a proper constructor.
            
            It preserves a lot of information about the original exception to help document the original problem as well as
            to find it, if necessary.
            </summary>
        </member>
        <member name="M:SharpRemote.UnserializableException.#ctor(System.String)">
            <summary>
            Creates a new UnserializableException.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:SharpRemote.UnserializableException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new UnserializableException that tries to capture
            as much information about the original (unserializable) exception
            as possible to ease debugging.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:SharpRemote.UnserializableException.#ctor(System.Exception)">
            <summary>
            Creates a new UnserializableException that tries to capture
            as much information about the original (unserializable) exception
            as possible to ease debugging.
            </summary>
            <param name="originalException"></param>
        </member>
        <member name="M:SharpRemote.UnserializableException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Restores an UnserializableException from the given stream.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.UnserializableException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.UnserializableException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="P:SharpRemote.UnserializableException.OriginalMessage">
            <summary>
            The <see cref="P:System.Exception.Message"/> of the
            original exception that could not be serialized.
            </summary>
        </member>
        <member name="P:SharpRemote.UnserializableException.OriginalStacktrace">
            <summary>
            The <see cref="P:System.Exception.StackTrace"/> of the
            original exception that could not be serialized.
            </summary>
        </member>
        <member name="P:SharpRemote.UnserializableException.OriginalSource">
            <summary>
            The <see cref="P:System.Exception.Source"/> of the
            original exception that could not be serialized.
            </summary>
        </member>
        <member name="P:SharpRemote.UnserializableException.OriginalTypename">
            <summary>
            The fully qualified typename of the original
            exception that could not be serialized.
            </summary>
        </member>
        <member name="P:SharpRemote.UnserializableException.OriginalTargetSite">
            <summary>
            The name of the <see cref="P:System.Exception.TargetSite"/> of the
            original exception that could not be serialized.
            </summary>
        </member>
        <member name="T:SharpRemote.IAuthenticator">
            <summary>
            The interface used to perform a challenge-response authentication between
            client and server.
            </summary>
        </member>
        <member name="M:SharpRemote.IAuthenticator.CreateChallenge">
            <summary>
            Starts a new challenge.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.IAuthenticator.CreateResponse(System.String)">
            <summary>
            Creates the response for the given challenge.
            </summary>
            <param name="challenge"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.IAuthenticator.Authenticate(System.String,System.String)">
            <summary>
            Performs the authentication for the given challenge and response.
            </summary>
            <param name="challenge"></param>
            <param name="response"></param>
            <returns>True when the challenge succeeded, false otherwise</returns>
        </member>
        <member name="T:SharpRemote.IGrain">
            <summary>
            Base interface for objects involved in remoting.
            </summary>
        </member>
        <member name="P:SharpRemote.IGrain.ObjectId">
            <summary>
            The unique id of the object. A proxy and servant (over the same channel) belong
            together when they have the same id.
            </summary>
        </member>
        <member name="P:SharpRemote.IGrain.Serializer">
            <summary>
            The serialized used to serialize and deserialize method arguments, return values
            and exceptions.
            </summary>
        </member>
        <member name="P:SharpRemote.IGrain.InterfaceType">
            <summary>
            The actual type of the interface that is being remoted.
            </summary>
        </member>
        <member name="P:SharpRemote.IGrain.EndPoint">
            <summary>
                The endpoint this grain has been created by and over which all communication
                is performed.
            </summary>
        </member>
        <member name="M:SharpRemote.IGrain.Invoke(System.String,System.IO.BinaryReader,System.IO.BinaryWriter)">
            <summary>
            Shall invoke the event or method named <paramref ref="eventOrMethodName"/>.
            </summary>
            <param name="eventOrMethodName"></param>
            <param name="reader"></param>
            <param name="writer"></param>
        </member>
        <member name="M:SharpRemote.IGrain.GetTaskScheduler(System.String)">
            <summary>
            Returns the specific task scheduler instance that must be used to schedule an invocation
            of the given method or null if <see cref="P:System.Threading.Tasks.TaskScheduler.Default"/> shall be used.
            </summary>
            <param name="eventOrMethodName"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.InvokeAttribute">
            <summary>
                Can be used to specify how a certain event, method or property should be invoked when being called through a proxy
                / servant.
                By default, all methods will be invoked on a new task on the <see cref="P:System.Threading.Tasks.TaskScheduler.Default" />, e.g. multiple
                (concurrent) calls
                will be executed on (possibly) multiple threads.
                When such a behaviour is not desired, one of the following scheduling types can be used instead:
                - <see cref="F:SharpRemote.Dispatch.SerializePerMethod" />: Concurrent invocations of this method (or property/event) are
                serialized and executed one after the other
                - <see cref="F:SharpRemote.Dispatch.SerializePerObject" />: Concurrent invocations of this method AND any other on the SAME
                object with the same invokation-type are serialized and executed one after the other
                - <see cref="F:SharpRemote.Dispatch.SerializePerType" />: Concurrent invocations of this method AND any other method on the SAME
                interface with the same invokation-type are serialized and executed one after the other
            </summary>
        </member>
        <member name="M:SharpRemote.InvokeAttribute.#ctor(SharpRemote.Dispatch)">
            <summary>
                Initializes this object.
            </summary>
            <param name="dispatch"></param>
        </member>
        <member name="P:SharpRemote.InvokeAttribute.DispatchingStrategy">
            <summary>
                The precise strategy with which the attributed method shall be invoked.
            </summary>
        </member>
        <member name="T:SharpRemote.IProxy">
            <summary>
            Tag interface for a proxy implementation of a specific interface.
            Is responsible for delegating method invocations over a remoting channel
            to its actual implementation.
            </summary>
        </member>
        <member name="T:SharpRemote.ISerializer">
            <summary>
                Interface for the serializer that must be capable of serializing arbitrary object graphs.
            </summary>
        </member>
        <member name="M:SharpRemote.ISerializer.RegisterType``1">
            <summary>
                Registers the given type <typeparamref name="T" /> with this serializer.
            </summary>
            <remarks>
                This method can be used to verify upfront that:
                - A used type can be serialized
                - No intermittent compilation happens while writing / reading an object graph
            </remarks>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.ArgumentNullException">When <typeparamref name="T" /> is null</exception>
            <exception cref="T:System.ArgumentException">When the type cannot be serialized</exception>
            <exception cref="T:SharpRemote.SerializationException">
                In case there was an error while generating the code necessary for
                serialization / deserialization
            </exception>
        </member>
        <member name="M:SharpRemote.ISerializer.RegisterType(System.Type)">
            <summary>
                Registers the given type <paramref name="type" /> with this serializer.
            </summary>
            <remarks>
                This method can be used to verify upfront that:
                - A used type can be serialized
                - No intermittent compilation happens while writing / reading an object graph
            </remarks>
            <param name="type">The type to register</param>
            <exception cref="T:System.ArgumentNullException">When <paramref name="type" /> is null</exception>
            <exception cref="T:System.ArgumentException">When the type cannot be serialized</exception>
            <exception cref="T:SharpRemote.SerializationException">
                In case there was an error while generating the code necessary for
                serialization / deserialization
            </exception>
        </member>
        <member name="M:SharpRemote.ISerializer.IsTypeRegistered``1">
            <summary>
                Tests if the given type <typeparamref name="T" /> has already been registered
                with this serializer (either directly through <see cref="M:SharpRemote.ISerializer.RegisterType(System.Type)" /> or indirectly
                through <see cref="M:SharpRemote.ISerializer.WriteObject(System.IO.BinaryWriter,System.Object,SharpRemote.IRemotingEndPoint)" /> or <see cref="M:SharpRemote.ISerializer.ReadObject(System.IO.BinaryReader,SharpRemote.IRemotingEndPoint)" />).
            </summary>
            <typeparam name="T">The type to test</typeparam>
            <returns>True if the type has been registered, false otherwise</returns>
        </member>
        <member name="M:SharpRemote.ISerializer.IsTypeRegistered(System.Type)">
            <summary>
                Tests if the given type <paramref name="type" /> has already been registered
                with this serializer (either directly through <see cref="M:SharpRemote.ISerializer.RegisterType(System.Type)" /> or indirectly
                through <see cref="M:SharpRemote.ISerializer.WriteObject(System.IO.BinaryWriter,System.Object,SharpRemote.IRemotingEndPoint)" /> or <see cref="M:SharpRemote.ISerializer.ReadObject(System.IO.BinaryReader,SharpRemote.IRemotingEndPoint)" />).
            </summary>
            <param name="type">The type to test</param>
            <returns>True if the type has been registered, false otherwise</returns>
        </member>
        <member name="M:SharpRemote.ISerializer.WriteObject(System.IO.BinaryWriter,System.Object,SharpRemote.IRemotingEndPoint)">
            <summary>
                Writes the given object graph using the given <paramref name="writer" />.
                If the type is not registered yet, then it will be.
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="endPoint"></param>
            <exception cref="T:SharpRemote.SerializationException">
                In case there was an error while generating the code necessary for
                serialization / deserialization
            </exception>
        </member>
        <member name="M:SharpRemote.ISerializer.ReadObject(System.IO.BinaryReader,SharpRemote.IRemotingEndPoint)">
            <summary>
                Reads the next object graph using the given <paramref name="reader" />.
                If the type is not registered yet, then it will be.
            </summary>
            <param name="reader"></param>
            <param name="endPoint"></param>
            <returns></returns>
            <exception cref="T:SharpRemote.SerializationException">
                In case there was an error while generating the code necessary for
                serialization / deserialization
            </exception>
        </member>
        <member name="M:SharpRemote.ISerializer.GetType(System.String)">
            <summary>
                Resolves a type by its name.
            </summary>
            <param name="assemblyQualifiedTypeName"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.IServant">
            <summary>
            Tag interface for a servant implementation of a specific interface.
            Is responsible for invoking remote method invocations from a remoting channel
            to its actual implementation.
            </summary>
        </member>
        <member name="P:SharpRemote.IServant.Subject">
            <summary>
            The subject who's methods are being invoked.
            </summary>
        </member>
        <member name="T:SharpRemote.SingletonFactoryMethodAttribute">
            <summary>
                Indicates that a method or a readable property be a factory method to produce
                instance of the type it's attached to.
            </summary>
        </member>
        <member name="T:SharpRemote.ITypeResolver">
            <summary>
            The interface to resolve types by their assembly qualified names.
            Can be implemented and given to the serializer, when <see cref="M:System.Type.GetType(System.String)"/> is
            insufficient.
            </summary>
        </member>
        <member name="M:SharpRemote.ITypeResolver.GetType(System.String)">
            <summary>
            Is called whenever a type object needs to be serialized.
            </summary>
            <param name="assemblyQualifiedTypeName"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.LogInterceptor">
            <summary>
            Log4net appender that delegates all log events to a user specified action.
            </summary>
        </member>
        <member name="M:SharpRemote.LogInterceptor.#ctor(System.Action{log4net.Core.LoggingEvent},log4net.Core.Level)">
            <summary>
            
            </summary>
            <param name="logAction"></param>
            <param name="level"></param>
        </member>
        <member name="T:SharpRemote.Tasks.SerialTaskScheduler">
            <summary>
                Executes scheduled delegates in a serial manner.
            </summary>
            <remarks>
                Only tasks with the proper access token are executed in a serial manner, all others are executed in parallel.
            </remarks>
        </member>
        <member name="F:SharpRemote.Tasks.SerialTaskScheduler.DeactivationThreshold">
            <summary>
                The amount of time that must pass without having done any work before the thread is shut-down.
            </summary>
        </member>
        <member name="M:SharpRemote.Tasks.SerialTaskScheduler.#ctor(System.TimeSpan,System.Boolean)">
            <summary>
                Initializes this object.
            </summary>
            <param name="deactivationThreshold"></param>
            <param name="logExceptions"></param>
        </member>
        <member name="M:SharpRemote.Tasks.SerialTaskScheduler.#ctor(System.String,System.String,System.Nullable{System.Int64},System.Boolean)">
            <summary>
                Initializes a new instance of this task scheduler.
            </summary>
            <param name="methodName"></param>
            <param name="objectId"></param>
            <param name="logExceptions"></param>
            <param name="typeName"></param>
        </member>
        <member name="P:SharpRemote.Tasks.SerialTaskScheduler.Exceptions">
            <summary>
                The list of all exceptions thrown during task execution.
                Is only captured when logExceptions was set to true upon construction.
            </summary>
            <remarks>
                Only used for testing.
            </remarks>
        </member>
        <member name="P:SharpRemote.Tasks.SerialTaskScheduler.IsExecutingThreadRunning">
            <summary>
                Tests if the task that executes all pending tasks is currently running or not.
                It will be stopped when no tasks have been queued for a certain time.
            </summary>
        </member>
        <member name="M:SharpRemote.Tasks.SerialTaskScheduler.Dispose">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.Tasks.SerialTaskScheduler.QueueTask``1(System.Func{``0},System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
                Enqueues the given task to this scheduler: It will be executed
                once all previous tasks have finished or failed.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fn"></param>
            <param name="completionSource"></param>
        </member>
        <member name="M:SharpRemote.Tasks.SerialTaskScheduler.QueueTask``1(System.Func{``0})">
            <summary>
                Enqueues the given task to this scheduler: It will be executed
                once all previous tasks have finished or failed.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fn"></param>
        </member>
        <member name="M:SharpRemote.Tasks.SerialTaskScheduler.QueueTask(System.Action,System.Threading.Tasks.TaskCompletionSource{System.Int32})">
            <summary>
                Enqueues the given task to this scheduler: It will be executed
                once all previous tasks have finished or failed.
            </summary>
            <param name="fn"></param>
            <param name="completionSource"></param>
        </member>
        <member name="M:SharpRemote.Tasks.SerialTaskScheduler.QueueTask(System.Action)">
            <summary>
                Enqueues the given task to this scheduler: It will be executed
                once all previous tasks have finished or failed.
            </summary>
            <param name="fn"></param>
        </member>
        <member name="M:SharpRemote.TypeExtensions.GetRealCustomAttribute``1(System.Type,System.Boolean)">
            <summary>
            Retrieves the first custom attribute type <typeparamref name="T"/> from the given
            type, including its base classes and interfaces.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <param name="inherited"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.Clock.ITimer">
            <summary>
            The interface responsible to translate <see cref="T:System.DateTime"/> values from a remote clock into <see cref="T:System.DateTime"/>
            values of a local clock.
            </summary>
        </member>
        <member name="P:SharpRemote.Clock.ITimer.AbsoluteDrift">
            <summary>
            The absolute drift between the two clocks that would be present without correction
            since this timer has been created.
            </summary>
        </member>
        <member name="M:SharpRemote.Clock.ITimer.AddTimeMeasurement(System.DateTime,System.DateTime,System.DateTime)">
            <summary>
            Adds a time-measurement 
            </summary>
            <param name="localMinimum"></param>
            <param name="remote"></param>
            <param name="localMaximum"></param>
        </member>
        <member name="M:SharpRemote.Clock.ITimer.ToLocalTime(System.DateTime,System.TimeSpan@)">
            <summary>
            Translates the given <see cref="T:System.DateTime"/> value from the remote source
            into a local <see cref="T:System.DateTime"/> value so that both values represent
            the same point in time (but account for the fact that both sources may use different clocks).
            </summary>
            <param name="remoteTime"></param>
            <param name="accuracy"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.MethodDescription">
            <summary>
                Similar to <see cref="T:System.Reflection.MethodInfo" /> (in that it describes a particular .NET method), but only
                describes its static structure that is important to a <see cref="T:SharpRemote.ISerializer" />.
            </summary>
        </member>
        <member name="M:SharpRemote.MethodDescription.#ctor">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.MethodDescription.Method">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.MethodDescription.IsAsync">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.MethodDescription.ReturnParameter">
            <summary>
                The equivalent of <see cref="P:System.Reflection.MethodInfo.ReturnParameter" />.
            </summary>
        </member>
        <member name="P:SharpRemote.MethodDescription.ReturnType">
            <summary>
                The equivalent of <see cref="P:System.Reflection.MethodInfo.ReturnType" />.
            </summary>
        </member>
        <member name="P:SharpRemote.MethodDescription.Parameters">
            <summary>
                The equivalent of <see cref="M:System.Reflection.MethodBase.GetParameters" />.
            </summary>
        </member>
        <member name="P:SharpRemote.MethodDescription.SpecialMethod">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.MethodDescription.Name">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.MethodDescription.ToString">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.MethodDescription.Create(System.Reflection.MethodInfo,System.Collections.Generic.IDictionary{System.String,SharpRemote.TypeDescription})">
            <summary>
            </summary>
            <param name="methodInfo"></param>
            <param name="typesByAssemblyQualifiedName"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.SpecialMethod">
            <summary>
            </summary>
        </member>
        <member name="F:SharpRemote.SpecialMethod.None">
            <summary>
                The method's not special at all.
            </summary>
        </member>
        <member name="F:SharpRemote.SpecialMethod.BeforeSerialize">
            <summary>
            </summary>
        </member>
        <member name="F:SharpRemote.SpecialMethod.AfterSerialize">
            <summary>
            </summary>
        </member>
        <member name="F:SharpRemote.SpecialMethod.BeforeDeserialize">
            <summary>
            </summary>
        </member>
        <member name="F:SharpRemote.SpecialMethod.AfterDeserialize">
            <summary>
            </summary>
        </member>
        <member name="T:SharpRemote.TypeDescription">
            <summary>
                Similar to <see cref="P:SharpRemote.TypeDescription.Type" /> (in that it describes a particular .NET type), but only
                describes its static structure that is important to a <see cref="T:SharpRemote.ISerializer" />.
            </summary>
        </member>
        <member name="F:SharpRemote.TypeDescription.BuiltInTypes">
            <summary>
                The list of types for which SharpRemote has built-in (de)serialization methods.
            </summary>
        </member>
        <member name="M:SharpRemote.TypeDescription.#ctor">
            <summary>
                Initializes this object.
            </summary>
        </member>
        <member name="M:SharpRemote.TypeDescription.#ctor(System.Type,System.Type)">
            <summary>
                Initializes this object.
            </summary>
            <param name="type"></param>
            <param name="byReferenceInterfaceType"></param>
        </member>
        <member name="P:SharpRemote.TypeDescription.Type">
            <summary>
            The type being described by this object.
            </summary>
        </member>
        <member name="P:SharpRemote.TypeDescription.ByReferenceInterfaceType">
            <summary>
            The type being described by this object.
            </summary>
        </member>
        <member name="P:SharpRemote.TypeDescription.Id">
            <summary>
                An id which differentiates this object amongst all others for the same
                <see cref="T:SharpRemote.TypeModel" />.
            </summary>
        </member>
        <member name="P:SharpRemote.TypeDescription.StorageType">
            <summary>
                The underlying type used for storing values.
            </summary>
            <remarks>
                Relevant for enums.
            </remarks>
        </member>
        <member name="P:SharpRemote.TypeDescription.Properties">
            <summary>
                The list of public non-static properties with the <see cref="T:System.Runtime.Serialization.DataMemberAttribute" />.
            </summary>
        </member>
        <member name="P:SharpRemote.TypeDescription.Fields">
            <summary>
                The list of public non-static fields with the <see cref="T:System.Runtime.Serialization.DataMemberAttribute" />.
            </summary>
        </member>
        <member name="P:SharpRemote.TypeDescription.Methods">
            <summary>
                The list of public non-static methods in case this is a <see cref="F:SharpRemote.SerializationType.ByReference" />
                type.
            </summary>
        </member>
        <member name="P:SharpRemote.TypeDescription.EnumValues">
            <summary>
               The list of enum values.
            </summary>
        </member>
        <member name="P:SharpRemote.TypeDescription.GenericArguments">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.TypeDescription.GenericArgumentTypeIds">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.TypeDescription.BaseTypeId">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.TypeDescription.BaseType">
            <summary>
                Equivalent of <see cref="P:System.Type.BaseType" />.
            </summary>
        </member>
        <member name="P:SharpRemote.TypeDescription.AssemblyQualifiedName">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.TypeDescription.SerializationType">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.TypeDescription.IsClass">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.TypeDescription.IsEnum">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.TypeDescription.IsEnumerable">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.TypeDescription.IsInterface">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.TypeDescription.IsValueType">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.TypeDescription.IsSealed">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.TypeDescription.IsBuiltIn">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.TypeDescription.IsGenericType">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.TypeDescription.ToString">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.TypeDescription.GetOrCreate(System.Type,System.Collections.Generic.IDictionary{System.String,SharpRemote.TypeDescription})">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="typesByAssemblyQualifiedName"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.TypeDescription.Create(System.Type,System.Collections.Generic.IDictionary{System.String,SharpRemote.TypeDescription},System.Boolean)">
            <summary>
                Creates a new description for the given type.
            </summary>
            <param name="type"></param>
            <param name="typesByAssemblyQualifiedName"></param>
            <param name="assumeByReference"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.TypeDescription.IsException(System.Type)">
            <summary>
            Tests if the given type is <see cref="T:System.Exception"/> or inherits from it.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.TypeInformation">
            <summary>
                TODO: Remove once <see cref="T:SharpRemote.ITypeDescription" /> is used throughout.
            </summary>
        </member>
        <member name="T:SharpRemote.AbstractBinaryStreamEndPoint`1">
            <summary>
                Base class for any remoting end point.
            </summary>
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.NumBytesSent">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.NumBytesReceived">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.NumMessagesSent">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.NumMessagesReceived">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.NumCallsInvoked">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.NumCallsAnswered">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.NumPendingMethodCalls">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.AverageRoundTripTime">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.#ctor(SharpRemote.GrainIdGenerator,System.String,SharpRemote.EndPointType,SharpRemote.IAuthenticator,SharpRemote.IAuthenticator,SharpRemote.CodeGeneration.ICodeGenerator,SharpRemote.HeartbeatSettings,SharpRemote.LatencySettings,SharpRemote.EndPointSettings,System.Boolean)">
            <summary>
                Initializes this object.
            </summary>
            <param name="idGenerator"></param>
            <param name="name"></param>
            <param name="type"></param>
            <param name="clientAuthenticator"></param>
            <param name="serverAuthenticator"></param>
            <param name="codeGenerator"></param>
            <param name="heartbeatSettings"></param>
            <param name="latencySettings"></param>
            <param name="endPointSettings"></param>
            <param name="waitUponReadWriteError"></param>
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.Socket">
            <summary>
                The socket used to communicate with the other endpoint.
            </summary>
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.InternalLocalEndPoint">
            <summary>
                The endpoint-address of this endpoint.
            </summary>
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.InternalRemoteEndPoint">
            <summary>
                The endpoint-address of this endpoint we're connected to, or null.
            </summary>
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.NumProxiesCollected">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.NumServantsCollected">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.TotalGarbageCollectionTime">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.LatencySettings">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.HeartbeatSettings">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.EndPointSettings">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.NumPendingMethodInvocations">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.IsDisposed">
            <summary>
                Tests if this object has been disposed of or not.
            </summary>
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.DisconnectReason">
            <summary>
                Contains the reason why the endpoint was disconnected, or null if it wasn't disconnected / never established
                a connection.
            </summary>
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.SyncRoot">
            <summary>
                The lock used to ensure that certain sections are not executed in parallel
                (mostly to do with connecting/disconnecting).
            </summary>
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.Proxies">
            <summary>
                Returns all the proxies of this endpoint.
                Used for testing.
            </summary>
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.Servants">
            <summary>
                Returns all the servants of this endpoint.
                Used for testing.
            </summary>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.CallRemoteMethodAsync(System.UInt64,System.String,System.String,System.IO.MemoryStream)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.CallRemoteMethod(System.UInt64,System.String,System.String,System.IO.MemoryStream)">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.LocalEndPoint">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.RemoteEndPoint">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.Name">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.IsConnected">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.CurrentConnectionId">
            <inheritdoc />
        </member>
        <member name="P:SharpRemote.AbstractBinaryStreamEndPoint`1.RoundtripTime">
            <summary>
               The average roundtrip time of empty method calls between this and the remote
               endpoint.
            </summary>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.Disconnect">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.CreateProxy``1(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.GetProxy``1(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.CreateServant``1(System.UInt64,``0)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.RetrieveSubject``1(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.GetExistingOrCreateNewProxy``1(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.GetExistingOrCreateNewServant``1(``0)">
            <inheritdoc />
        </member>
        <member name="E:SharpRemote.AbstractBinaryStreamEndPoint`1.OnConnected">
            <summary>
                Is called when a connection with another <see cref="T:SharpRemote.AbstractBinaryStreamEndPoint`1" />
                is created.
            </summary>
            <remarks>
                The event is fired with the endpoint of the *other* <see cref="T:SharpRemote.AbstractBinaryStreamEndPoint`1" />.
            </remarks>
        </member>
        <member name="E:SharpRemote.AbstractBinaryStreamEndPoint`1.OnDisconnected">
            <summary>
                Is called when a connection with another <see cref="T:SharpRemote.AbstractBinaryStreamEndPoint`1" /> is disconnected.
            </summary>
        </member>
        <member name="E:SharpRemote.AbstractBinaryStreamEndPoint`1.OnFailure">
            <summary>
                This event is invoked right before an endpoint's connection is to be closed due to failure of:
                - the connection between endpoints
                - a failure of the remote process
                - a failure of SharpRemote
                - something else ;)
            </summary>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.IsFailure(SharpRemote.EndPointDisconnectReason)">
            <summary>
                Tests if the given disconnect reason indicates a failure of the connection
                or rather an intentional disconnect.
            </summary>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.DisposeAdditional">
            <summary>
                Called when <see cref="M:SharpRemote.AbstractBinaryStreamEndPoint`1.Dispose" /> is called.
            </summary>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.DisconnectByFailure">
            <summary>
                Performs a "hard" disconnect as if a failure occured.
                Is used to implement certain unit-tests where the connection
                failed (cable disconnected, etc...).
            </summary>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.CreateDisconnectExplanation(SharpRemote.EndPointDisconnectReason)">
            <summary>
               Creates an explanation as to why the connection was disconnected.
               This is most likely due to external circumstances (such as the cabling having been removed,
               the other side crashing, etc..) and this method tries to find a way to explain that
               to a human in simple terms.
            </summary>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.DisconnectTransport(`0,System.Boolean)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <param name="reuseSocket"></param>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.DisposeAfterDisconnect(`0)">
            <summary>
            
            </summary>
            <param name="socket"></param>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.ClearPendingMethodInvocations">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.ClearTransientProxies">
            <summary>
            Removes all those proxies which were created because the other endpoint
            created (likely temporary) servants and sent them over the network.
            </summary>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.FireOnConnected(System.Net.EndPoint,SharpRemote.ConnectionId)">
            <summary>
            
            </summary>
            <param name="remoteEndPoint"></param>
            <param name="connectionId"></param>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.SendGoodbye(`0,System.TimeSpan)">
            <summary>
                Sends a goodbye message over the socket.
            </summary>
            <param name="socket"></param>
            <param name="waitTime"></param>
            <returns>True when the goodbye message could be sent, false otherwise</returns>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.SendGoodbye(`0,System.Int64,System.TimeSpan)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <param name="waitTime"></param>
            <param name="timeSpan"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.Send(`0,System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="size"></param>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.ReadMessage(`0,System.TimeSpan,System.String,System.String@,System.String@)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <param name="timeout"></param>
            <param name="messageStep"></param>
            <param name="messageType"></param>
            <param name="message"></param>
            <exception cref="T:SharpRemote.HandshakeException"></exception>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.WriteMessage(`0,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <param name="messageType"></param>
            <param name="message"></param>
            <exception cref="T:SharpRemote.HandshakeException"></exception>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.GetRemoteEndPointOf(`0)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.SendConnectionBlocked(`0)">
            <summary>
            
            </summary>
            <param name="socket"></param>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.PerformIncomingHandshake(`0,System.Net.EndPoint)">
            <summary>
                Performs the authentication between client and server (if necessary) from the server-side.
            </summary>
            <param name="socket"></param>
            <param name="remoteEndPoint"></param>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.TryPerformOutgoingHandshake(`0,System.TimeSpan,SharpRemote.AbstractBinaryStreamEndPoint{`0}.ErrorType@,System.String@,SharpRemote.ConnectionId@,System.Object@)">
            <summary>
                Performs the authentication between client and server (if necessary) from the client-side.
            </summary>
            <param name="socket"></param>
            <param name="timeout"></param>
            <param name="errorType"></param>
            <param name="error"></param>
            <param name="currentConnectionId"></param>
            <param name="errorReason"></param>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.TryParseEndPoint(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.OnHandshakeSucceeded(`0,System.Net.EndPoint)">
            <summary>
                Is called when the handshake for the newly incoming message succeeds.
            </summary>
            <param name="socket"></param>
            <param name="remoteEndPoint"></param>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.WriteLoop(System.Object)">
            <summary>
                This method blocks and writes to the given <see cref="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ThreadArgs.Socket" /> until
                the socket has been disposed of or the <see cref="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ThreadArgs.Token" /> has been canceled.
            </summary>
            <param name="sock"></param>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.ReadLoop(System.Object)">
            <summary>
                This method blocks and reads from the given <see cref="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ThreadArgs.Socket" /> until
                the socket has been disposed of or the <see cref="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ThreadArgs.Token" /> has been canceled.
            </summary>
            <param name="sock"></param>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.SynchronizedWrite(`0,System.Byte[],System.Int32,SharpRemote.EndPointDisconnectReason@)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <param name="data"></param>
            <param name="length"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.SynchronizedRead(`0,System.Byte[],System.TimeSpan,SharpRemote.EndPointDisconnectReason@)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <param name="buffer"></param>
            <param name="timeout"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.SynchronizedRead(`0,System.Byte[],SharpRemote.EndPointDisconnectReason@)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <param name="buffer"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.AbstractBinaryStreamEndPoint`1.ErrorType">
            <summary>
            Describes the error which occured because of which the
            connection is being dropped.
            </summary>
        </member>
        <member name="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ErrorType.None">
            <summary>
            No error occured.
            </summary>
        </member>
        <member name="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ErrorType.Handshake">
            <summary>
            The error occured during the handshake:
            This happens when the target isn't a proper SharpRemote endpoint.
            </summary>
        </member>
        <member name="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ErrorType.Authentication">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ErrorType.AuthenticationRequired">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ErrorType.EndPointBlocked">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpRemote.AbstractBinaryStreamEndPoint`1.ThreadArgs">
            <summary>
            The structure given to <see cref="M:SharpRemote.AbstractBinaryStreamEndPoint`1.ReadLoop(System.Object)"/>
            and <see cref="M:SharpRemote.AbstractBinaryStreamEndPoint`1.WriteLoop(System.Object)"/>.
            </summary>
        </member>
        <member name="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ThreadArgs.ConnectionId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ThreadArgs.Socket">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpRemote.AbstractBinaryStreamEndPoint`1.ThreadArgs.Token">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpRemote.AbstractBinaryStreamEndPoint`1.ThreadArgs.#ctor(`0,System.Threading.CancellationToken,SharpRemote.ConnectionId)">
            <summary>
            
            </summary>
            <param name="socket"></param>
            <param name="token"></param>
            <param name="connectionId"></param>
        </member>
        <member name="T:SharpRemote.IRemotingEndPoint">
            <summary>
                Represents an endpoint in that can establish a connection to exactly one other
                endpoint in the same / different AppDomain, Process or Machine.
            </summary>
            <remarks>
                There can only be one endpoint *per* <see cref="T:System.Net.IPEndPoint" /> *per* machine.
            </remarks>
        </member>
        <member name="P:SharpRemote.IRemotingEndPoint.IsConnected">
            <summary>
                Whether or not this endpoint is connected to another one.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingEndPoint.NumServantsCollected">
            <summary>
                The total number of <see cref="T:SharpRemote.IServant" />s that have been removed from this endpoint because
                their subjects have been collected by the GC.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingEndPoint.NumProxiesCollected">
            <summary>
                The total number of <see cref="T:SharpRemote.IProxy" />s that have been removed from this endpoint because
                they're no longer used.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingEndPoint.CurrentConnectionId">
            <summary>
            The id of the current connection or <see cref="F:SharpRemote.ConnectionId.None"/> if no connection
            is currently established.
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingEndPoint.RemoteEndPoint">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpRemote.IRemotingEndPoint.Proxies">
            <summary>
                Returns all the proxies of this endpoint.
            </summary>
        </member>
        <member name="E:SharpRemote.IRemotingEndPoint.OnConnected">
            <summary>
            Is called when a connection with another <see cref="T:SharpRemote.IRemotingEndPoint"/>
            is created.
            </summary>
            <remarks>
            The event is fired with the endpoint of the *other* <see cref="T:SharpRemote.IRemotingEndPoint"/>.
            </remarks>
        </member>
        <member name="E:SharpRemote.IRemotingEndPoint.OnDisconnected">
            <summary>
            Is called when a connection with another <see cref="T:SharpRemote.IRemotingEndPoint"/> is disconnected.
            </summary>
        </member>
        <member name="E:SharpRemote.IRemotingEndPoint.OnFailure">
            <summary>
                This event is invoked right before a socket is to be closed due to failure of:
                - the connection between endpoints
                - a failure of the remote process
                - a failure of SharpRemote
                - something else ;)
            </summary>
        </member>
        <member name="M:SharpRemote.IRemotingEndPoint.Disconnect">
            <summary>
                Disconnects this endpoint from its remote endpoint.
            </summary>
            <remarks>
                When this endpoint is not connected to a remot endpoint in the first place, then this method does nothing.
            </remarks>
        </member>
        <member name="M:SharpRemote.IRemotingEndPoint.CreateServant``1(System.UInt64,``0)">
            <summary>
                Creates and registers a servant for the given subject <paramref name="subject" /> under the given
                <paramref name="objectId" />,
                giving another connected <see cref="T:SharpRemote.IRemotingEndPoint" /> the ability to call the subject's methods via a proxy
                (<see cref="M:SharpRemote.IRemotingEndPoint.CreateProxy``1(System.UInt64)" />).
            </summary>
            <remarks>
                A servant is responsible for invoking RPCs on the original subject whenever they are called through a proxy.
                If the interfaces <typeparamref name="T"/> methods are attributed with the <see cref="T:SharpRemote.InvokeAttribute"/>,
                then the servant will ensure that methods are invoked with the specified synchronization.
            </remarks>
            <remarks>
                A servant can be created independent from any proxy and the order in which both are created is unimportant, for as
                long as no interface methods / properties are invoked.
            </remarks>
            <remarks>
                This method is thread-safe.
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="objectId"></param>
            <param name="subject"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.IRemotingEndPoint.RetrieveSubject``1(System.UInt64)">
            <summary>
                Retrieves the subject that was previously registered at this end-point via <see cref="M:SharpRemote.IRemotingEndPoint.CreateServant``1(System.UInt64,``0)" />
                (and has not yet been garbage collected).
            </summary>
            <remarks>
                This method is thread-safe.
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="objectId">The objectId that has been given to this endpoint when registering a servant for the subject</param>
            <returns>The subject that was registered or null if the subject has been garbage collected already</returns>
        </member>
        <member name="M:SharpRemote.IRemotingEndPoint.GetExistingOrCreateNewServant``1(``0)">
            <summary>
                If a servant has already been registered (via <see cref="M:SharpRemote.IRemotingEndPoint.CreateServant``1(System.UInt64,``0)" /> or this method),
                then it is returned. Otherwise a new servant will be registered.
            </summary>
            <remarks>
                This method is thread-safe.
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="subject"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.IRemotingEndPoint.CreateProxy``1(System.UInt64)">
            <summary>
                Creates and registers an object that implements the given interface <typeparamref name="T" />.
                Calls to properties / methods of the given interface are marshalled to connected endpoint, if an appropriate
                servant of the same interface an <paramref name="objectId" /> has been created using <see cref="M:SharpRemote.IRemotingEndPoint.CreateServant``1(System.UInt64,``0)" />.
            </summary>
            <remarks>
                A proxy can be created independent from its servant and the order in which both are created is unimportant, for as long
                as no interface methods / properties are invoked.
            </remarks>
            <remarks>
                Every method / property on the given object is now capable of throwing an additional set of exceptions, in addition
                to whatever exceptions any implementation already throws:
                - <see cref="T:SharpRemote.NoSuchServantException" />: There's no servant with the id of the proxy and therefore no subject on which the method could possibly be executed
                - <see cref="T:SharpRemote.NotConnectedException" />: At the time of calling the proxy's method, no connection to a remote end point was available
                - <see cref="T:SharpRemote.ConnectionLostException" />: The method call was canceled because the connection between proxy and servant was interrupted / lost / disconnected
                - <see cref="T:SharpRemote.UnserializableException" />: The remote method was executed, threw an exception, but the exception could not be serialized
            </remarks>
            <remarks>
                This method is thread-safe.
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="objectId"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When there already exists a proxy of id <paramref name="objectId" />.
            </exception>
            <exception cref="T:System.ArgumentException">
                When <typeparamref name="T" /> does not refer to an interface.
            </exception>
        </member>
        <member name="M:SharpRemote.IRemotingEndPoint.GetProxy``1(System.UInt64)">
            <summary>
            Returns the proxy that belongs to the given object-id.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="objectId"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">When there's no proxy with that id</exception>
            <exception cref="T:System.ArgumentException">When there proxy's type does not match the given <typeparamref name="T"/> type parameter</exception>
        </member>
        <member name="M:SharpRemote.IRemotingEndPoint.GetExistingOrCreateNewProxy``1(System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="objectId"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.IEndPointChannel">
            <summary>
            The interface to forward a method call to a remote endpoint and return its response.
            </summary>
        </member>
        <member name="M:SharpRemote.IEndPointChannel.CallRemoteMethodAsync(System.UInt64,System.String,System.String,System.IO.MemoryStream)">
            <summary>
            Forwards a method call to the given servant or proxy.
            </summary>
            <remarks>
            The returned task throws if
            - no servant / proxy with the given id exists
            - the servant / proxy doesn't implement the given interface
            - the method doesn't exist
            - The arguments are malformatted
            </remarks>
            <param name="servantId"></param>
            <param name="interfaceType"></param>
            <param name="methodName"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.IEndPointChannel.CallRemoteMethod(System.UInt64,System.String,System.String,System.IO.MemoryStream)">
            <summary>
            Forwards a method call to the given servant or proxy.
            </summary>
            <remarks>
            Throws if
            - no servant / proxy with the given id exists
            - the servant / proxy doesn't implement the given interface
            - the method doesn't exist
            - The arguments are malformatted
            </remarks>
            <param name="servantId"></param>
            <param name="interfaceType"></param>
            <param name="methodName"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.TypeId">
            <summary>
                A globally (seriously) unique identifier for a <see cref="T:SharpRemote.ITypeDescription" /> and its .NET type.
            </summary>
        </member>
        <member name="M:SharpRemote.TypeId.Equals(SharpRemote.TypeId)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.TypeId.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.TypeId.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.TypeId.op_Equality(SharpRemote.TypeId,SharpRemote.TypeId)">
            <summary>
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.TypeId.op_Inequality(SharpRemote.TypeId,SharpRemote.TypeId)">
            <summary>
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="P:SharpRemote.TypeId.SerializedValue">
            <summary>
            </summary>
        </member>
        <member name="P:SharpRemote.TypeId.Value">
            <summary>
                The actual value of this id.
            </summary>
        </member>
        <member name="T:SharpRemote.TypeModel">
            <summary>
                A representation of all types registered with a <see cref="T:SharpRemote.ISerializer" />.
                This representation describes each type (as far as serialization is concerned) and
                may be serialized/deserialized *without* requiring that the types describes by this type model
                can be loaded.
            </summary>
        </member>
        <member name="M:SharpRemote.TypeModel.#ctor">
            <summary>
                Initializes this object.
            </summary>
        </member>
        <member name="M:SharpRemote.TypeModel.TryResolveTypes(SharpRemote.ITypeResolver)">
            <summary>
            
            </summary>
            <param name="typeResolver"></param>
        </member>
        <member name="P:SharpRemote.TypeModel.Types">
            <inheritdoc />
        </member>
        <member name="M:SharpRemote.TypeModel.Get``1">
            <summary>
            Returns the type description for the given type.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.TypeModel.Get(System.Type)">
            <summary>
            Returns the type description for the given type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.TypeModel.Add``1(System.Boolean)">
            <summary>
                Adds the given <typeparamref name="T" /> to this model.
            </summary>
            <param name="assumeByReference"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SharpRemote.TypeModel.Add(System.Type,System.Boolean)">
            <summary>
                Adds the given <paramref name="type" /> to this model.
            </summary>
            <param name="type"></param>
            <param name="assumeByReference"></param>
            <exception cref="T:System.ArgumentNullException">When <paramref name="type" /> is null</exception>
        </member>
        <member name="M:SharpRemote.TypeModel.Contains``1">
            <summary>
                Tests if the given type has been added to this model.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SharpRemote.TypeModel.Contains(System.Type)">
            <summary>
                Tests if the given type has been added to this model.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:SharpRemote.TypeModel.AfterDeserialize">
            <summary>
                This method is called right after deserialization and restores all references in this type
                model (this is only necessary because the <see cref="T:SharpRemote.ISerializer" /> implementation only
                works with directed acyclic graphs and a type model, naturally, contains cycles).
            </summary>
        </member>
        <member name="T:SharpRemote.TypeModelComparer">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpRemote.TypeModelComparer.IsCompatible``1(SharpRemote.TypeModel)">
            <summary>
               Verifies if the given (remote) type model implements the expected interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface"></typeparam>
            <param name="remoteTypeModel"></param>
            <returns>True if the type model implements the interface and supports all methods offered by that interface, false otherwise</returns>
        </member>
        <member name="M:SharpRemote.TypeModelComparer.IsCompatible(SharpRemote.TypeModel,System.Type)">
            <summary>
               Verifies if the given (remote) type model implements the expected interface <paramref name="expectedInterface"/>.
            </summary>
            <param name="remoteTypeModel"></param>
            <param name="expectedInterface"></param>
            <returns>True if the type model implements the interface and supports all methods offered by that interface, false otherwise</returns>
        </member>
        <member name="T:SharpRemote.InstallationFailedException">
            <summary>
            Is thrown in case an installation failed.
            </summary>
        </member>
        <member name="M:SharpRemote.InstallationFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization ctor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:SharpRemote.InstallationFailedException.#ctor">
            <summary>
            Initializes a new instance of this exception.
            </summary>
        </member>
        <member name="M:SharpRemote.InstallationFailedException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of this exception with the given message and inner exception that is the cause of this exception.
            </summary>
            <param name="message"></param>
            <param name="inner"></param>
        </member>
        <member name="T:SharpRemote.WeakKeyDictionary`2">
            <summary>
            A dictionary that maps keys to values. Contrary to <see cref="T:System.Collections.Generic.Dictionary`2"/>
            keys are stored in a <see cref="T:System.WeakReference"/> and thus entries in this dictionary
            will automatically be removed (No longer visible)
            </summary>
        </member>
        <member name="M:SharpRemote.WeakKeyDictionary`2.Add(`0,`1)">
            <summary>
            Adds the given key-value pair to this dictionary.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpRemote.WeakKeyDictionary`2.ContainsKey(`0)">
            <summary>
            Tests if the given key is part of this dictionary and returns true if it is, false otherwise.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.WeakKeyDictionary`2.FindEntry(`0)">
            <summary>
            Finds the first occurence of the given key and returns its index, or -1 if it doesn't exist.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:SharpRemote.NativeMethods">
            <summary>
                Provides access to native methods from "SharpRemote.PostmortemDebugger.dll":
                Allows interception of various failures (such as access violations, pure virtual
                function calls, assertions, etc..) and minidump creation when they occur.
            </summary>
        </member>
        <member name="M:SharpRemote.NativeMethods.OpenProcess(SharpRemote.ProcessAccessFlags,System.Boolean,System.Int32)">
            <summary>
                Opens an existing local process object.
                <see
                    href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684320%28v=vs.85%29.aspx" />
                .
            </summary>
            <param name="processAccess"></param>
            <param name="bInheritHandle"></param>
            <param name="processId"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.NativeMethods.TerminateProcess(System.IntPtr,System.UInt32)">
            <summary>
                Terminates the specified process and all of its threads.
                <see
                    href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.85%29.aspx" />
            </summary>
            <param name="hProcess"></param>
            <param name="uExitCode"></param>
            <returns></returns>
        </member>
        <member name="M:SharpRemote.NativeMethods.CloseHandle(System.IntPtr)">
            <summary>
                Closes an open object handle.
                <see
                    href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724211%28v=vs.85%29.aspx" />
            </summary>
            <param name="hObject"></param>
            <returns></returns>
        </member>
    </members>
</doc>
